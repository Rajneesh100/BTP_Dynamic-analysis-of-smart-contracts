{{
  "language": "Solidity",
  "sources": {
    "src/PointsVaultExtension.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.21;\n\nimport {Points} from \"./Points.sol\";\nimport {IUniversalVault} from \"./external/IUniversalVault.sol\";\nimport {IRageQuit} from \"./external/IRageQuit.sol\";\nimport {IInstanceRegistry} from \"./external/IInstanceRegistry.sol\";\nimport {IPointsVaultExtension} from \"./interfaces/IPointsVaultExtension.sol\";\nimport {EnumerableSet} from \"points_@openzeppelin-contracts/utils/structs/EnumerableSet.sol\";\n\ncontract PointsVaultExtension is Points, IPointsVaultExtension {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    EnumerableSet.AddressSet private vaultFactorySet;\n\n    constructor(string memory name_, string memory symbol_) Points(name_, symbol_) {}\n\n    modifier onlyValidVault(address vault) {\n        if (!isValidVault(vault)) {\n            revert InvalidVault(vault);\n        }\n        _;\n    }\n\n    /**\n     * @inheritdoc IPointsVaultExtension\n     */\n    function getVaultFactorySetLength() external view override returns (uint256 length) {\n        length = vaultFactorySet.length();\n    }\n\n    /**\n     * @inheritdoc IPointsVaultExtension\n     */\n    function getVaultFactoryAtIndex(uint256 index) external view override returns (address factory) {\n        factory = vaultFactorySet.at(index);\n    }\n\n    /**\n     * @inheritdoc IPointsVaultExtension\n     */\n    function isValidVault(address vault) public view override returns (bool validity) {\n        // validate target is created from whitelisted vault factory\n        for (uint256 index = 0; index < vaultFactorySet.length(); index++) {\n            if (IInstanceRegistry(vaultFactorySet.at(index)).isInstance(vault)) {\n                validity = true;\n                break;\n            }\n        }\n    }\n\n    /**\n     * @inheritdoc IPointsVaultExtension\n     */\n    function registerVaultFactory(address factory) external onlyOwner {\n        if (!vaultFactorySet.add(factory)) {\n            revert VaultFactoryAlreadyRegistered(factory);\n        }\n        emit VaultFactoryRegistered(factory);\n    }\n\n    /**\n     * @inheritdoc IPointsVaultExtension\n     */\n    function removeVaultFactory(address factory) external onlyOwner {\n        if (!vaultFactorySet.remove(factory)) {\n            revert VaultFactoryNotRegistered(factory);\n        }\n        emit VaultFactoryRemoved(factory);\n    }\n\n    /**\n     * @inheritdoc IPointsVaultExtension\n     */\n    function stakeToken(address vault, address token, uint128 amount, bytes calldata permission)\n        external\n        onlyValidVault(vault)\n        preConvertPendingPoints(vault, token)\n    {\n        tokenStakes[vault][token].amount += amount;\n\n        // Call lock on vault\n        IUniversalVault(vault).lock(token, amount, permission);\n\n        emit TokenVaultLocked(vault, token, amount);\n    }\n\n    /**\n     * @inheritdoc IPointsVaultExtension\n     */\n    function unstakeToken(address vault, address token, uint128 amount, bytes calldata permission)\n        external\n        preConvertPendingPoints(vault, token)\n    {\n        uint128 stakedAmount = tokenStakes[vault][token].amount;\n        if (stakedAmount < amount) {\n            revert InsufficientTokenBalance(stakedAmount, amount);\n        }\n        IUniversalVault(vault).unlock(token, amount, permission);\n        tokenStakes[vault][token].amount = stakedAmount - amount;\n\n        emit TokenVaultUnlocked(vault, token, amount);\n    }\n\n    /**\n     * @inheritdoc IRageQuit\n     */\n    function rageQuit() external {\n        for (uint256 i = 0; i < tokenAt.length; i++) {\n            address token = tokenAt[i];\n            delete tokenStakes[_msgSender()][token];\n        }\n    }\n}\n"
    },
    "src/Points.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.21;\n\nimport {Ownable} from \"points_@openzeppelin-contracts/access/Ownable.sol\";\nimport {ERC20} from \"points_@openzeppelin-contracts/token/ERC20/ERC20.sol\";\nimport {IERC20} from \"points_@openzeppelin-contracts/token/ERC20/IERC20.sol\";\nimport {IPoints} from \"./interfaces/IPoints.sol\";\n\ncontract Points is Ownable, ERC20, IPoints {\n    struct TokenStake {\n        uint128 amount;\n        uint128 cumulativeRate;\n    }\n\n    uint128 public constant RATE_DENOMINATOR = 10 ** 18;\n\n    bool internal _paused;\n\n    address public authorizedBurner;\n\n    /**\n     * @inheritdoc IPoints\n     */\n    mapping(address => bool) public isWhitelisted;\n\n    /**\n     * @inheritdoc IPoints\n     */\n    address[] public tokenAt;\n\n    // Stores the cumulative rate for each token up to the last timestamp\n    mapping(address => uint128) internal cumulativeRates;\n\n    // Stores the current rate for each token\n    mapping(address => uint96) internal _rates;\n\n    // Records the timestamp of the last transfer or rate change for each token\n    mapping(address => uint32) internal timestamps;\n\n    // User -> Token -> Amount\n    mapping(address => mapping(address => TokenStake)) internal tokenStakes;\n\n    // How much stake is required to reach each multiplier\n    // Token -> Thresholds\n    mapping(address => uint128[]) internal multiplierThresholds;\n\n    // How much to scale the rate by at each multiplier\n    // Token -> Scalars\n    mapping(address => uint128[]) internal multiplierScalars;\n\n    modifier checkPaused(address account) {\n        if (_paused && !isWhitelisted[account]) {\n            revert TransfersPaused();\n        }\n        _;\n    }\n\n    modifier preConvertPendingPoints(address account, address token) {\n        // Do not want to modify timestamps[token] if token is not supported\n        if (!tokenSupported(token)) {\n            revert TokenNotSupported(token);\n        }\n        // Updating the cumulative rate for the token and the last timestamp\n        cumulativeRates[token] += uint128(_rates[token]) * (uint32(block.timestamp) - timestamps[token]);\n        timestamps[token] = uint32(block.timestamp);\n\n        // Calculating the amount of points to mint to the account\n        TokenStake storage tokenStake = tokenStakes[account][token];\n        uint256 amountToMint =\n            calculateMintAmount(token, tokenStake.amount, cumulativeRates[token] - tokenStake.cumulativeRate);\n        _mint(account, amountToMint);\n        emit PendingPointsConverted(account, token, amountToMint);\n\n        // Updating the user's token stake\n        tokenStake.cumulativeRate = cumulativeRates[token];\n        _;\n    }\n\n    /**\n     * @dev If `super.balanceOf()` already exceeds `threshold`, it will skip converting pending points\n     */\n    modifier preConvertAllPendingPoints(address account, uint256 threshold) {\n        if (super.balanceOf(account) < threshold) {\n            convertPendingPoints(account);\n        }\n        _;\n    }\n\n    function calculateMintAmount(address token, uint128 amount, uint128 cumulativeRateDiff)\n        internal\n        view\n        returns (uint256 mintAmount)\n    {\n        mintAmount = (uint256(amount) * cumulativeRateDiff) / RATE_DENOMINATOR;\n\n        uint256 thresholdIndex;\n        for (thresholdIndex = 0; thresholdIndex < multiplierThresholds[token].length; thresholdIndex++) {\n            if (amount < multiplierThresholds[token][thresholdIndex]) {\n                break;\n            }\n        }\n        // If not greater than any threshold, don't apply a multiplier. Otherwise use the last applicable scalar.\n        if (thresholdIndex > 0) {\n            mintAmount = (mintAmount * multiplierScalars[token][thresholdIndex - 1]) / RATE_DENOMINATOR;\n        }\n    }\n\n    function convertPendingPoints(address account) public {\n        uint256 totalAmountToMint;\n        for (uint256 i = 0; i < tokenAt.length; i++) {\n            address token = tokenAt[i];\n            // Skip if the user has no stakes for the current token\n            if (tokenStakes[account][token].amount == 0) {\n                continue;\n            }\n            // Updating the cumulative rate for the token and the last timestamp\n            cumulativeRates[token] += uint128(_rates[token]) * (uint32(block.timestamp) - timestamps[token]);\n            timestamps[token] = uint32(block.timestamp);\n\n            // Calculating the amount of points to mint to the account\n            TokenStake storage tokenStake = tokenStakes[account][token];\n            uint256 amountToMint =\n                calculateMintAmount(token, tokenStake.amount, cumulativeRates[token] - tokenStake.cumulativeRate);\n            emit PendingPointsConverted(account, token, amountToMint);\n            totalAmountToMint += amountToMint;\n\n            // Updating the user's token stake\n            tokenStake.cumulativeRate = cumulativeRates[token];\n        }\n        // Minting the total amount of points to the account at the end if there are any\n        if (totalAmountToMint > 0) {\n            _mint(account, totalAmountToMint);\n        }\n    }\n\n    function convertPendingPoints(address[] calldata accounts) public {\n        for (uint256 i = 0; i < accounts.length; i++) {\n            convertPendingPoints(accounts[i]);\n        }\n    }\n\n    constructor(string memory name_, string memory symbol_) ERC20(name_, symbol_) {\n        _paused = true;\n    }\n\n    /**\n     * @inheritdoc IPoints\n     */\n    function paused() public view virtual returns (bool paused_) {\n        paused_ = _paused;\n    }\n\n    /**\n     * @inheritdoc IPoints\n     */\n    function setPaused(bool paused_) external onlyOwner {\n        _paused = paused_;\n        emit IsPaused(paused_);\n    }\n\n    /**\n     * @inheritdoc IPoints\n     */\n    function setAuthorizedBurner(address authorizedBurner_) external onlyOwner {\n        authorizedBurner = authorizedBurner_;\n        emit AuthorizedBurnerUpdated(authorizedBurner_);\n    }\n\n    /**\n     * @inheritdoc IPoints\n     */\n    function burn(address account, uint256 amount) external preConvertAllPendingPoints(account, amount) {\n        if (msg.sender != authorizedBurner) {\n            revert UnauthorizedBurner(msg.sender);\n        }\n        _burn(account, amount);\n    }\n\n    /**\n     * @inheritdoc IPoints\n     */\n    function setAddressWhitelist(address account, bool status) external onlyOwner {\n        isWhitelisted[account] = status;\n        emit WhitelistUpdated(account, status);\n    }\n\n    /**\n     * @dev Checks if token has been added. Does this by validating that the token has a timestamp.\n     */\n    function tokenSupported(address token) internal view returns (bool supported) {\n        supported = timestamps[token] != 0;\n    }\n\n    function tokenCount() public view returns (uint256 count) {\n        count = tokenAt.length;\n    }\n\n    /**\n     * @inheritdoc IPoints\n     */\n    function setRates(address[] calldata tokens, uint96[] calldata rates) external onlyOwner {\n        if (tokens.length != rates.length) {\n            revert TokenRatesLengthsMismatched(tokens.length, rates.length);\n        }\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n            address token = tokens[i];\n            uint96 newRate = rates[i];\n            // Increase the cumulativeRate by r_{i-1} * t_{i-1}\n            cumulativeRates[token] += uint128(block.timestamp - timestamps[token]) * _rates[token];\n            _rates[token] = newRate;\n            // If token not already supported, it needs to be added to the tokenAt array\n            if (!tokenSupported(token)) {\n                tokenAt.push(token);\n            }\n            timestamps[token] = uint32(block.timestamp);\n            emit RateUpdated(token, newRate, uint32(block.timestamp));\n        }\n    }\n\n    /**\n     * @inheritdoc IPoints\n     */\n    function getRateInfo(address token) external view returns (uint96 rate, uint32 timestamp, uint128 cumulativeRate) {\n        rate = _rates[token];\n        timestamp = timestamps[token];\n        cumulativeRate = cumulativeRates[token];\n    }\n\n    /**\n     * @inheritdoc IPoints\n     */\n    function getMultipliers(address token)\n        external\n        view\n        returns (uint128[] memory thresholds, uint128[] memory scalars)\n    {\n        thresholds = multiplierThresholds[token];\n        scalars = multiplierScalars[token];\n    }\n\n    /**\n     * @inheritdoc IPoints\n     */\n    function setMultipliers(address token, uint128[] calldata iterativeThresholds, uint128[] calldata iterativeScalars)\n        external\n        onlyOwner\n    {\n        if (iterativeThresholds.length != iterativeScalars.length) {\n            revert MultiplierLengthsMismatched(iterativeThresholds.length, iterativeScalars.length);\n        }\n\n        // Calculating the resulting absolute thresholds and scalars\n        uint128 runningThreshold;\n        uint128 runningScalar = RATE_DENOMINATOR;\n        multiplierThresholds[token] = new uint128[](iterativeThresholds.length);\n        multiplierScalars[token] = new uint128[](iterativeThresholds.length);\n        for (uint256 i = 0; i < iterativeThresholds.length; i++) {\n            runningThreshold += iterativeThresholds[i];\n            runningScalar += iterativeScalars[i];\n            multiplierThresholds[token][i] = runningThreshold;\n            multiplierScalars[token][i] = runningScalar;\n        }\n        emit MultipliersUpdated(token, multiplierThresholds[token], multiplierScalars[token]);\n    }\n\n    /**\n     * @inheritdoc IPoints\n     */\n    function pendingBalanceOf(address account) public view returns (uint256 pendingBalance) {\n        for (uint256 i = 0; i < tokenAt.length; i++) {\n            address token = tokenAt[i];\n            // Skip if the user has no stakes for the current token\n            if (tokenStakes[account][token].amount == 0) {\n                continue;\n            }\n            TokenStake memory tokenStake = tokenStakes[account][token];\n            uint128 cumulativeRate =\n                cumulativeRates[token] + uint128(block.timestamp - timestamps[token]) * _rates[token];\n            pendingBalance += calculateMintAmount(token, tokenStake.amount, cumulativeRate - tokenStake.cumulativeRate);\n        }\n    }\n\n    /**\n     * @inheritdoc IERC20\n     * @dev Overriding balanceOf to include pendingBalance\n     */\n    function balanceOf(address account) public view override(ERC20, IERC20) returns (uint256) {\n        return super.balanceOf(account) + pendingBalanceOf(account);\n    }\n\n    /**\n     * @dev Overriding _transfer to convert all pending points before transfers\n     */\n    function _transfer(address from, address to, uint256 amount)\n        internal\n        override\n        checkPaused(from)\n        preConvertAllPendingPoints(from, amount)\n    {\n        super._transfer(from, to, amount);\n    }\n\n    /**\n     * @inheritdoc IPoints\n     */\n    function getTokenStake(address account, address token) external view override returns (uint128 amount) {\n        amount = tokenStakes[account][token].amount;\n    }\n\n    function getTokenMultiplier(address account, address token) external view returns (uint256 rateScalar) {\n        uint128 amount = tokenStakes[account][token].amount;\n\n        rateScalar = RATE_DENOMINATOR;\n        uint256 thresholdIndex;\n        for (thresholdIndex = 0; thresholdIndex < multiplierThresholds[token].length; thresholdIndex++) {\n            if (amount < multiplierThresholds[token][thresholdIndex]) {\n                break;\n            }\n        }\n        if (thresholdIndex > 0) {\n            rateScalar = multiplierScalars[token][thresholdIndex - 1];\n        }\n    }\n}\n"
    },
    "src/external/IUniversalVault.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {IUniversalVaultEvents} from \"./IUniversalVaultEvents.sol\";\n\n/**\n * @notice IUniversalVault interface\n * @dev Source: https://github.com/ampleforth/token-geyser-v2/blob/c878fd6ba5856d818ff41c54bce59c9413bc93c9/contracts/UniversalVault.sol#L17-L87\n */\ninterface IUniversalVault is IUniversalVaultEvents {\n    /* data types */\n\n    struct LockData {\n        address delegate;\n        address token;\n        uint256 balance;\n    }\n\n    /* initialize function */\n\n    function initialize() external;\n\n    /* user functions */\n\n    function lock(address token, uint256 amount, bytes calldata permission) external;\n\n    function unlock(address token, uint256 amount, bytes calldata permission) external;\n\n    function rageQuit(address delegate, address token) external returns (bool notified, string memory error);\n\n    function transferERC20(address token, address to, uint256 amount) external;\n\n    function transferETH(address to, uint256 amount) external payable;\n\n    /* pure functions */\n\n    function calculateLockID(address delegate, address token) external pure returns (bytes32 lockID);\n\n    /* getter functions */\n\n    function getPermissionHash(bytes32 eip712TypeHash, address delegate, address token, uint256 amount, uint256 nonce)\n        external\n        view\n        returns (bytes32 permissionHash);\n\n    function getNonce() external view returns (uint256 nonce);\n\n    function owner() external view returns (address ownerAddress);\n\n    function getLockSetCount() external view returns (uint256 count);\n\n    function getLockAt(uint256 index) external view returns (LockData memory lockData);\n\n    function getBalanceDelegated(address token, address delegate) external view returns (uint256 balance);\n\n    function getBalanceLocked(address token) external view returns (uint256 balance);\n\n    function checkBalances() external view returns (bool validity);\n}\n"
    },
    "src/external/IRageQuit.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\n/**\n * @notice IRageQuit interface\n * @dev Source: https://github.com/ampleforth/token-geyser-v2/blob/c878fd6ba5856d818ff41c54bce59c9413bc93c9/contracts/Geyser.sol#L17-L19\n */\ninterface IRageQuit {\n    /**\n     * @notice Exit without claiming reward\n     * @dev Should only be callable by the vault directly\n     */\n    function rageQuit() external;\n}\n"
    },
    "src/external/IInstanceRegistry.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.0;\n\n/**\n * @notice IInstanceRegistry interface\n * @dev Source: https://github.com/ampleforth/token-geyser-v2/blob/c878fd6ba5856d818ff41c54bce59c9413bc93c9/contracts/Factory/InstanceRegistry.sol#L6-L19\n */\ninterface IInstanceRegistry {\n    /* events */\n\n    event InstanceAdded(address instance);\n    event InstanceRemoved(address instance);\n\n    /* view functions */\n\n    function isInstance(address instance) external view returns (bool validity);\n\n    function instanceCount() external view returns (uint256 count);\n\n    function instanceAt(uint256 index) external view returns (address instance);\n}\n"
    },
    "src/interfaces/IPointsVaultExtension.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.21;\n\nimport {IPoints} from \"./IPoints.sol\";\nimport {IRageQuit} from \"../external/IRageQuit.sol\";\nimport {IPointsVaultExtensionEvents} from \"./IPointsVaultExtensionEvents.sol\";\nimport {IPointsVaultExtensionErrors} from \"./IPointsVaultExtensionErrors.sol\";\n\n/**\n * @title IPointsVaultExtension\n * @notice Interface for the vault-extension of the Points contract.\n * @dev Does not support fee-on-transfer or rebasing tokens (in unwrapped form).\n */\ninterface IPointsVaultExtension is IPoints, IRageQuit, IPointsVaultExtensionEvents, IPointsVaultExtensionErrors {\n    /**\n     * @notice Get the length of the registered vaultFactory whitelist\n     * @return length The length of the vaultFactory whitelist\n     */\n    function getVaultFactorySetLength() external view returns (uint256 length);\n\n    /**\n     * @notice Get the address of the vaultFactory at the corresponding index on the whitelist\n     * @param index The index of the vaultFactory\n     * @return factory The address of the vaultFactory at the index on the whitelist\n     */\n    function getVaultFactoryAtIndex(uint256 index) external view returns (address factory);\n\n    /**\n     * @notice Validate whether or not the target vault is from a whitelisted factory\n     * @param vault The address of the vault in question\n     * @return validity Whether the target vault is from a whitelisted factory or not\n     */\n    function isValidVault(address vault) external view returns (bool validity);\n\n    /**\n     * @notice Register a new vaultFactory onto the whitelist. Only callable by owner.\n     * @param factory The address of the factory to add.\n     */\n    function registerVaultFactory(address factory) external;\n\n    /**\n     * @notice Remove a vaultFactory from the whitelist. Only callable by owner.\n     * @param factory The address of the factory to remove.\n     */\n    function removeVaultFactory(address factory) external;\n\n    /**\n     * @notice Stake tokens from vault into Points contract.\n     * @notice Vault must be from whitelisted vaultFactory.\n     * @param vault Address of the vault to stake from.\n     * @param token The address of the token.\n     * @param amount The amount of tokens to deposit.\n     * @param permission Permission signature from vault owner.\n     */\n    function stakeToken(address vault, address token, uint128 amount, bytes calldata permission) external;\n\n    /**\n     * @notice Unstake tokens from Points contract and transfer earned points to the vault.\n     * @param vault Address of the vault to unstake from.\n     * @param token The address of the token.\n     * @param amount The amount of tokens to deposit.\n     * @param permission Permission signature from vault owner.\n     */\n    function unstakeToken(address vault, address token, uint128 amount, bytes calldata permission) external;\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "src/interfaces/IPoints.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.21;\n\nimport {IERC20} from \"points_@openzeppelin-contracts/token/ERC20/IERC20.sol\";\nimport {IPointsEvents} from \"./IPointsEvents.sol\";\nimport {IPointsErrors} from \"./IPointsErrors.sol\";\n\n/**\n * @title IPoints\n * @notice Interface for the Points contract.\n * @dev Does not support fee-on-transfer or rebasing tokens (in unwrapped form).\n */\ninterface IPoints is IERC20, IPointsEvents, IPointsErrors {\n    /**\n     * @notice Returns true if transfers are paused.\n     * @return paused_ True if transfers are paused. False otherwise.\n     */\n    function paused() external view returns (bool paused_);\n\n    /**\n     * @notice Sets the paused status of the transfers.\n     * @param paused_ The new paused status.\n     */\n    function setPaused(bool paused_) external;\n\n    /**\n     * @notice Returns the address of the authorized burner.\n     * @return authorizedBurner The address of the authorized burner.\n     */\n    function authorizedBurner() external view returns (address authorizedBurner);\n\n    /**\n     * @notice Sets the address of the authorized burner.\n     * @param authorizedBurner_ The new address of the authorized burner.\n     */\n    function setAuthorizedBurner(address authorizedBurner_) external;\n\n    /**\n     * @notice Burns the specified amount of tokens from the caller. Only callable by the authorized burner.\n     * @param account The address to burn tokens from.\n     * @param amount The amount of tokens to burn.\n     */\n    function burn(address account, uint256 amount) external;\n\n    /**\n     * @notice Returns true if the account is whitelisted (able to transfer tokens without restrictions).\n     * @param account The address to check.\n     * @return whitelisted True if the account is whitelisted. False otherwise.\n     */\n    function isWhitelisted(address account) external view returns (bool whitelisted);\n\n    /**\n     * @notice Updates the whitelist status of the account.\n     * @param account The address to update.\n     * @param status The new whitelist status.\n     */\n    function setAddressWhitelist(address account, bool status) external;\n\n    /**\n     * @notice Returns the token at the given index in the token list\n     * @dev Tokens that have rates set to 0 are still included in the list.\n     * @param index The index of the token in the list.\n     * @return token The token\n     */\n    function tokenAt(uint256 index) external view returns (address token);\n\n    /**\n     * @notice Returns the number of tokens in the token list.\n     * @dev Tokens that have rates set to 0 are still included in the list.\n     * @return count The number of tokens in the list.\n     */\n    function tokenCount() external view returns (uint256 count);\n\n    /**\n     * @notice Sets the rates of the tokens. New tokens will be added if they do not already exist.\n     * @dev Token addresses and rates are matched by corresponding index in their respective arrays\n     * @dev Passing in the same token address multiple times results in only the final value being used.\n     * @param tokens The addresses of the tokens.\n     * @param rates The rates of the tokens.\n     */\n    function setRates(address[] calldata tokens, uint96[] calldata rates) external;\n\n    /**\n     * @notice Returns the rate of the token and the timestamp of the last update.\n     * @param token The address of the token.\n     * @return rate The rate of the token.\n     * @return timestamp The timestamp of the last rate update or transfer of the token.\n     * @return cumulativeRate The cumulative rate snapshot at the timestamp.\n     */\n    function getRateInfo(address token) external view returns (uint96 rate, uint32 timestamp, uint128 cumulativeRate);\n\n    /**\n     * @notice Returns the multiplier thresholds and scalars for the token.\n     * @param token The address of the token.\n     * @return thresholds The absolute thresholds for the multipliers.\n     * @return scalars The absolute scalars for the multipliers.\n     */\n    function getMultipliers(address token)\n        external\n        view\n        returns (uint128[] memory thresholds, uint128[] memory scalars);\n\n    /**\n     * @notice Sets the multiplier thresholds and scalars for the token.\n     * @dev To generate the stored absolute thresholds, each iterative threshold is added to the previous one, starting from 0\n     * @dev To generate the stored absolute scalars, each iterative scalar is added by the previous one, starting from RATE_DENOMINATOR\n     * @param token The address of the token.\n     * @param iterativeThresholds The iterative thresholds for the multipliers. Base threshold is 0\n     * @param iterativeScalars The iterative scalars for the multipliers. Base multiplier is RATE_DENOMINATOR.\n     */\n    function setMultipliers(address token, uint128[] calldata iterativeThresholds, uint128[] calldata iterativeScalars)\n        external;\n\n    /**\n     * @notice Returns the pending balance of the account (points that have yet to be converted)\n     * @param account The address of the account.\n     * @return pendingBalance The pending balance of the account.\n     */\n    function pendingBalanceOf(address account) external view returns (uint256 pendingBalance);\n\n    /**\n     * @notice Returns the staked amount for a given account and token\n     * @param account The address of the account.\n     * @param token The address of the token.\n     * @return amount The staked amount for the account and token.\n     */\n    function getTokenStake(address account, address token) external view returns (uint128 amount);\n\n    /**\n     * @notice Returns the current multiplier scalar for a given account and token\n     * @param account The address of the account.\n     * @param token The address of the token.\n     * @return rateScalar The current multiplier scalar for the account and token.\n     */\n    function getTokenMultiplier(address account, address token) external view returns (uint256 rateScalar);\n}\n"
    },
    "src/external/IUniversalVaultEvents.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\n/**\n * @notice IUniversalVaultEvents interface\n * @dev Source: https://github.com/ampleforth/token-geyser-v2/blob/c878fd6ba5856d818ff41c54bce59c9413bc93c9/contracts/UniversalVault.sol#L20-L22\n */\ninterface IUniversalVaultEvents {\n    /* user events */\n    event Locked(address delegate, address token, uint256 amount);\n    event Unlocked(address delegate, address token, uint256 amount);\n    event RageQuit(address delegate, address token, bool notified, string reason);\n}\n"
    },
    "src/interfaces/IPointsVaultExtensionEvents.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.21;\n\n/**\n * @title IPointsVaultExtensionEvents\n * @notice Interface for the Events emitted by the PointsVaultExtension contract.\n */\ninterface IPointsVaultExtensionEvents {\n    /**\n     * @notice Emitted when tokens are locked in a vault\n     * @param vault The address of the vault that tokens were locked in\n     * @param token The address of the token that was locked in the vault\n     * @param amount The amount of tokens that were locked in the vault\n     */\n    event TokenVaultLocked(address indexed vault, address indexed token, uint256 amount);\n    /**\n     * @notice Emitted when tokens are unlocked from a vault\n     * @param vault The address of the vault that tokens were unlocked from\n     * @param token The address of the token that was unlocked from the vault\n     * @param amount The amount of tokens that were unlocked from the vault\n     */\n    event TokenVaultUnlocked(address indexed vault, address indexed token, uint256 amount);\n    /**\n     * @notice Emitted when a vaultFactory is registered on the whitelist\n     * @param vaultFactory The address of the vaultFactory was registered\n     */\n    event VaultFactoryRegistered(address indexed vaultFactory);\n    /**\n     * @notice Emitted when a vaultFactory is removed from the whitelist\n     * @param vaultFactory The address of the vaultFactory that was removed\n     */\n    event VaultFactoryRemoved(address indexed vaultFactory);\n}\n"
    },
    "src/interfaces/IPointsVaultExtensionErrors.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.21;\n\n/**\n * @title IPointsVaultExtensionErrors\n * @notice Interface for the Errors emitted by the PointsVaultExtension contract.\n */\ninterface IPointsVaultExtensionErrors {\n    /**\n     * @notice Thrown when attempting to register a vaultFactory that has already been registered\n     * @param vaultFactory The address of the vaultFactory that was already registered\n     */\n    error VaultFactoryAlreadyRegistered(address vaultFactory);\n    /**\n     * @notice Thrown when attempting to remove a vaultFactory that has not been registered\n     * @param vaultFactory The address of the vaultFactory that was not already registered\n     */\n    error VaultFactoryNotRegistered(address vaultFactory);\n    /**\n     * @notice Thrown when attempting to stake with a vault that is not from a registered vaultFactory;\n     * @param vault The address of the vault that was not from a registered vaultFactory\n     */\n    error InvalidVault(address vault);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "src/interfaces/IPointsEvents.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.21;\n\n/**\n * @title IPointsEvents\n * @notice Interface for the Events emitted by the Points contract.\n */\ninterface IPointsEvents {\n    /**\n     * @notice Emitted when the paused status of the transfers is updated.\n     * @param paused The new paused status\n     */\n    event IsPaused(bool paused);\n    /**\n     * @notice Emitted when the authorized burner is updated.\n     * @param authorizedBurner The new authorized burner\n     */\n    event AuthorizedBurnerUpdated(address authorizedBurner);\n    /**\n     * @notice Emitted when the whitelist status of an account is updated.\n     * @param account The account whose whitelist status was updated\n     * @param whitelisted The new whitelist status\n     */\n    event WhitelistUpdated(address indexed account, bool whitelisted);\n    /**\n     * @notice Emitted when the rate of a token is updated.\n     * @param token The token whose rate is updated\n     * @param rate The new rate\n     * @param timestamp The timestamp of the update\n     */\n    event RateUpdated(address indexed token, uint96 rate, uint32 timestamp);\n    /**\n     * @notice Emitted when points are converted to pending points.\n     * @param account The account whose points were converted\n     * @param token The staked token that earned the points\n     * @param amount The amount of points converted\n     */\n    event PendingPointsConverted(address indexed account, address indexed token, uint256 amount);\n    /**\n     * @notice Emitted when multipliers are updated\n     * @param token The token whose multipliers were updated\n     * @param thresholds The new thresholds\n     * @param scalars The new scalars\n     */\n    event MultipliersUpdated(address indexed token, uint128[] thresholds, uint128[] scalars);\n}\n"
    },
    "src/interfaces/IPointsErrors.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.21;\n\n/**\n * @title IPointsErrors\n * @notice Interface for the errors thrown by the Points contract.\n */\ninterface IPointsErrors {\n    /**\n     * @notice Thrown when attempting to set rates while rates parameter and tokens parameter have different lengths.\n     * @param tokensLength The length of the tokens array\n     * @param ratesLength The length of the rates array\n     */\n    error TokenRatesLengthsMismatched(uint256 tokensLength, uint256 ratesLength);\n    /**\n     * @notice Thrown when attempting to transfer when paused and not whitelisted.\n     */\n    error TransfersPaused();\n\n    /**\n     * @notice Thrown when attempting to burn tokens without being the authorized burner.\n     * @param account The account attempting to burn tokens\n     */\n    error UnauthorizedBurner(address account);\n\n    /**\n     * @notice Thrown when attempting to stake an unsupported token.\n     * @param token The token that was not supported\n     */\n    error TokenNotSupported(address token);\n    /**\n     * @notice Thrown when attempting to unstake more of the token than has been staked.\n     * @param tokenBalance The amount of tokens the user had deposited into the contract\n     * @param amount The amount of tokens the user was attempting to withdraw\n     */\n    error InsufficientTokenBalance(uint256 tokenBalance, uint256 amount);\n    /**\n     * @notice Thrown when attempting to set multipliers with threshold and additionalRate arrays of different lengths.\n     * @param thresholdsLength The length of the thresholds array\n     * @param additionalRatesLength The length of the additionalRates array\n     */\n    error MultiplierLengthsMismatched(uint256 thresholdsLength, uint256 additionalRatesLength);\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "forge-std/=null/",
      "openzeppelin-contracts/=null/",
      "@openzeppelin-contracts/=null/",
      "openzeppelin/=null/",
      "mock-contracts/=null/",
      "points_@openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/",
      "points_forge-std/=lib/forge-std/src/",
      "points_mock-contracts/=lib/mock-contracts/src/",
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/",
      "mock-contracts_@openzeppelin-contracts/=lib/mock-contracts/lib/openzeppelin-contracts/contracts/",
      "mock-contracts_forge-std/=lib/mock-contracts/lib/forge-std/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "evmVersion": "paris",
    "libraries": {}
  }
}}