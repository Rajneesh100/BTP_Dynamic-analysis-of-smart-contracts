{{
  "language": "Solidity",
  "sources": {
    "src/Stash.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport {IAuction} from \"./interfaces/IAuction.sol\";\nimport {IWETH} from \"./interfaces/IWETH.sol\";\nimport {OrderType} from \"./helpers/Enum.sol\";\nimport {Order, PunkBid} from \"./helpers/Struct.sol\";\nimport {MerkleProofLib} from \"lib/solady/src/utils/MerkleProofLib.sol\";\nimport {SignatureCheckerLib} from \"lib/solady/src/utils/SignatureCheckerLib.sol\";\nimport {SafeTransferLib} from \"lib/solady/src/utils/SafeTransferLib.sol\";\nimport {IERC721} from \"forge-std/interfaces/IERC721.sol\";\nimport {IERC1155} from \"forge-std/interfaces/IERC1155.sol\";\nimport {IERC20} from \"forge-std/interfaces/IERC20.sol\";\nimport {ILegacyWrappedPunks} from \"./interfaces/ILegacyWrappedPunks.sol\";\nimport {ICryptoPunks721} from \"./interfaces/ICryptoPunks721.sol\";\nimport {ICryptoPunks} from \"./interfaces/ICryptoPunks.sol\";\nimport {IStashFactory} from \"./interfaces/IStashFactory.sol\";\nimport {IPunkTransferHelper} from \"./interfaces/IPunkTransferHelper.sol\";\n\n/**\n * @title Stash\n * @author Yuga Labs\n * @custom:security-contact security@yugalabs.io\n * @notice A multipurpose user deployed contract.\n */\ncontract Stash {\n    // --------------------- STASH EVENTS ---------------------\n\n    /// @dev Emitted when an order is placed.\n    event OrderPlaced(Order order);\n\n    /// @dev Emitted when an order is updated.\n    event OrderUpdated(Order originalOrder, Order updatedOrder);\n\n    /// @dev Emitted when an order is removed, either because it was filled or the auction was finalized.\n    event OrderRemoved(Order order);\n\n    /// @dev Emitted when a punk bid is canceled.\n    event PunkBidCanceled(uint256 indexed bidNonce);\n\n    /// @dev Emitted when the Stash's global nonce is incremented, cancelling all Punk bids.\n    event AllPunkBidsCanceled();\n\n    /// @dev Emitted when a punk bid is accepted.\n    event PunkBidAccepted(uint256 indexed price, uint256 indexed punkIndex);\n\n    // --------------------- CUSTOM ERRORS ---------------------\n\n    /// @dev The punk bid has expired.\n    error BidExpired();\n\n    /// @dev The bid either has zero units or does not include the CryptoPunks address.\n    error InvalidBid();\n\n    /// @dev The bid has been used or canceled.\n    error BidCanceled();\n\n    /// @dev The caller is not authorized to perform this action.\n    error Unauthorized();\n\n    /// @dev The order does not exist. It may have been filled, canceled, or never existed.\n    error OrderNotFound();\n\n    /// @dev The merkle proof provided does not match the CryptoPunk Bid.\n    error InvalidProof();\n\n    /// @dev The vault already has 10 orders for the given payment token.\n    error TooManyOrders();\n\n    /// @dev The Punk is either not listed for sale, or there was an error paying the caller.\n    error FailedToBuyPunk();\n\n    /// @dev This Stash does not have an active bid on the auction that is attempting to process the order.\n    error NoBidForAuction();\n\n    /// @dev The provided signature does not match the provided CryptoPunk bid.\n    error InvalidSignature();\n\n    /// @dev The caller is not a valid auction contract, as determined by the StashFactory.\n    error CallerNotAuction();\n\n    /// @dev Payment to the Stash owner failed.\n    error FailedToWithdraw();\n\n    /// @dev The Stash has already been initialized.\n    error AlreadyInitialized();\n\n    /// @dev The order is being altered in a way that is not allowed by the order type.\n    error InvalidOrderAlteration();\n\n    /// @dev An order or withdrawal is being requested for an amount that exceeds the available balance.\n    error RequestExceedsAvailableBalance();\n\n    /// @dev An auction is attempting to pull more funds than the Stash owner has approved from the Stash.\n    error CannotTransferMoreThanBidAmount();\n\n    // --------------------- MODIFIERS ---------------------\n\n    modifier onlyOwner() {\n        if (msg.sender != owner) revert CallerNotAuction();\n        _;\n    }\n\n    // ----------------- CONSTANTS & IMMUTABLES -----------------\n\n    uint256 private constant _VERSION = 1;\n    bytes32 private constant _COLLECTION_BID_ROOT = bytes32(0);\n    bytes32 private constant _ORDER_TYPEHASH =\n        keccak256(\"Order(uint16 numberOfUnits,uint80 pricePerUnit,address auction)\");\n    bytes32 private constant _PUNK_BID_TYPEHASH = keccak256(\n        \"PunkBid(Order order,uint256 accountNonce,uint256 bidNonce,uint256 expiration,bytes32 root)Order(uint16 numberOfUnits,uint80 pricePerUnit,address auction)\"\n    );\n\n    ICryptoPunks private immutable _CRYPTOPUNKS;\n    ILegacyWrappedPunks private immutable _LEGACY_WRAPPED_PUNKS;\n    ICryptoPunks721 private immutable _CRYPTOPUNKS_721;\n    IWETH private immutable _WETH;\n    IStashFactory private immutable _STASH_FACTORY;\n    IPunkTransferHelper private immutable _PUNK_TRANSFER_HELPER;\n\n    // -------------------- CONSTRUCTOR --------------------\n\n    constructor(\n        address stashFactory,\n        address weth,\n        address punks,\n        address legacyWrappedPunks,\n        address cryptoPunksWrapped,\n        address punkTransferHelper\n    ) {\n        _STASH_FACTORY = IStashFactory(stashFactory);\n        _WETH = IWETH(weth);\n        _CRYPTOPUNKS = ICryptoPunks(punks);\n        _LEGACY_WRAPPED_PUNKS = ILegacyWrappedPunks(legacyWrappedPunks);\n        _CRYPTOPUNKS_721 = ICryptoPunks721(cryptoPunksWrapped);\n        _PUNK_TRANSFER_HELPER = IPunkTransferHelper(punkTransferHelper);\n        _initialized = true;\n    }\n\n    // --------------------- STORAGE ---------------------\n\n    /// @dev Whether or not the contract has been initialized.\n    bool private _initialized;\n\n    /// @notice The permanent and immutable owner of the stash. Set once at initialization.\n    address public owner;\n\n    /// @notice The current nonce of the stash owner's account. Used for punk bidding, can be incremented to cancel all open bids.\n    uint56 public punkAccountNonce;\n\n    /// @notice A mapping of punk bid nonces to the number of times they can be used.\n    mapping(uint256 punkBidNonce => uint256 usesRemaining) public punkBidNonceUsesRemaining;\n\n    /// @notice A mapping of punk bid nonces to whether or not they have been used.\n    mapping(uint256 punkBidNonce => bool isUsed) public usedPunkBidNonces;\n\n    /// @notice Returns an array of all current orders for a given payment token.\n    mapping(address paymentToken => Order[] orders) public paymentTokenToOrders;\n\n    // --------------------- EXTERNAL ---------------------\n\n    // allow receiving ETH.\n    receive() external payable {}\n\n    /**\n     * @notice Initializes the contract. This is called only once upon deployment by the StashFactory.\n     * @param _owner The permanent and immutable owner of the stash.\n     */\n    function initialize(address _owner) external {\n        if (_initialized) revert AlreadyInitialized();\n\n        owner = _owner;\n        _initialized = true;\n    }\n\n    /**\n     * @notice Places an order for an auction. If one exists, it will be replaced or incremented depending on the order type.\n     * @param pricePerUnit The price per unit of the order.\n     * @param numberOfUnits The number of units included in the order.\n     * @dev The stash owner must initiate this transaction by calling the corresponding bid function on a valid auction contract.\n     */\n    function placeOrder(uint80 pricePerUnit, uint16 numberOfUnits) external payable {\n        // Prevent unwanted bids by enforcing that the user initiated the transaction and that the caller is a registered auction.\n        if (tx.origin != owner) revert Unauthorized();\n        if (!_STASH_FACTORY.isAuction(msg.sender)) revert CallerNotAuction();\n\n        (address paymentToken, OrderType orderType) = IAuction(msg.sender).bidConfig();\n\n        uint256 paymentTokenBalance = _balanceOfToken(paymentToken);\n        (uint256 lockedAmount, uint256 finalizedIndexes) = _totalLockedAndStaleBids(paymentToken);\n\n        uint256 _availableLiquidity;\n        unchecked {\n            // Locked amount cannot exceed paymentTokenBalance.\n            _availableLiquidity = paymentTokenBalance - lockedAmount;\n        }\n\n        _cleanStaleBids(paymentToken, finalizedIndexes);\n\n        Order memory newOrder = Order(numberOfUnits, pricePerUnit, msg.sender);\n\n        Order[] storage _orders = paymentTokenToOrders[paymentToken];\n\n        for (uint256 i = 0; i < _orders.length; ++i) {\n            Order storage _order = _orders[i];\n            if (_order.auction == msg.sender) {\n                // cache the existing order to emit an event later.\n                Order memory existingOrder = _order;\n\n                // This will check that the stash has funds to cover the order, and modify the existing order in place.\n                _replaceOrIncrementExistingOrders(_order, numberOfUnits, pricePerUnit, _availableLiquidity, orderType);\n\n                emit OrderUpdated(existingOrder, _order);\n\n                return;\n            }\n        }\n\n        if (_bidDeltaExceedsLiquidity(0, uint256(numberOfUnits) * pricePerUnit, _availableLiquidity)) {\n            revert RequestExceedsAvailableBalance();\n        }\n\n        _orders.push(newOrder);\n\n        /**\n         * Limit the number of orders to 10 to prevent gas issues. Realistically, there will only ever be one order\n         * per payment token at a time. This is just a safety measure.\n         */\n        if (_orders.length > 10) revert TooManyOrders();\n\n        emit OrderPlaced(newOrder);\n    }\n\n    /**\n     * @notice Processes an order for a given auction, transferring payment to the auction contract.\n     * @param costPerUnit The cost per unit of the order.\n     * @param numberOfUnits The number of units to process.\n     * @dev This function is called by the auction contract, which should handle minting corresponding units\n     * as part of the transaction. The order's numberOfUnits will be lowered by numberOfUnits, and the order will be\n     * removed if numberOfUnits is equal to the order's numberOfUnits.\n     */\n    function processOrder(uint80 costPerUnit, uint16 numberOfUnits) external {\n        if (!_STASH_FACTORY.isAuction(msg.sender)) revert CallerNotAuction();\n        (address paymentToken,) = IAuction(msg.sender).bidConfig();\n\n        Order[] storage _orders = paymentTokenToOrders[paymentToken];\n        for (uint256 i = 0; i < _orders.length;) {\n            Order storage _order = _orders[i];\n            if (_order.auction == msg.sender) {\n                if (costPerUnit > _order.pricePerUnit || numberOfUnits > _order.numberOfUnits) {\n                    revert CannotTransferMoreThanBidAmount();\n                }\n\n                if (numberOfUnits == _order.numberOfUnits) {\n                    _removeBid(paymentToken, i);\n                } else {\n                    // cache the existing order to emit an event later.\n                    Order memory _originalOrder = _order;\n\n                    unchecked {\n                        _order.numberOfUnits -= numberOfUnits;\n                    }\n\n                    emit OrderUpdated(_originalOrder, _order);\n                }\n\n                _transferTokens(paymentToken, uint256(numberOfUnits) * costPerUnit);\n                return;\n            } else {\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n\n        revert NoBidForAuction();\n    }\n\n    /**\n     * @notice Allows selling a punk to the stash. A valid signature from the stash owner is required for successful execution.\n     * @param bid The bid that was signed off-chain.\n     * @param punkIndex The id of the punk to sell. Must be included in the bid's merkle tree.\n     * @param signature The signed bid.\n     * @param proof The merkle proof for the punkIndex.\n     * @dev This function will revert if the bid is invalid, expired, or canceled. It will also revert if the bid.\n     * does not contain the punkIndex in its merkle tree. If the bid is valid, the punk will be transferred to the stash.\n     * owner and the bid's numberOfUnits will be decremented. If numberOfUnits is 1, the bid will be marked as used.\n     */\n    function processPunkBid(PunkBid calldata bid, uint256 punkIndex, bytes memory signature, bytes32[] calldata proof)\n        external\n    {\n        uint256 availableETH = availableLiquidity(address(0));\n\n        Order calldata order = bid.order;\n        uint256 bidPrice = order.pricePerUnit;\n\n        if (order.numberOfUnits == 0) revert InvalidBid();\n        if (order.auction != address(_CRYPTOPUNKS)) revert InvalidBid();\n        if (punkAccountNonce != bid.accountNonce) revert BidCanceled();\n        if (usedPunkBidNonces[bid.bidNonce]) revert BidCanceled();\n        if (bid.expiration > 0 && block.timestamp > bid.expiration) revert BidExpired();\n        if (!_isValidSignature(bid, signature)) revert InvalidSignature();\n\n        if (bid.root != _COLLECTION_BID_ROOT) {\n            if (!MerkleProofLib.verifyCalldata(proof, bid.root, keccak256(abi.encode(punkIndex)))) {\n                revert InvalidProof();\n            }\n        }\n\n        // if balance is too low, we try to use owner's approved weth to supplement.\n        if (bidPrice > availableETH) {\n            _swapWETH(bidPrice - availableETH);\n        }\n\n        uint256 remainingUnits = punkBidNonceUsesRemaining[bid.bidNonce];\n\n        // we have already checked if the nonce is marked as used, so if remainingUnits is 0, this is the first use.\n        if (remainingUnits == 0) {\n            if (order.numberOfUnits == 1) {\n                usedPunkBidNonces[bid.bidNonce] = true;\n            } else {\n                unchecked {\n                    punkBidNonceUsesRemaining[bid.bidNonce] = order.numberOfUnits - 1;\n                }\n            }\n            // If remainingUnits is greater than 1, decrement it.\n        } else if (remainingUnits > 1) {\n            unchecked {\n                --punkBidNonceUsesRemaining[bid.bidNonce];\n            }\n            // remainingUnits is 1 - this is the last use, so mark the nonce as used.\n        } else {\n            delete punkBidNonceUsesRemaining[bid.bidNonce];\n            usedPunkBidNonces[bid.bidNonce] = true;\n        }\n\n        (bool isPunkForSaleInLegacyMarketplace,,, uint256 minValue,) = _CRYPTOPUNKS.punksOfferedForSale(punkIndex);\n        uint256 amountDueToCaller;\n\n        // if the punk is listed for sale, we can infer that it is unwrapped.\n        if (isPunkForSaleInLegacyMarketplace) {\n            if (minValue > bidPrice) {\n                revert CannotTransferMoreThanBidAmount();\n            } else if (minValue < bidPrice) {\n                /**\n                 * If the punk is listed under the bid, incentivize MEV fulfillment by paying the difference to the caller.\n                 * We cache the value to be used after finalization to avoid reentrancy issues.\n                 */\n                unchecked {\n                    amountDueToCaller = bidPrice - minValue;\n                }\n            }\n\n            _CRYPTOPUNKS.buyPunk{value: minValue}(punkIndex);\n            // If it is not listed, we can still fulfill the bid if the punk is wrapped in the legacy or 721 wrapper.\n        } else {\n            /**\n             * If the punk is wrapped in the legacy wrapper or CryptoPunks721, we need to unwrap it. Owners of Legacy Wrapped\n             * Punks or CryptoPunks721 have to approve their punks to the PunkTransferHelper. To prevent the Stash owner from\n             * maliciously replacing the bid with a lower price after the wrapped punk has already been approved, while unwrapped\n             * punk bids can be fulfilled by anybody, processing bids using punks that are wrapped will verify that msg.sender is\n             * the owner of the punk.\n             */\n\n            address _unwrappedCryptoPunkOwner = _CRYPTOPUNKS.punkIndexToAddress(punkIndex);\n\n            bytes32 _punkIndexAndOwnerAddressPacked;\n\n            assembly {\n                // Shift _punkIndex left by 160 bits to make room for the _assetContract\n                let shiftedPunkIndex := shl(160, punkIndex)\n                // Combine shifted _punkIndex with _assetContract\n                _punkIndexAndOwnerAddressPacked := or(shiftedPunkIndex, caller())\n            }\n\n            if (_unwrappedCryptoPunkOwner == address(_LEGACY_WRAPPED_PUNKS)) {\n                // Transfer punk to stash for unwrapping. This implicitly checks that caller is owner of wrapped punk to prevent malicious bid replacement:\n                _PUNK_TRANSFER_HELPER.transferLegacyWrappedPunkToStash(_punkIndexAndOwnerAddressPacked);\n                // Unwrap punk:\n                _LEGACY_WRAPPED_PUNKS.burn(punkIndex);\n            } else if (_unwrappedCryptoPunkOwner == address(_CRYPTOPUNKS_721)) {\n                // Transfer punk to stash for unwrapping. This implicitly checks that caller is owner of wrapped punk to prevent malicious bid replacement:\n                _PUNK_TRANSFER_HELPER.transferWrappedPunkToStash(_punkIndexAndOwnerAddressPacked);\n                // Unwrap punk:\n                _CRYPTOPUNKS_721.unwrapPunk(punkIndex);\n            } else {\n                revert FailedToBuyPunk();\n            }\n\n            // set bidPrice as amount to pay caller. Caller will always be the stash owner in this case:\n            amountDueToCaller = bidPrice;\n        }\n\n        _CRYPTOPUNKS.transferPunk(owner, punkIndex);\n        if (amountDueToCaller > 0) {\n            (bool callerPaid,) = payable(msg.sender).call{value: amountDueToCaller}(\"\");\n            if (!callerPaid) revert FailedToBuyPunk();\n        }\n\n        emit PunkBidAccepted(bidPrice, punkIndex);\n    }\n\n    /**\n     * @notice Cancels a bid.\n     * @param bidNonce The nonce of the bid to cancel.\n     */\n    function cancelPunkBid(uint256 bidNonce) external onlyOwner {\n        usedPunkBidNonces[bidNonce] = true;\n\n        emit PunkBidCanceled(bidNonce);\n    }\n\n    /**\n     * @notice increments the global account nonce, canceling all existing offchain bids.\n     * @dev a very motivated stash owner could overflow their nonce, but there would be no benefit to doing so.\n     */\n    function cancelAllPunkBids() external onlyOwner {\n        unchecked {\n            ++punkAccountNonce;\n        }\n\n        emit AllPunkBidsCanceled();\n    }\n\n    // --------------------- WITHDRAWALS ---------------------\n\n    /**\n     * @notice Used by the CryptoPunks721 contract to wrap punks. Punks must be deposited to the Stash for wrapping.\n     * @param punkIndex The index of the punk to wrap.\n     */\n    function wrapPunk(uint256 punkIndex) external {\n        if (msg.sender != address(_CRYPTOPUNKS_721)) revert Unauthorized();\n\n        _CRYPTOPUNKS.transferPunk(address(_CRYPTOPUNKS_721), punkIndex);\n    }\n\n    /**\n     * @notice withdraws funds from the stash.\n     * @param tokenAddress The address of the token to withdraw. Zero address for ETH.\n     * @param amount The amount to withdraw in wei.\n     * @dev This function allows withdrawal of funds that are not committed to an active bid. It will also\n     * clean up any stale bids that have been finalized or expired.\n     */\n    function withdraw(address tokenAddress, uint256 amount) external onlyOwner {\n        (uint256 _lockedAmount, uint256 finalizedIndexes) = _totalLockedAndStaleBids(tokenAddress);\n\n        uint256 tokenBalance = _balanceOfToken(tokenAddress);\n\n        uint256 availableToWithdraw = tokenBalance - _lockedAmount;\n        if (amount > availableToWithdraw) revert RequestExceedsAvailableBalance();\n\n        _cleanStaleBids(tokenAddress, finalizedIndexes);\n\n        _transferTokens(tokenAddress, amount);\n    }\n\n    /**\n     * @notice Convenience function to withdraw ERC721 tokens from the stash.\n     * @param tokenAddress The address of the token to withdraw.\n     * @param tokenIds An array of token IDs to withdraw.\n     */\n    function withdrawERC721(address tokenAddress, uint256[] calldata tokenIds) external onlyOwner {\n        IERC721 tokenContract = IERC721(tokenAddress);\n\n        for (uint256 i = 0; i < tokenIds.length; ++i) {\n            tokenContract.transferFrom(address(this), owner, tokenIds[i]);\n        }\n    }\n\n    /**\n     * @notice Convenience function to withdraw ERC1155 tokens from the stash.\n     * @param tokenAddress The address of the token to withdraw.\n     * @param tokenIds An array of token IDs to withdraw.\n     * @param amounts An array of amounts to withdraw.\n     */\n    function withdrawERC1155(address tokenAddress, uint256[] calldata tokenIds, uint256[] calldata amounts)\n        external\n        onlyOwner\n    {\n        IERC1155 tokenContract = IERC1155(tokenAddress);\n\n        for (uint256 i = 0; i < tokenIds.length; ++i) {\n            tokenContract.safeTransferFrom(address(this), owner, tokenIds[i], amounts[i], \"\");\n        }\n    }\n\n    /**\n     * @notice Convenience function to withdraw CryptoPunks from the stash.\n     * @param tokenIds An array of punk IDs to withdraw.\n     */\n    function withdrawPunks(uint256[] calldata tokenIds) external onlyOwner {\n        for (uint256 i = 0; i < tokenIds.length; ++i) {\n            _CRYPTOPUNKS.transferPunk(owner, tokenIds[i]);\n        }\n    }\n\n    // --------------------- VIEW ---------------------\n\n    /**\n     * @notice Fetches a bid corresponding to an auction.\n     * @param auction The address of the auction to fetch a bid for.\n     * @return bid The bid corresponding to the auction.\n     */\n    function getOrder(address auction) external view returns (Order memory) {\n        (address paymentToken,) = IAuction(auction).bidConfig();\n        Order[] storage _orders = paymentTokenToOrders[paymentToken];\n\n        for (uint256 i = 0; i < _orders.length; ++i) {\n            Order storage bid = _orders[i];\n            if (bid.auction == auction) {\n                if (!IAuction(bid.auction).finalized()) {\n                    return bid;\n                } else {\n                    // If the auction is finalized, the bid is invalid.\n                    revert OrderNotFound();\n                }\n            }\n        }\n\n        revert OrderNotFound();\n    }\n\n    /**\n     * @notice Fetches the total amount of locked funds for a given token.\n     * @param tokenAddress The address of the token to fetch the locked amount for. Zero address for ETH.\n     */\n    function totalLocked(address tokenAddress) external view returns (uint256 lockedAmount) {\n        (lockedAmount,) = _totalLockedAndStaleBids(tokenAddress);\n    }\n\n    /**\n     * @notice Fetches the total amount of available funds for a given token.\n     * @param tokenAddress The address of the token to fetch the available amount for. Zero address for ETH.\n     */\n    function availableLiquidity(address tokenAddress) public view returns (uint256 availableAmount) {\n        uint256 tokenBalance = _balanceOfToken(tokenAddress);\n        (uint256 lockedAmount,) = _totalLockedAndStaleBids(tokenAddress);\n        availableAmount = tokenBalance - lockedAmount;\n    }\n\n    /**\n     * @notice convenience function that returns the total amount of useable ETH and WETH.\n     * @return availableAmount The total amount of useable ETH and WETH.\n     */\n    function availableLiquidityWETHAndETH() public view returns (uint256 availableAmount) {\n        uint256 wethHeldByOwner = _WETH.balanceOf(owner);\n        uint256 wethApprovedByOwner = _WETH.allowance(owner, address(this));\n        uint256 availableWETH = wethHeldByOwner > wethApprovedByOwner ? wethApprovedByOwner : wethHeldByOwner;\n\n        availableAmount = availableWETH + availableLiquidity(address(_WETH)) + availableLiquidity(address(0));\n    }\n\n    /**\n     * @notice Returns the current version of this particular Stash.\n     * @return _VERSION The current version of this Stash.\n     */\n    function version() external pure returns (uint256) {\n        return _VERSION;\n    }\n\n    // --------------------- ERC165 ---------------------\n\n    function onERC1155Received(address, address, uint256, uint256, bytes memory) public virtual returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory)\n        public\n        virtual\n        returns (bytes4)\n    {\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    function onERC721Received(address, address, uint256, bytes memory) public virtual returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    // --------------------- INTERNAL ---------------------\n\n    function _transferTokens(address tokenAddress, uint256 amount) internal {\n        if (tokenAddress == address(0)) {\n            (bool success,) = payable(msg.sender).call{value: amount}(\"\");\n            if (!success) revert FailedToWithdraw();\n        } else {\n            SafeTransferLib.safeTransfer(tokenAddress, msg.sender, amount);\n        }\n    }\n\n    function _replaceOrIncrementExistingOrders(\n        Order storage existingOrder,\n        uint16 updatedNumberOfUnits,\n        uint80 updatedPricePerUnit,\n        uint256 _availableLiquidity,\n        OrderType _type\n    ) internal {\n        if (_type == OrderType.UNREPLACEABLE) revert InvalidOrderAlteration();\n\n        if (\n            _bidDeltaExceedsLiquidity(\n                uint256(existingOrder.numberOfUnits) * existingOrder.pricePerUnit,\n                uint256(updatedNumberOfUnits) * updatedPricePerUnit,\n                _availableLiquidity\n            )\n        ) revert RequestExceedsAvailableBalance();\n\n        if (_type == OrderType.SUBSEQUENT_BIDS_REPLACE_EXISTING_PRICE_INCREASE_REQUIRED) {\n            if (existingOrder.pricePerUnit >= updatedPricePerUnit) {\n                revert InvalidOrderAlteration();\n            } else {\n                // `numberOfUnits` is allowed to decrease as long as `pricePerUnit` increases.\n                existingOrder.numberOfUnits = updatedNumberOfUnits;\n                existingOrder.pricePerUnit = updatedPricePerUnit;\n                return;\n            }\n        }\n\n        if (_type == OrderType.SUBSEQUENT_BIDS_OVERWRITE_PRICE_AND_ADD_UNITS) {\n            unchecked {\n                existingOrder.numberOfUnits += updatedNumberOfUnits;\n            }\n            existingOrder.pricePerUnit = updatedPricePerUnit;\n        }\n    }\n\n    // internal helpers\n    function _swapWETH(uint256 wethAmount) internal {\n        uint256 availableBalance = availableLiquidity(address(_WETH));\n\n        // if existing balance is high enough just withdraw it and return early.\n        if (availableBalance >= wethAmount) {\n            _WETH.withdraw(wethAmount);\n            return;\n        }\n\n        uint256 amountToTransfer = wethAmount;\n        // if existing balance is not high enough but greater than 0, decrement the amount needed by the existing balance.\n        if (availableBalance > 0 && availableBalance < wethAmount) {\n            unchecked {\n                amountToTransfer -= availableBalance;\n            }\n        }\n        _WETH.transferFrom(owner, address(this), amountToTransfer);\n        _WETH.withdraw(wethAmount);\n    }\n\n    // --------------------- INTERNAL VIEW ---------------------\n\n    function _isValidSignature(PunkBid calldata bid, bytes memory signature) internal view returns (bool) {\n        Order calldata order = bid.order;\n\n        bytes32 hashStruct = keccak256(\n            abi.encode(\n                _PUNK_BID_TYPEHASH,\n                keccak256(abi.encode(_ORDER_TYPEHASH, order.numberOfUnits, order.pricePerUnit, order.auction)),\n                bid.accountNonce,\n                bid.bidNonce,\n                bid.expiration,\n                bid.root\n            )\n        );\n\n        bytes32 _domainHash = keccak256(\n            abi.encode(\n                keccak256(\"EIP712Domain(uint256 chainId,address verifyingContract)\"), block.chainid, address(this)\n            )\n        );\n        bytes32 hash = keccak256(abi.encodePacked(\"\\x19\\x01\", _domainHash, hashStruct));\n\n        // This lib does not include a malleability check, however, the bidNonce will prevent signature reuse.\n        return SignatureCheckerLib.isValidSignatureNow(owner, hash, signature);\n    }\n\n    function _totalAmountBid(Order storage _order) internal view returns (uint256) {\n        return uint256(_order.numberOfUnits) * _order.pricePerUnit;\n    }\n\n    function _balanceOfToken(address tokenAddress) internal view returns (uint256) {\n        if (tokenAddress == address(0)) {\n            return address(this).balance;\n        } else {\n            return IERC20(tokenAddress).balanceOf(address(this));\n        }\n    }\n\n    function _totalLockedAndStaleBids(address tokenAddress)\n        internal\n        view\n        returns (uint256 _lockedAmount, uint256 finalizedIndexes)\n    {\n        Order[] storage _orders = paymentTokenToOrders[tokenAddress];\n\n        for (uint256 i = 0; i < _orders.length; ++i) {\n            Order storage order = _orders[i];\n            IAuction auction = IAuction(order.auction);\n\n            if (auction.finalized()) {\n                finalizedIndexes = finalizedIndexes | (1 << i);\n            } else {\n                (address paymentToken,) = auction.bidConfig();\n                if (tokenAddress == paymentToken) {\n                    unchecked {\n                        _lockedAmount += _totalAmountBid(order);\n                    }\n                }\n            }\n        }\n    }\n\n    function _cleanStaleBids(address tokenAddress, uint256 finalizedIndexes) internal {\n        Order[] storage _orders = paymentTokenToOrders[tokenAddress];\n\n        // If there are no bids to process, exit early.\n        if (_orders.length == 0) return;\n\n        // Otherwise, use a while loop to iterate and clean up stale bids.\n        uint256 i = _orders.length;\n\n        while (i > 0) {\n            unchecked {\n                --i;\n            }\n            if ((finalizedIndexes & (1 << i)) != 0) {\n                _removeBid(tokenAddress, i);\n                // If the last bid is removed, break out of the loop.\n                if (_orders.length == 0) break;\n            }\n        }\n    }\n\n    function _removeBid(address _key, uint256 _bidIndex) internal {\n        Order[] storage _orders = paymentTokenToOrders[_key];\n        Order memory orderToRemove = _orders[_bidIndex];\n\n        if (_bidIndex != _orders.length - 1) {\n            _orders[_bidIndex] = _orders[_orders.length - 1];\n        }\n        _orders.pop();\n\n        emit OrderRemoved(orderToRemove);\n    }\n\n    function _bidDeltaExceedsLiquidity(uint256 existingTotal, uint256 newTotal, uint256 _availableLiquidity)\n        internal\n        pure\n        returns (bool)\n    {\n        if (newTotal > existingTotal && newTotal - existingTotal > _availableLiquidity) {\n            return true;\n        }\n\n        return false;\n    }\n}\n"
    },
    "src/interfaces/IAuction.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"forge-std/interfaces/IERC165.sol\";\nimport {OrderType} from \"../helpers/Enum.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IAuction is IERC165 {\n    error AuctionNotOpen();\n    error BidTooLow();\n    error CannotFinalizeOpenAuction();\n\n    function bidConfig() external view returns (address, OrderType);\n\n    function open() external view returns (bool);\n\n    function finalized() external view returns (bool);\n\n    function withdraw() external;\n\n    function currentPrice() external view returns (uint80);\n}\n"
    },
    "src/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.23;\n\ninterface IWETH {\n    function transfer(address dst, uint256 wad) external;\n    function transferFrom(address src, address dst, uint256 wad) external;\n    function deposit() external payable;\n    function withdraw(uint256 wad) external;\n    function balanceOf(address user) external view returns (uint256);\n    function approve(address guy, uint256 wad) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n}\n"
    },
    "src/helpers/Enum.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nenum OrderType\n{\n    // 0: Can replace previous bid. Alters bid price and adds `numberOfUnits`\n    SUBSEQUENT_BIDS_OVERWRITE_PRICE_AND_ADD_UNITS,\n    // 1: Can replace previous bid if new bid has higher `pricePerUnit`\n    SUBSEQUENT_BIDS_REPLACE_EXISTING_PRICE_INCREASE_REQUIRED,\n    // 2: Cannot replace previous bid under any circumstance\n    UNREPLACEABLE\n}\n"
    },
    "src/helpers/Struct.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {OrderType} from \"./Enum.sol\";\n\nstruct Order {\n    uint16 numberOfUnits;\n    uint80 pricePerUnit;\n    address auction;\n}\n\nstruct PunkBid {\n    Order order;\n    uint256 accountNonce;\n    uint256 bidNonce;\n    uint256 expiration;\n    bytes32 root;\n}\n"
    },
    "lib/solady/src/utils/MerkleProofLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Gas optimized verification of proof of inclusion for a leaf in a Merkle tree.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/MerkleProofLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/MerkleProofLib.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/MerkleProof.sol)\nlibrary MerkleProofLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*            MERKLE PROOF VERIFICATION OPERATIONS            */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns whether `leaf` exists in the Merkle tree with `root`, given `proof`.\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf)\n        internal\n        pure\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(proof) {\n                // Initialize `offset` to the offset of `proof` elements in memory.\n                let offset := add(proof, 0x20)\n                // Left shift by 5 is equivalent to multiplying by 0x20.\n                let end := add(offset, shl(5, mload(proof)))\n                // Iterate over proof elements to compute root hash.\n                for {} 1 {} {\n                    // Slot of `leaf` in scratch space.\n                    // If the condition is true: 0x20, otherwise: 0x00.\n                    let scratch := shl(5, gt(leaf, mload(offset)))\n                    // Store elements to hash contiguously in scratch space.\n                    // Scratch space is 64 bytes (0x00 - 0x3f) and both elements are 32 bytes.\n                    mstore(scratch, leaf)\n                    mstore(xor(scratch, 0x20), mload(offset))\n                    // Reuse `leaf` to store the hash to reduce stack operations.\n                    leaf := keccak256(0x00, 0x40)\n                    offset := add(offset, 0x20)\n                    if iszero(lt(offset, end)) { break }\n                }\n            }\n            isValid := eq(leaf, root)\n        }\n    }\n\n    /// @dev Returns whether `leaf` exists in the Merkle tree with `root`, given `proof`.\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf)\n        internal\n        pure\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if proof.length {\n                // Left shift by 5 is equivalent to multiplying by 0x20.\n                let end := add(proof.offset, shl(5, proof.length))\n                // Initialize `offset` to the offset of `proof` in the calldata.\n                let offset := proof.offset\n                // Iterate over proof elements to compute root hash.\n                for {} 1 {} {\n                    // Slot of `leaf` in scratch space.\n                    // If the condition is true: 0x20, otherwise: 0x00.\n                    let scratch := shl(5, gt(leaf, calldataload(offset)))\n                    // Store elements to hash contiguously in scratch space.\n                    // Scratch space is 64 bytes (0x00 - 0x3f) and both elements are 32 bytes.\n                    mstore(scratch, leaf)\n                    mstore(xor(scratch, 0x20), calldataload(offset))\n                    // Reuse `leaf` to store the hash to reduce stack operations.\n                    leaf := keccak256(0x00, 0x40)\n                    offset := add(offset, 0x20)\n                    if iszero(lt(offset, end)) { break }\n                }\n            }\n            isValid := eq(leaf, root)\n        }\n    }\n\n    /// @dev Returns whether all `leaves` exist in the Merkle tree with `root`,\n    /// given `proof` and `flags`.\n    ///\n    /// Note:\n    /// - Breaking the invariant `flags.length == (leaves.length - 1) + proof.length`\n    ///   will always return false.\n    /// - The sum of the lengths of `proof` and `leaves` must never overflow.\n    /// - Any non-zero word in the `flags` array is treated as true.\n    /// - The memory offset of `proof` must be non-zero\n    ///   (i.e. `proof` is not pointing to the scratch space).\n    function verifyMultiProof(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32[] memory leaves,\n        bool[] memory flags\n    ) internal pure returns (bool isValid) {\n        // Rebuilds the root by consuming and producing values on a queue.\n        // The queue starts with the `leaves` array, and goes into a `hashes` array.\n        // After the process, the last element on the queue is verified\n        // to be equal to the `root`.\n        //\n        // The `flags` array denotes whether the sibling\n        // should be popped from the queue (`flag == true`), or\n        // should be popped from the `proof` (`flag == false`).\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cache the lengths of the arrays.\n            let leavesLength := mload(leaves)\n            let proofLength := mload(proof)\n            let flagsLength := mload(flags)\n\n            // Advance the pointers of the arrays to point to the data.\n            leaves := add(0x20, leaves)\n            proof := add(0x20, proof)\n            flags := add(0x20, flags)\n\n            // If the number of flags is correct.\n            for {} eq(add(leavesLength, proofLength), add(flagsLength, 1)) {} {\n                // For the case where `proof.length + leaves.length == 1`.\n                if iszero(flagsLength) {\n                    // `isValid = (proof.length == 1 ? proof[0] : leaves[0]) == root`.\n                    isValid := eq(mload(xor(leaves, mul(xor(proof, leaves), proofLength))), root)\n                    break\n                }\n\n                // The required final proof offset if `flagsLength` is not zero, otherwise zero.\n                let proofEnd := add(proof, shl(5, proofLength))\n                // We can use the free memory space for the queue.\n                // We don't need to allocate, since the queue is temporary.\n                let hashesFront := mload(0x40)\n                // Copy the leaves into the hashes.\n                // Sometimes, a little memory expansion costs less than branching.\n                // Should cost less, even with a high free memory offset of 0x7d00.\n                leavesLength := shl(5, leavesLength)\n                for { let i := 0 } iszero(eq(i, leavesLength)) { i := add(i, 0x20) } {\n                    mstore(add(hashesFront, i), mload(add(leaves, i)))\n                }\n                // Compute the back of the hashes.\n                let hashesBack := add(hashesFront, leavesLength)\n                // This is the end of the memory for the queue.\n                // We recycle `flagsLength` to save on stack variables (sometimes save gas).\n                flagsLength := add(hashesBack, shl(5, flagsLength))\n\n                for {} 1 {} {\n                    // Pop from `hashes`.\n                    let a := mload(hashesFront)\n                    // Pop from `hashes`.\n                    let b := mload(add(hashesFront, 0x20))\n                    hashesFront := add(hashesFront, 0x40)\n\n                    // If the flag is false, load the next proof,\n                    // else, pops from the queue.\n                    if iszero(mload(flags)) {\n                        // Loads the next proof.\n                        b := mload(proof)\n                        proof := add(proof, 0x20)\n                        // Unpop from `hashes`.\n                        hashesFront := sub(hashesFront, 0x20)\n                    }\n\n                    // Advance to the next flag.\n                    flags := add(flags, 0x20)\n\n                    // Slot of `a` in scratch space.\n                    // If the condition is true: 0x20, otherwise: 0x00.\n                    let scratch := shl(5, gt(a, b))\n                    // Hash the scratch space and push the result onto the queue.\n                    mstore(scratch, a)\n                    mstore(xor(scratch, 0x20), b)\n                    mstore(hashesBack, keccak256(0x00, 0x40))\n                    hashesBack := add(hashesBack, 0x20)\n                    if iszero(lt(hashesBack, flagsLength)) { break }\n                }\n                isValid :=\n                    and(\n                        // Checks if the last value in the queue is same as the root.\n                        eq(mload(sub(hashesBack, 0x20)), root),\n                        // And whether all the proofs are used, if required.\n                        eq(proofEnd, proof)\n                    )\n                break\n            }\n        }\n    }\n\n    /// @dev Returns whether all `leaves` exist in the Merkle tree with `root`,\n    /// given `proof` and `flags`.\n    ///\n    /// Note:\n    /// - Breaking the invariant `flags.length == (leaves.length - 1) + proof.length`\n    ///   will always return false.\n    /// - Any non-zero word in the `flags` array is treated as true.\n    /// - The calldata offset of `proof` must be non-zero\n    ///   (i.e. `proof` is from a regular Solidity function with a 4-byte selector).\n    function verifyMultiProofCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32[] calldata leaves,\n        bool[] calldata flags\n    ) internal pure returns (bool isValid) {\n        // Rebuilds the root by consuming and producing values on a queue.\n        // The queue starts with the `leaves` array, and goes into a `hashes` array.\n        // After the process, the last element on the queue is verified\n        // to be equal to the `root`.\n        //\n        // The `flags` array denotes whether the sibling\n        // should be popped from the queue (`flag == true`), or\n        // should be popped from the `proof` (`flag == false`).\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the number of flags is correct.\n            for {} eq(add(leaves.length, proof.length), add(flags.length, 1)) {} {\n                // For the case where `proof.length + leaves.length == 1`.\n                if iszero(flags.length) {\n                    // `isValid = (proof.length == 1 ? proof[0] : leaves[0]) == root`.\n                    // forgefmt: disable-next-item\n                    isValid := eq(\n                        calldataload(\n                            xor(leaves.offset, mul(xor(proof.offset, leaves.offset), proof.length))\n                        ),\n                        root\n                    )\n                    break\n                }\n\n                // The required final proof offset if `flagsLength` is not zero, otherwise zero.\n                let proofEnd := add(proof.offset, shl(5, proof.length))\n                // We can use the free memory space for the queue.\n                // We don't need to allocate, since the queue is temporary.\n                let hashesFront := mload(0x40)\n                // Copy the leaves into the hashes.\n                // Sometimes, a little memory expansion costs less than branching.\n                // Should cost less, even with a high free memory offset of 0x7d00.\n                calldatacopy(hashesFront, leaves.offset, shl(5, leaves.length))\n                // Compute the back of the hashes.\n                let hashesBack := add(hashesFront, shl(5, leaves.length))\n                // This is the end of the memory for the queue.\n                // We recycle `flagsLength` to save on stack variables (sometimes save gas).\n                flags.length := add(hashesBack, shl(5, flags.length))\n\n                // We don't need to make a copy of `proof.offset` or `flags.offset`,\n                // as they are pass-by-value (this trick may not always save gas).\n\n                for {} 1 {} {\n                    // Pop from `hashes`.\n                    let a := mload(hashesFront)\n                    // Pop from `hashes`.\n                    let b := mload(add(hashesFront, 0x20))\n                    hashesFront := add(hashesFront, 0x40)\n\n                    // If the flag is false, load the next proof,\n                    // else, pops from the queue.\n                    if iszero(calldataload(flags.offset)) {\n                        // Loads the next proof.\n                        b := calldataload(proof.offset)\n                        proof.offset := add(proof.offset, 0x20)\n                        // Unpop from `hashes`.\n                        hashesFront := sub(hashesFront, 0x20)\n                    }\n\n                    // Advance to the next flag offset.\n                    flags.offset := add(flags.offset, 0x20)\n\n                    // Slot of `a` in scratch space.\n                    // If the condition is true: 0x20, otherwise: 0x00.\n                    let scratch := shl(5, gt(a, b))\n                    // Hash the scratch space and push the result onto the queue.\n                    mstore(scratch, a)\n                    mstore(xor(scratch, 0x20), b)\n                    mstore(hashesBack, keccak256(0x00, 0x40))\n                    hashesBack := add(hashesBack, 0x20)\n                    if iszero(lt(hashesBack, flags.length)) { break }\n                }\n                isValid :=\n                    and(\n                        // Checks if the last value in the queue is same as the root.\n                        eq(mload(sub(hashesBack, 0x20)), root),\n                        // And whether all the proofs are used, if required.\n                        eq(proofEnd, proof.offset)\n                    )\n                break\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   EMPTY CALLDATA HELPERS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns an empty calldata bytes32 array.\n    function emptyProof() internal pure returns (bytes32[] calldata proof) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            proof.length := 0\n        }\n    }\n\n    /// @dev Returns an empty calldata bytes32 array.\n    function emptyLeaves() internal pure returns (bytes32[] calldata leaves) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            leaves.length := 0\n        }\n    }\n\n    /// @dev Returns an empty calldata bool array.\n    function emptyFlags() internal pure returns (bool[] calldata flags) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            flags.length := 0\n        }\n    }\n}\n"
    },
    "lib/solady/src/utils/SignatureCheckerLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Signature verification helper that supports both ECDSA signatures from EOAs\n/// and ERC1271 signatures from smart contract wallets like Argent and Gnosis safe.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SignatureCheckerLib.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/SignatureChecker.sol)\n///\n/// @dev Note:\n/// - The signature checking functions use the ecrecover precompile (0x1).\n/// - The `bytes memory signature` variants use the identity precompile (0x4)\n///   to copy memory internally.\n/// - Unlike ECDSA signatures, contract signatures are revocable.\n/// - As of Solady version 0.0.134, all `bytes signature` variants accept both\n///   regular 65-byte `(r, s, v)` and EIP-2098 `(r, vs)` short form signatures.\n///   See: https://eips.ethereum.org/EIPS/eip-2098\n///   This is for calldata efficiency on smart accounts prevalent on L2s.\n///\n/// WARNING! Do NOT use signatures as unique identifiers:\n/// - Use a nonce in the digest to prevent replay attacks on the same contract.\n/// - Use EIP-712 for the digest to prevent replay attacks across different chains and contracts.\n///   EIP-712 also enables readable signing of typed data for better user safety.\n/// This implementation does NOT check if a signature is non-malleable.\nlibrary SignatureCheckerLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*               SIGNATURE CHECKING OPERATIONS                */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns whether `signature` is valid for `signer` and `hash`.\n    /// If `signer` is a smart contract, the signature is validated with ERC1271.\n    /// Otherwise, the signature is validated with `ECDSA.recover`.\n    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clean the upper 96 bits of `signer` in case they are dirty.\n            for { signer := shr(96, shl(96, signer)) } signer {} {\n                let m := mload(0x40)\n                mstore(0x00, hash)\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\n                if eq(mload(signature), 64) {\n                    let vs := mload(add(signature, 0x40))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                    let t :=\n                        staticcall(\n                            gas(), // Amount of gas left for the transaction.\n                            1, // Address of `ecrecover`.\n                            0x00, // Start of input.\n                            0x80, // Size of input.\n                            0x01, // Start of output.\n                            0x20 // Size of output.\n                        )\n                    // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                    if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\n                        isValid := 1\n                        mstore(0x60, 0) // Restore the zero slot.\n                        mstore(0x40, m) // Restore the free memory pointer.\n                        break\n                    }\n                }\n                if eq(mload(signature), 65) {\n                    mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\n                    mstore(0x60, mload(add(signature, 0x40))) // `s`.\n                    let t :=\n                        staticcall(\n                            gas(), // Amount of gas left for the transaction.\n                            1, // Address of `ecrecover`.\n                            0x00, // Start of input.\n                            0x80, // Size of input.\n                            0x01, // Start of output.\n                            0x20 // Size of output.\n                        )\n                    // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                    if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\n                        isValid := 1\n                        mstore(0x60, 0) // Restore the zero slot.\n                        mstore(0x40, m) // Restore the free memory pointer.\n                        break\n                    }\n                }\n                mstore(0x60, 0) // Restore the zero slot.\n                mstore(0x40, m) // Restore the free memory pointer.\n\n                let f := shl(224, 0x1626ba7e)\n                mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m, 0x04), hash)\n                let d := add(m, 0x24)\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\n                // Copy the `signature` over.\n                let n := add(0x20, mload(signature))\n                pop(staticcall(gas(), 4, signature, n, add(m, 0x44), n))\n                // forgefmt: disable-next-item\n                isValid := and(\n                    // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\n                    eq(mload(d), f),\n                    // Whether the staticcall does not revert.\n                    // This must be placed at the end of the `and` clause,\n                    // as the arguments are evaluated from right to left.\n                    staticcall(\n                        gas(), // Remaining gas.\n                        signer, // The `signer` address.\n                        m, // Offset of calldata in memory.\n                        add(returndatasize(), 0x44), // Length of calldata in memory.\n                        d, // Offset of returndata.\n                        0x20 // Length of returndata to write.\n                    )\n                )\n                break\n            }\n        }\n    }\n\n    /// @dev Returns whether `signature` is valid for `signer` and `hash`.\n    /// If `signer` is a smart contract, the signature is validated with ERC1271.\n    /// Otherwise, the signature is validated with `ECDSA.recover`.\n    function isValidSignatureNowCalldata(address signer, bytes32 hash, bytes calldata signature)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clean the upper 96 bits of `signer` in case they are dirty.\n            for { signer := shr(96, shl(96, signer)) } signer {} {\n                let m := mload(0x40)\n                mstore(0x00, hash)\n                if eq(signature.length, 64) {\n                    let vs := calldataload(add(signature.offset, 0x20))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x40, calldataload(signature.offset)) // `r`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                    let t :=\n                        staticcall(\n                            gas(), // Amount of gas left for the transaction.\n                            1, // Address of `ecrecover`.\n                            0x00, // Start of input.\n                            0x80, // Size of input.\n                            0x01, // Start of output.\n                            0x20 // Size of output.\n                        )\n                    // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                    if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\n                        isValid := 1\n                        mstore(0x60, 0) // Restore the zero slot.\n                        mstore(0x40, m) // Restore the free memory pointer.\n                        break\n                    }\n                }\n                if eq(signature.length, 65) {\n                    mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\n                    calldatacopy(0x40, signature.offset, 0x40) // `r`, `s`.\n                    let t :=\n                        staticcall(\n                            gas(), // Amount of gas left for the transaction.\n                            1, // Address of `ecrecover`.\n                            0x00, // Start of input.\n                            0x80, // Size of input.\n                            0x01, // Start of output.\n                            0x20 // Size of output.\n                        )\n                    // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                    if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\n                        isValid := 1\n                        mstore(0x60, 0) // Restore the zero slot.\n                        mstore(0x40, m) // Restore the free memory pointer.\n                        break\n                    }\n                }\n                mstore(0x60, 0) // Restore the zero slot.\n                mstore(0x40, m) // Restore the free memory pointer.\n\n                let f := shl(224, 0x1626ba7e)\n                mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m, 0x04), hash)\n                let d := add(m, 0x24)\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\n                mstore(add(m, 0x44), signature.length)\n                // Copy the `signature` over.\n                calldatacopy(add(m, 0x64), signature.offset, signature.length)\n                // forgefmt: disable-next-item\n                isValid := and(\n                    // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\n                    eq(mload(d), f),\n                    // Whether the staticcall does not revert.\n                    // This must be placed at the end of the `and` clause,\n                    // as the arguments are evaluated from right to left.\n                    staticcall(\n                        gas(), // Remaining gas.\n                        signer, // The `signer` address.\n                        m, // Offset of calldata in memory.\n                        add(signature.length, 0x64), // Length of calldata in memory.\n                        d, // Offset of returndata.\n                        0x20 // Length of returndata to write.\n                    )\n                )\n                break\n            }\n        }\n    }\n\n    /// @dev Returns whether the signature (`r`, `vs`) is valid for `signer` and `hash`.\n    /// If `signer` is a smart contract, the signature is validated with ERC1271.\n    /// Otherwise, the signature is validated with `ECDSA.recover`.\n    function isValidSignatureNow(address signer, bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clean the upper 96 bits of `signer` in case they are dirty.\n            for { signer := shr(96, shl(96, signer)) } signer {} {\n                let m := mload(0x40)\n                mstore(0x00, hash)\n                mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                mstore(0x40, r) // `r`.\n                mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                let t :=\n                    staticcall(\n                        gas(), // Amount of gas left for the transaction.\n                        1, // Address of `ecrecover`.\n                        0x00, // Start of input.\n                        0x80, // Size of input.\n                        0x01, // Start of output.\n                        0x20 // Size of output.\n                    )\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\n                    isValid := 1\n                    mstore(0x60, 0) // Restore the zero slot.\n                    mstore(0x40, m) // Restore the free memory pointer.\n                    break\n                }\n\n                let f := shl(224, 0x1626ba7e)\n                mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m, 0x04), hash)\n                let d := add(m, 0x24)\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\n                mstore(add(m, 0x44), 65) // Length of the signature.\n                mstore(add(m, 0x64), r) // `r`.\n                mstore(add(m, 0x84), mload(0x60)) // `s`.\n                mstore8(add(m, 0xa4), mload(0x20)) // `v`.\n                // forgefmt: disable-next-item\n                isValid := and(\n                    // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\n                    eq(mload(d), f),\n                    // Whether the staticcall does not revert.\n                    // This must be placed at the end of the `and` clause,\n                    // as the arguments are evaluated from right to left.\n                    staticcall(\n                        gas(), // Remaining gas.\n                        signer, // The `signer` address.\n                        m, // Offset of calldata in memory.\n                        0xa5, // Length of calldata in memory.\n                        d, // Offset of returndata.\n                        0x20 // Length of returndata to write.\n                    )\n                )\n                mstore(0x60, 0) // Restore the zero slot.\n                mstore(0x40, m) // Restore the free memory pointer.\n                break\n            }\n        }\n    }\n\n    /// @dev Returns whether the signature (`v`, `r`, `s`) is valid for `signer` and `hash`.\n    /// If `signer` is a smart contract, the signature is validated with ERC1271.\n    /// Otherwise, the signature is validated with `ECDSA.recover`.\n    function isValidSignatureNow(address signer, bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clean the upper 96 bits of `signer` in case they are dirty.\n            for { signer := shr(96, shl(96, signer)) } signer {} {\n                let m := mload(0x40)\n                mstore(0x00, hash)\n                mstore(0x20, and(v, 0xff)) // `v`.\n                mstore(0x40, r) // `r`.\n                mstore(0x60, s) // `s`.\n                let t :=\n                    staticcall(\n                        gas(), // Amount of gas left for the transaction.\n                        1, // Address of `ecrecover`.\n                        0x00, // Start of input.\n                        0x80, // Size of input.\n                        0x01, // Start of output.\n                        0x20 // Size of output.\n                    )\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\n                    isValid := 1\n                    mstore(0x60, 0) // Restore the zero slot.\n                    mstore(0x40, m) // Restore the free memory pointer.\n                    break\n                }\n\n                let f := shl(224, 0x1626ba7e)\n                mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m, 0x04), hash)\n                let d := add(m, 0x24)\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\n                mstore(add(m, 0x44), 65) // Length of the signature.\n                mstore(add(m, 0x64), r) // `r`.\n                mstore(add(m, 0x84), s) // `s`.\n                mstore8(add(m, 0xa4), v) // `v`.\n                // forgefmt: disable-next-item\n                isValid := and(\n                    // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\n                    eq(mload(d), f),\n                    // Whether the staticcall does not revert.\n                    // This must be placed at the end of the `and` clause,\n                    // as the arguments are evaluated from right to left.\n                    staticcall(\n                        gas(), // Remaining gas.\n                        signer, // The `signer` address.\n                        m, // Offset of calldata in memory.\n                        0xa5, // Length of calldata in memory.\n                        d, // Offset of returndata.\n                        0x20 // Length of returndata to write.\n                    )\n                )\n                mstore(0x60, 0) // Restore the zero slot.\n                mstore(0x40, m) // Restore the free memory pointer.\n                break\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     ERC1271 OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns whether `signature` is valid for `hash` for an ERC1271 `signer` contract.\n    function isValidERC1271SignatureNow(address signer, bytes32 hash, bytes memory signature)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let f := shl(224, 0x1626ba7e)\n            mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x04), hash)\n            let d := add(m, 0x24)\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\n            // Copy the `signature` over.\n            let n := add(0x20, mload(signature))\n            pop(staticcall(gas(), 4, signature, n, add(m, 0x44), n))\n            // forgefmt: disable-next-item\n            isValid := and(\n                // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\n                eq(mload(d), f),\n                // Whether the staticcall does not revert.\n                // This must be placed at the end of the `and` clause,\n                // as the arguments are evaluated from right to left.\n                staticcall(\n                    gas(), // Remaining gas.\n                    signer, // The `signer` address.\n                    m, // Offset of calldata in memory.\n                    add(returndatasize(), 0x44), // Length of calldata in memory.\n                    d, // Offset of returndata.\n                    0x20 // Length of returndata to write.\n                )\n            )\n        }\n    }\n\n    /// @dev Returns whether `signature` is valid for `hash` for an ERC1271 `signer` contract.\n    function isValidERC1271SignatureNowCalldata(\n        address signer,\n        bytes32 hash,\n        bytes calldata signature\n    ) internal view returns (bool isValid) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let f := shl(224, 0x1626ba7e)\n            mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x04), hash)\n            let d := add(m, 0x24)\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\n            mstore(add(m, 0x44), signature.length)\n            // Copy the `signature` over.\n            calldatacopy(add(m, 0x64), signature.offset, signature.length)\n            // forgefmt: disable-next-item\n            isValid := and(\n                // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\n                eq(mload(d), f),\n                // Whether the staticcall does not revert.\n                // This must be placed at the end of the `and` clause,\n                // as the arguments are evaluated from right to left.\n                staticcall(\n                    gas(), // Remaining gas.\n                    signer, // The `signer` address.\n                    m, // Offset of calldata in memory.\n                    add(signature.length, 0x64), // Length of calldata in memory.\n                    d, // Offset of returndata.\n                    0x20 // Length of returndata to write.\n                )\n            )\n        }\n    }\n\n    /// @dev Returns whether the signature (`r`, `vs`) is valid for `hash`\n    /// for an ERC1271 `signer` contract.\n    function isValidERC1271SignatureNow(address signer, bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let f := shl(224, 0x1626ba7e)\n            mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x04), hash)\n            let d := add(m, 0x24)\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\n            mstore(add(m, 0x44), 65) // Length of the signature.\n            mstore(add(m, 0x64), r) // `r`.\n            mstore(add(m, 0x84), shr(1, shl(1, vs))) // `s`.\n            mstore8(add(m, 0xa4), add(shr(255, vs), 27)) // `v`.\n            // forgefmt: disable-next-item\n            isValid := and(\n                // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\n                eq(mload(d), f),\n                // Whether the staticcall does not revert.\n                // This must be placed at the end of the `and` clause,\n                // as the arguments are evaluated from right to left.\n                staticcall(\n                    gas(), // Remaining gas.\n                    signer, // The `signer` address.\n                    m, // Offset of calldata in memory.\n                    0xa5, // Length of calldata in memory.\n                    d, // Offset of returndata.\n                    0x20 // Length of returndata to write.\n                )\n            )\n        }\n    }\n\n    /// @dev Returns whether the signature (`v`, `r`, `s`) is valid for `hash`\n    /// for an ERC1271 `signer` contract.\n    function isValidERC1271SignatureNow(address signer, bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let f := shl(224, 0x1626ba7e)\n            mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x04), hash)\n            let d := add(m, 0x24)\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\n            mstore(add(m, 0x44), 65) // Length of the signature.\n            mstore(add(m, 0x64), r) // `r`.\n            mstore(add(m, 0x84), s) // `s`.\n            mstore8(add(m, 0xa4), v) // `v`.\n            // forgefmt: disable-next-item\n            isValid := and(\n                // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\n                eq(mload(d), f),\n                // Whether the staticcall does not revert.\n                // This must be placed at the end of the `and` clause,\n                // as the arguments are evaluated from right to left.\n                staticcall(\n                    gas(), // Remaining gas.\n                    signer, // The `signer` address.\n                    m, // Offset of calldata in memory.\n                    0xa5, // Length of calldata in memory.\n                    d, // Offset of returndata.\n                    0x20 // Length of returndata to write.\n                )\n            )\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     HASHING OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns an Ethereum Signed Message, created from a `hash`.\n    /// This produces a hash corresponding to the one signed with the\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\n    /// JSON-RPC method as part of EIP-191.\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, hash) // Store into scratch space for keccak256.\n            mstore(0x00, \"\\x00\\x00\\x00\\x00\\x19Ethereum Signed Message:\\n32\") // 28 bytes.\n            result := keccak256(0x04, 0x3c) // `32 * 2 - (32 - 28) = 60 = 0x3c`.\n        }\n    }\n\n    /// @dev Returns an Ethereum Signed Message, created from `s`.\n    /// This produces a hash corresponding to the one signed with the\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\n    /// JSON-RPC method as part of EIP-191.\n    /// Note: Supports lengths of `s` up to 999999 bytes.\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let sLength := mload(s)\n            let o := 0x20\n            mstore(o, \"\\x19Ethereum Signed Message:\\n\") // 26 bytes, zero-right-padded.\n            mstore(0x00, 0x00)\n            // Convert the `s.length` to ASCII decimal representation: `base10(s.length)`.\n            for { let temp := sLength } 1 {} {\n                o := sub(o, 1)\n                mstore8(o, add(48, mod(temp, 10)))\n                temp := div(temp, 10)\n                if iszero(temp) { break }\n            }\n            let n := sub(0x3a, o) // Header length: `26 + 32 - o`.\n            // Throw an out-of-offset error (consumes all gas) if the header exceeds 32 bytes.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0x20))\n            mstore(s, or(mload(0x00), mload(n))) // Temporarily store the header.\n            result := keccak256(add(s, sub(0x20, n)), add(n, sLength))\n            mstore(s, sLength) // Restore the length.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   EMPTY CALLDATA HELPERS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns an empty calldata bytes.\n    function emptySignature() internal pure returns (bytes calldata signature) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            signature.length := 0\n        }\n    }\n}\n"
    },
    "lib/solady/src/utils/SafeTransferLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n///\n/// @dev Note:\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\n/// - For ERC20s, this implementation won't check that a token has code,\n///   responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The ETH transfer has failed.\n    error ETHTransferFailed();\n\n    /// @dev The ERC20 `transferFrom` has failed.\n    error TransferFromFailed();\n\n    /// @dev The ERC20 `transfer` has failed.\n    error TransferFailed();\n\n    /// @dev The ERC20 `approve` has failed.\n    error ApproveFailed();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\n\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\n    /// storage reads and writes, but low enough to prevent griefing.\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       ETH OPERATIONS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\n    //\n    // The regular variants:\n    // - Forwards all remaining gas to the target.\n    // - Reverts if the target reverts.\n    // - Reverts if the current contract has insufficient balance.\n    //\n    // The force variants:\n    // - Forwards with an optional gas stipend\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\n    // - If the target reverts, or if the gas stipend is exhausted,\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\n    // - Reverts if the current contract has insufficient balance.\n    //\n    // The try variants:\n    // - Forwards with a mandatory gas stipend.\n    // - Instead of reverting, returns whether the transfer succeeded.\n\n    /// @dev Sends `amount` (in wei) ETH to `to`.\n    function safeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Sends all the ETH in the current contract to `to`.\n    function safeTransferAllETH(address to) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer all the ETH and check if it succeeded or not.\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if lt(selfbalance(), amount) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\n    function forceSafeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if lt(selfbalance(), amount) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\n    function forceSafeTransferAllETH(address to) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // forgefmt: disable-next-item\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\n        }\n    }\n\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      ERC20 OPERATIONS                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have at least `amount` approved for\n    /// the current contract to manage.\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, amount) // Store the `amount` argument.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have their entire balance approved for\n    /// the current contract to manage.\n    function safeTransferAllFrom(address token, address from, address to)\n        internal\n        returns (uint256 amount)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\n            // Read the balance, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\n            // Perform the transfer, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransfer(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\n            mstore(0x20, address()) // Store the address of the current contract.\n            // Read the balance, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x14, to) // Store the `to` argument.\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\n    /// Reverts upon failure.\n    function safeApprove(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n            // Perform the approval, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\n    /// Reverts upon failure.\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n            // Perform the approval, retrying upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x34, 0) // Store 0 for the `amount`.\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n                pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\n                mstore(0x34, amount) // Store back the original `amount`.\n                // Retry the approval, reverting upon failure.\n                if iszero(\n                    and(\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                    )\n                ) {\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\n    /// Returns zero if the `token` does not exist.\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, account) // Store the `account` argument.\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\n            amount :=\n                mul(\n                    mload(0x20),\n                    and( // The arguments of `and` are evaluated from right to left.\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\n                    )\n                )\n        }\n    }\n}\n"
    },
    "lib/forge-std/src/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2;\n\nimport \"./IERC165.sol\";\n\n/// @title ERC-721 Non-Fungible Token Standard\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n/// Note: the ERC-165 identifier for this interface is 0x80ac58cd.\ninterface IERC721 is IERC165 {\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\n    /// This event emits when NFTs are created (`from` == 0) and destroyed\n    /// (`to` == 0). Exception: during contract creation, any number of NFTs\n    /// may be created and assigned without emitting Transfer. At the time of\n    /// any transfer, the approved address for that NFT (if any) is reset to none.\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n\n    /// @dev This emits when the approved address for an NFT is changed or\n    /// reaffirmed. The zero address indicates there is no approved address.\n    /// When a Transfer event emits, this also indicates that the approved\n    /// address for that NFT (if any) is reset to none.\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n\n    /// @dev This emits when an operator is enabled or disabled for an owner.\n    /// The operator can manage all NFTs of the owner.\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n    /// @notice Count all NFTs assigned to an owner\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\n    /// function throws for queries about the zero address.\n    /// @param _owner An address for whom to query the balance\n    /// @return The number of NFTs owned by `_owner`, possibly zero\n    function balanceOf(address _owner) external view returns (uint256);\n\n    /// @notice Find the owner of an NFT\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\n    /// about them do throw.\n    /// @param _tokenId The identifier for an NFT\n    /// @return The address of the owner of the NFT\n    function ownerOf(uint256 _tokenId) external view returns (address);\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n    /// operator, or the approved address for this NFT. Throws if `_from` is\n    /// not the current owner. Throws if `_to` is the zero address. Throws if\n    /// `_tokenId` is not a valid NFT. When transfer is complete, this function\n    /// checks if `_to` is a smart contract (code size > 0). If so, it calls\n    /// `onERC721Received` on `_to` and throws if the return value is not\n    /// `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    /// @param data Additional data with no specified format, sent in call to `_to`\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external payable;\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n    /// @dev This works identically to the other function with an extra data parameter,\n    /// except this function just sets data to \"\".\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\n\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n    /// TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n    /// THEY MAY BE PERMANENTLY LOST\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n    /// operator, or the approved address for this NFT. Throws if `_from` is\n    /// not the current owner. Throws if `_to` is the zero address. Throws if\n    /// `_tokenId` is not a valid NFT.\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\n\n    /// @notice Change or reaffirm the approved address for an NFT\n    /// @dev The zero address indicates there is no approved address.\n    /// Throws unless `msg.sender` is the current NFT owner, or an authorized\n    /// operator of the current owner.\n    /// @param _approved The new approved NFT controller\n    /// @param _tokenId The NFT to approve\n    function approve(address _approved, uint256 _tokenId) external payable;\n\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\n    /// all of `msg.sender`'s assets\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\n    /// multiple operators per owner.\n    /// @param _operator Address to add to the set of authorized operators\n    /// @param _approved True if the operator is approved, false to revoke approval\n    function setApprovalForAll(address _operator, bool _approved) external;\n\n    /// @notice Get the approved address for a single NFT\n    /// @dev Throws if `_tokenId` is not a valid NFT.\n    /// @param _tokenId The NFT to find the approved address for\n    /// @return The approved address for this NFT, or the zero address if there is none\n    function getApproved(uint256 _tokenId) external view returns (address);\n\n    /// @notice Query if an address is an authorized operator for another address\n    /// @param _owner The address that owns the NFTs\n    /// @param _operator The address that acts on behalf of the owner\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n}\n\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\ninterface IERC721TokenReceiver {\n    /// @notice Handle the receipt of an NFT\n    /// @dev The ERC721 smart contract calls this function on the recipient\n    /// after a `transfer`. This function MAY throw to revert and reject the\n    /// transfer. Return of other than the magic value MUST result in the\n    /// transaction being reverted.\n    /// Note: the contract address is always the message sender.\n    /// @param _operator The address which called `safeTransferFrom` function\n    /// @param _from The address which previously owned the token\n    /// @param _tokenId The NFT identifier which is being transferred\n    /// @param _data Additional data with no specified format\n    /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    ///  unless throwing\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data)\n        external\n        returns (bytes4);\n}\n\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n/// Note: the ERC-165 identifier for this interface is 0x5b5e139f.\ninterface IERC721Metadata is IERC721 {\n    /// @notice A descriptive name for a collection of NFTs in this contract\n    function name() external view returns (string memory _name);\n\n    /// @notice An abbreviated name for NFTs in this contract\n    function symbol() external view returns (string memory _symbol);\n\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n    /// 3986. The URI may point to a JSON file that conforms to the \"ERC721\n    /// Metadata JSON Schema\".\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\n}\n\n/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n/// Note: the ERC-165 identifier for this interface is 0x780e9d63.\ninterface IERC721Enumerable is IERC721 {\n    /// @notice Count NFTs tracked by this contract\n    /// @return A count of valid NFTs tracked by this contract, where each one of\n    /// them has an assigned and queryable owner not equal to the zero address\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Enumerate valid NFTs\n    /// @dev Throws if `_index` >= `totalSupply()`.\n    /// @param _index A counter less than `totalSupply()`\n    /// @return The token identifier for the `_index`th NFT,\n    /// (sort order not specified)\n    function tokenByIndex(uint256 _index) external view returns (uint256);\n\n    /// @notice Enumerate NFTs assigned to an owner\n    /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\n    /// `_owner` is the zero address, representing invalid NFTs.\n    /// @param _owner An address where we are interested in NFTs owned by them\n    /// @param _index A counter less than `balanceOf(_owner)`\n    /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\n    /// (sort order not specified)\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\n}\n"
    },
    "lib/forge-std/src/interfaces/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2;\n\nimport \"./IERC165.sol\";\n\n/// @title ERC-1155 Multi Token Standard\n/// @dev See https://eips.ethereum.org/EIPS/eip-1155\n/// Note: The ERC-165 identifier for this interface is 0xd9b67a26.\ninterface IERC1155 is IERC165 {\n    /// @dev\n    /// - Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred, including zero value transfers as well as minting or burning (see \"Safe Transfer Rules\" section of the standard).\n    /// - The `_operator` argument MUST be the address of an account/contract that is approved to make the transfer (SHOULD be msg.sender).\n    /// - The `_from` argument MUST be the address of the holder whose balance is decreased.\n    /// - The `_to` argument MUST be the address of the recipient whose balance is increased.\n    /// - The `_id` argument MUST be the token type being transferred.\n    /// - The `_value` argument MUST be the number of tokens the holder balance is decreased by and match what the recipient balance is increased by.\n    /// - When minting/creating tokens, the `_from` argument MUST be set to `0x0` (i.e. zero address).\n    /// - When burning/destroying tokens, the `_to` argument MUST be set to `0x0` (i.e. zero address).\n    event TransferSingle(\n        address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _value\n    );\n\n    /// @dev\n    /// - Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred, including zero value transfers as well as minting or burning (see \"Safe Transfer Rules\" section of the standard).\n    /// - The `_operator` argument MUST be the address of an account/contract that is approved to make the transfer (SHOULD be msg.sender).\n    /// - The `_from` argument MUST be the address of the holder whose balance is decreased.\n    /// - The `_to` argument MUST be the address of the recipient whose balance is increased.\n    /// - The `_ids` argument MUST be the list of tokens being transferred.\n    /// - The `_values` argument MUST be the list of number of tokens (matching the list and order of tokens specified in _ids) the holder balance is decreased by and match what the recipient balance is increased by.\n    /// - When minting/creating tokens, the `_from` argument MUST be set to `0x0` (i.e. zero address).\n    /// - When burning/destroying tokens, the `_to` argument MUST be set to `0x0` (i.e. zero address).\n    event TransferBatch(\n        address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _values\n    );\n\n    /// @dev MUST emit when approval for a second party/operator address to manage all tokens for an owner address is enabled or disabled (absence of an event assumes disabled).\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n    /// @dev MUST emit when the URI is updated for a token ID. URIs are defined in RFC 3986.\n    /// The URI MUST point to a JSON file that conforms to the \"ERC-1155 Metadata URI JSON Schema\".\n    event URI(string _value, uint256 indexed _id);\n\n    /// @notice Transfers `_value` amount of an `_id` from the `_from` address to the `_to` address specified (with safety call).\n    /// @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \"Approval\" section of the standard).\n    /// - MUST revert if `_to` is the zero address.\n    /// - MUST revert if balance of holder for token `_id` is lower than the `_value` sent.\n    /// - MUST revert on any other error.\n    /// - MUST emit the `TransferSingle` event to reflect the balance change (see \"Safe Transfer Rules\" section of the standard).\n    /// - After the above conditions are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call `onERC1155Received` on `_to` and act appropriately (see \"Safe Transfer Rules\" section of the standard).\n    /// @param _from Source address\n    /// @param _to Target address\n    /// @param _id ID of the token type\n    /// @param _value Transfer amount\n    /// @param _data Additional data with no specified format, MUST be sent unaltered in call to `onERC1155Received` on `_to`\n    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes calldata _data) external;\n\n    /// @notice Transfers `_values` amount(s) of `_ids` from the `_from` address to the `_to` address specified (with safety call).\n    /// @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \"Approval\" section of the standard).\n    /// - MUST revert if `_to` is the zero address.\n    /// - MUST revert if length of `_ids` is not the same as length of `_values`.\n    /// - MUST revert if any of the balance(s) of the holder(s) for token(s) in `_ids` is lower than the respective amount(s) in `_values` sent to the recipient.\n    /// - MUST revert on any other error.\n    /// - MUST emit `TransferSingle` or `TransferBatch` event(s) such that all the balance changes are reflected (see \"Safe Transfer Rules\" section of the standard).\n    /// - Balance changes and events MUST follow the ordering of the arrays (_ids[0]/_values[0] before _ids[1]/_values[1], etc).\n    /// - After the above conditions for the transfer(s) in the batch are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call the relevant `ERC1155TokenReceiver` hook(s) on `_to` and act appropriately (see \"Safe Transfer Rules\" section of the standard).\n    /// @param _from Source address\n    /// @param _to Target address\n    /// @param _ids IDs of each token type (order and length must match _values array)\n    /// @param _values Transfer amounts per token type (order and length must match _ids array)\n    /// @param _data Additional data with no specified format, MUST be sent unaltered in call to the `ERC1155TokenReceiver` hook(s) on `_to`\n    function safeBatchTransferFrom(\n        address _from,\n        address _to,\n        uint256[] calldata _ids,\n        uint256[] calldata _values,\n        bytes calldata _data\n    ) external;\n\n    /// @notice Get the balance of an account's tokens.\n    /// @param _owner The address of the token holder\n    /// @param _id ID of the token\n    /// @return The _owner's balance of the token type requested\n    function balanceOf(address _owner, uint256 _id) external view returns (uint256);\n\n    /// @notice Get the balance of multiple account/token pairs\n    /// @param _owners The addresses of the token holders\n    /// @param _ids ID of the tokens\n    /// @return The _owner's balance of the token types requested (i.e. balance for each (owner, id) pair)\n    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage all of the caller's tokens.\n    /// @dev MUST emit the ApprovalForAll event on success.\n    /// @param _operator Address to add to the set of authorized operators\n    /// @param _approved True if the operator is approved, false to revoke approval\n    function setApprovalForAll(address _operator, bool _approved) external;\n\n    /// @notice Queries the approval status of an operator for a given owner.\n    /// @param _owner The owner of the tokens\n    /// @param _operator Address of authorized operator\n    /// @return True if the operator is approved, false if not\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n}\n"
    },
    "lib/forge-std/src/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2;\n\n/// @dev Interface of the ERC20 standard as defined in the EIP.\n/// @dev This includes the optional name, symbol, and decimals metadata.\ninterface IERC20 {\n    /// @dev Emitted when `value` tokens are moved from one account (`from`) to another (`to`).\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @dev Emitted when the allowance of a `spender` for an `owner` is set, where `value`\n    /// is the new allowance.\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice Returns the amount of tokens in existence.\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Returns the amount of tokens owned by `account`.\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @notice Moves `amount` tokens from the caller's account to `to`.\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /// @notice Returns the remaining number of tokens that `spender` is allowed\n    /// to spend on behalf of `owner`\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /// @notice Sets `amount` as the allowance of `spender` over the caller's tokens.\n    /// @dev Be aware of front-running risks: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /// @notice Moves `amount` tokens from `from` to `to` using the allowance mechanism.\n    /// `amount` is then deducted from the caller's allowance.\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n\n    /// @notice Returns the name of the token.\n    function name() external view returns (string memory);\n\n    /// @notice Returns the symbol of the token.\n    function symbol() external view returns (string memory);\n\n    /// @notice Returns the decimals places of the token.\n    function decimals() external view returns (uint8);\n}\n"
    },
    "src/interfaces/ILegacyWrappedPunks.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\ninterface ILegacyWrappedPunks {\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function proxyInfo(address) external view returns (address);\n    function registerProxy() external;\n    function burn(uint256 punkId) external;\n    function mint(uint256 punkId) external;\n    function approve(address to, uint256 punkId) external;\n    function ownerOf(uint256 punkId) external view returns (address);\n}\n"
    },
    "src/interfaces/ICryptoPunks721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\ninterface ICryptoPunks721 {\n    function wrapPunk(uint256 punkIndex) external;\n\n    function unwrapPunk(uint256 punkIndex) external;\n\n    function wrapPunkBatch(uint256[] calldata punkIndexes) external;\n\n    function unwrapPunkBatch(uint256[] calldata punkIndexes) external;\n\n    function migrateLegacyWrappedPunks(uint256[] calldata punkIndexes) external;\n\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    function approve(address to, uint256 punkId) external;\n\n    function ownerOf(uint256 punkId) external view returns (address);\n}\n"
    },
    "src/interfaces/ICryptoPunks.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\ninterface ICryptoPunks {\n    function punksOfferedForSale(uint256)\n        external\n        view\n        returns (bool isForSale, uint256 punkIndex, address seller, uint256 minValue, address onlySellTo);\n    function buyPunk(uint256) external payable;\n    function transferPunk(address, uint256) external;\n    function balanceOf(address) external returns (uint256);\n    function punkIndexToAddress(uint256) external view returns (address);\n    function pendingWithdrawals(address) external view returns (uint256);\n    function offerPunkForSaleToAddress(uint256, uint256, address) external;\n    function getPunk(uint256 punkId) external;\n}\n"
    },
    "src/interfaces/IStashFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\ninterface IStashFactory {\n    function isStash(address stash) external view returns (bool);\n    function deployStash(address owner) external returns (address);\n    function isAuction(address auction) external view returns (bool);\n    function stashAddressFor(address owner) external view returns (address);\n}\n"
    },
    "src/interfaces/IPunkTransferHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IPunkTransferHelper {\n    function transferWrappedPunkToStash(bytes32 _packedData) external;\n    function transferLegacyWrappedPunkToStash(bytes32 _packedData) external;\n}\n"
    },
    "lib/forge-std/src/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceID The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    /// uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    /// `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "forge-std/=lib/forge-std/src/",
      "@openzeppelin/=lib/openzeppelin-contracts/",
      "ERC721A/=lib/ERC721A/contracts/",
      "solady/=lib/solady/src/",
      "soladytest/=lib/solady/test/",
      "sol-json/=lib/sol-json/src/",
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "solmate/=lib/sol-json/lib/solady/lib/solmate/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "evmVersion": "paris",
    "libraries": {}
  }
}}