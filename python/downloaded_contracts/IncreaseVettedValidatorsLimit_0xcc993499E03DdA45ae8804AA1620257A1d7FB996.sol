{{
  "language": "Solidity",
  "sources": {
    "IncreaseVettedValidatorsLimit.sol": {
      "content": "// SPDX-FileCopyrightText: 2023 Lido <info@lido.fi>\n// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.6;\n\nimport \"EVMScriptCreator.sol\";\nimport \"IEVMScriptFactory.sol\";\nimport \"INodeOperatorsRegistry.sol\";\n\n/// @notice Creates EVMScript to increase staking limit for node operator\ncontract IncreaseVettedValidatorsLimit is IEVMScriptFactory {\n    struct VettedValidatorsLimitInput {\n        uint256 nodeOperatorId;\n        uint256 stakingLimit;\n    }\n    struct NodeOperatorData {\n        uint256 id;\n        bool active;\n        address rewardAddress;\n        uint64 stakingLimit;\n        uint64 totalSigningKeys;\n    }\n\n    // -------------\n    // CONSTANTS\n    // -------------\n    /// @notice keccak256(\"MANAGE_SIGNING_KEYS\")\n    bytes32 private constant MANAGE_SIGNING_KEYS_ROLE =\n        0x75abc64490e17b40ea1e66691c3eb493647b24430b358bd87ec3e5127f1621ee;\n\n    // -------------\n    // ERRORS\n    // -------------\n\n    string private constant NODE_OPERATOR_DISABLED = \"NODE_OPERATOR_DISABLED\";\n    string private constant CALLER_IS_NOT_NODE_OPERATOR_OR_MANAGER =\n        \"CALLER_IS_NOT_NODE_OPERATOR_OR_MANAGER\";\n    string private constant STAKING_LIMIT_TOO_LOW = \"STAKING_LIMIT_TOO_LOW\";\n    string private constant NOT_ENOUGH_SIGNING_KEYS = \"NOT_ENOUGH_SIGNING_KEYS\";\n\n    // -------------\n    // VARIABLES\n    // -------------\n\n    /// @notice Address of NodeOperatorsRegistry contract\n    INodeOperatorsRegistry public immutable nodeOperatorsRegistry;\n\n    // -------------\n    // CONSTRUCTOR\n    // -------------\n\n    constructor(address _nodeOperatorsRegistry) {\n        nodeOperatorsRegistry = INodeOperatorsRegistry(_nodeOperatorsRegistry);\n    }\n\n    // -------------\n    // EXTERNAL METHODS\n    // -------------\n\n    /// @notice Creates EVMScript to increase staking limit for node operator\n    /// @param _creator Address who creates EVMScript\n    /// @param _evmScriptCallData Encoded tuple: (uint256 _nodeOperatorId, uint256 _stakingLimit) where\n    /// _nodeOperatorId - id of node operator in NodeOperatorsRegistry\n    /// _stakingLimit - new staking limit\n    function createEVMScript(\n        address _creator,\n        bytes memory _evmScriptCallData\n    ) external view override returns (bytes memory) {\n        _validateInputData(_creator, _evmScriptCallData);\n\n        return\n            EVMScriptCreator.createEVMScript(\n                address(nodeOperatorsRegistry),\n                nodeOperatorsRegistry.setNodeOperatorStakingLimit.selector,\n                _evmScriptCallData\n            );\n    }\n\n    /// @notice Decodes call data used by createEVMScript method\n    /// @param _evmScriptCallData Encoded tuple: (uint256 _nodeOperatorId, uint256 _stakingLimit) where\n    /// _nodeOperatorId - id of node operator in NodeOperatorsRegistry\n    /// _stakingLimit - new staking limit\n    /// @return VettedValidatorsLimitInput\n    function decodeEVMScriptCallData(\n        bytes memory _evmScriptCallData\n    ) external pure returns (VettedValidatorsLimitInput memory) {\n        return _decodeEVMScriptCallData(_evmScriptCallData);\n    }\n\n    // ------------------\n    // PRIVATE METHODS\n    // ------------------\n\n    function _decodeEVMScriptCallData(\n        bytes memory _evmScriptCallData\n    ) private pure returns (VettedValidatorsLimitInput memory) {\n        return abi.decode(_evmScriptCallData, (VettedValidatorsLimitInput));\n    }\n\n    function _validateInputData(address _creator, bytes memory _evmScriptCallData) private view {\n        VettedValidatorsLimitInput memory vettedValidatorsLimitInput = _decodeEVMScriptCallData(\n            _evmScriptCallData\n        );\n\n        NodeOperatorData memory nodeOperatorData = _getNodeOperatorData(\n            vettedValidatorsLimitInput.nodeOperatorId\n        );\n\n        uint256[] memory role_params = new uint256[](1);\n        role_params[0] = vettedValidatorsLimitInput.nodeOperatorId;\n\n        require(\n            _creator == nodeOperatorData.rewardAddress ||\n                nodeOperatorsRegistry.canPerform(_creator, MANAGE_SIGNING_KEYS_ROLE, role_params),\n            CALLER_IS_NOT_NODE_OPERATOR_OR_MANAGER\n        );\n        require(nodeOperatorData.active, NODE_OPERATOR_DISABLED);\n        require(\n            nodeOperatorData.stakingLimit < vettedValidatorsLimitInput.stakingLimit,\n            STAKING_LIMIT_TOO_LOW\n        );\n        require(\n            nodeOperatorData.totalSigningKeys >= vettedValidatorsLimitInput.stakingLimit,\n            NOT_ENOUGH_SIGNING_KEYS\n        );\n    }\n\n    function _getNodeOperatorData(\n        uint256 _nodeOperatorId\n    ) private view returns (NodeOperatorData memory _nodeOperatorData) {\n        (\n            bool active,\n            ,\n            address rewardAddress,\n            uint64 stakingLimit,\n            ,\n            uint64 totalSigningKeys,\n\n        ) = nodeOperatorsRegistry.getNodeOperator(_nodeOperatorId, false);\n\n        _nodeOperatorData.id = _nodeOperatorId;\n        _nodeOperatorData.active = active;\n        _nodeOperatorData.rewardAddress = rewardAddress;\n        _nodeOperatorData.stakingLimit = stakingLimit;\n        _nodeOperatorData.totalSigningKeys = totalSigningKeys;\n    }\n}\n"
    },
    "EVMScriptCreator.sol": {
      "content": "// SPDX-FileCopyrightText: 2021 Lido <info@lido.fi>\n// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.4;\n\n/// @author psirex\n/// @notice Contains methods for convenient creation\n/// of EVMScripts in EVMScript factories contracts\nlibrary EVMScriptCreator {\n    // Id of default CallsScript Aragon's executor.\n    bytes4 private constant SPEC_ID = hex\"00000001\";\n\n    /// @notice Encodes one method call as EVMScript\n    function createEVMScript(\n        address _to,\n        bytes4 _methodId,\n        bytes memory _evmScriptCallData\n    ) internal pure returns (bytes memory _commands) {\n        return\n            abi.encodePacked(\n                SPEC_ID,\n                _to,\n                uint32(_evmScriptCallData.length) + 4,\n                _methodId,\n                _evmScriptCallData\n            );\n    }\n\n    /// @notice Encodes multiple calls of the same method on one contract as EVMScript\n    function createEVMScript(\n        address _to,\n        bytes4 _methodId,\n        bytes[] memory _evmScriptCallData\n    ) internal pure returns (bytes memory _evmScript) {\n        for (uint256 i = 0; i < _evmScriptCallData.length; ++i) {\n            _evmScript = bytes.concat(\n                _evmScript,\n                abi.encodePacked(\n                    _to,\n                    uint32(_evmScriptCallData[i].length) + 4,\n                    _methodId,\n                    _evmScriptCallData[i]\n                )\n            );\n        }\n        _evmScript = bytes.concat(SPEC_ID, _evmScript);\n    }\n\n    /// @notice Encodes multiple calls to different methods within the same contract as EVMScript\n    function createEVMScript(\n        address _to,\n        bytes4[] memory _methodIds,\n        bytes[] memory _evmScriptCallData\n    ) internal pure returns (bytes memory _evmScript) {\n        require(_methodIds.length == _evmScriptCallData.length, \"LENGTH_MISMATCH\");\n\n        for (uint256 i = 0; i < _methodIds.length; ++i) {\n            _evmScript = bytes.concat(\n                _evmScript,\n                abi.encodePacked(\n                    _to,\n                    uint32(_evmScriptCallData[i].length) + 4,\n                    _methodIds[i],\n                    _evmScriptCallData[i]\n                )\n            );\n        }\n        _evmScript = bytes.concat(SPEC_ID, _evmScript);\n    }\n\n    /// @notice Encodes multiple calls to different contracts as EVMScript\n    function createEVMScript(\n        address[] memory _to,\n        bytes4[] memory _methodIds,\n        bytes[] memory _evmScriptCallData\n    ) internal pure returns (bytes memory _evmScript) {\n        require(_to.length == _methodIds.length, \"LENGTH_MISMATCH\");\n        require(_to.length == _evmScriptCallData.length, \"LENGTH_MISMATCH\");\n\n        for (uint256 i = 0; i < _to.length; ++i) {\n            _evmScript = bytes.concat(\n                _evmScript,\n                abi.encodePacked(\n                    _to[i],\n                    uint32(_evmScriptCallData[i].length) + 4,\n                    _methodIds[i],\n                    _evmScriptCallData[i]\n                )\n            );\n        }\n        _evmScript = bytes.concat(SPEC_ID, _evmScript);\n    }\n}\n"
    },
    "IEVMScriptFactory.sol": {
      "content": "// SPDX-FileCopyrightText: 2021 Lido <info@lido.fi>\n// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.4;\n\n/// @author psirex\n/// @notice Interface which every EVMScript factory used in EasyTrack contract has to implement\ninterface IEVMScriptFactory {\n    function createEVMScript(address _creator, bytes memory _evmScriptCallData)\n        external\n        returns (bytes memory);\n}\n"
    },
    "INodeOperatorsRegistry.sol": {
      "content": "// SPDX-FileCopyrightText: 2023 Lido <info@lido.fi>\n// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.4;\n\n/// @author bulbozaur\ninterface INodeOperatorsRegistry {\n    function activateNodeOperator(uint256 _nodeOperatorId) external;\n\n    function deactivateNodeOperator(uint256 _nodeOperatorId) external;\n\n    function getNodeOperatorIsActive(uint256 _nodeOperatorId) external view returns (bool);\n\n    function getNodeOperatorsCount() external view returns (uint256);\n\n    function addNodeOperator(\n        string memory _name,\n        address _rewardAddress\n    ) external returns (uint256 id);\n\n    function MAX_NODE_OPERATOR_NAME_LENGTH() external view returns (uint256);\n\n    function MAX_NODE_OPERATORS_COUNT() external view returns (uint256);\n\n    function setNodeOperatorRewardAddress(uint256 _nodeOperatorId, address _rewardAddress) external;\n\n    function setNodeOperatorName(uint256 _nodeOperatorId, string memory _name) external;\n\n    function getNodeOperator(\n        uint256 _id,\n        bool _fullInfo\n    )\n        external\n        view\n        returns (\n            bool active,\n            string memory name,\n            address rewardAddress,\n            uint64 stakingLimit,\n            uint64 stoppedValidators,\n            uint64 totalSigningKeys,\n            uint64 usedSigningKeys\n        );\n\n    function canPerform(\n        address _sender,\n        bytes32 _role,\n        uint256[] memory _params\n    ) external view returns (bool);\n\n    function setNodeOperatorStakingLimit(uint256 _id, uint64 _stakingLimit) external;\n\n    function updateTargetValidatorsLimits(\n        uint256 _nodeOperatorId,\n        bool _isTargetLimitActive,\n        uint256 _targetLimit\n    ) external;\n}\n"
    }
  },
  "settings": {
    "evmVersion": "istanbul",
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "libraries": {
      "IncreaseVettedValidatorsLimit.sol": {}
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}