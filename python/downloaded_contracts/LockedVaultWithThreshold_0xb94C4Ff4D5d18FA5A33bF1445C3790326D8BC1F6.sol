{{
  "language": "Solidity",
  "sources": {
    "LockedVaultWithThreshold.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport \"LockedVault.sol\";\nimport \"VaultWithThreshold.sol\";\n\ncontract LockedVaultWithThreshold is LockedVault, VaultWithThreshold {\n    constructor(\n        address _owner,\n        address _underlying,\n        address _rewardsToken,\n        address _daoTreasury\n    ) LockedVault(_owner, _underlying, _rewardsToken, _daoTreasury) {}\n\n    function initialize(\n        uint256 _threshold,\n        uint256 _withdrawalWaitDuration\n    ) external initializer {\n        __LockedVault_initialize(_withdrawalWaitDuration);\n        threshold = _threshold;\n    }\n\n    function getTotalRawVotingPower()\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        if (totalSupply < threshold) {\n            return threshold;\n        }\n        return totalSupply;\n    }\n}\n"
    },
    "LockedVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\nimport \"IERC20Metadata.sol\";\nimport \"Initializable.sol\";\nimport \"EnumerableSet.sol\";\n\nimport \"ILockingVault.sol\";\n\nimport \"DataTypes.sol\";\nimport \"ScaledMath.sol\";\nimport \"VotingPowerHistory.sol\";\n\nimport \"ImmutableOwner.sol\";\nimport \"LiquidityMining.sol\";\nimport \"BaseDelegatingVault.sol\";\n\ncontract LockedVault is\n    Initializable,\n    BaseDelegatingVault,\n    ILockingVault,\n    ImmutableOwner,\n    LiquidityMining\n{\n    using ScaledMath for uint256;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using VotingPowerHistory for VotingPowerHistory.History;\n\n    string internal constant _VAULT_TYPE = \"LockedVault\";\n\n    IERC20 public immutable underlying;\n    uint256 internal withdrawalWaitDuration;\n\n    // Mapping of a user's address to their pending withdrawal ids.\n    mapping(address => EnumerableSet.UintSet) internal userPendingWithdrawalIds;\n\n    mapping(uint256 => DataTypes.PendingWithdrawal) internal pendingWithdrawals;\n\n    uint256 internal nextWithdrawalId;\n\n    // Total supply of shares locked in the vault that are not queued for withdrawal\n    uint256 public totalSupply;\n\n    uint8 internal immutable _underlyingDecimals;\n\n    constructor(\n        address _owner,\n        address _underlying,\n        address _rewardsToken,\n        address _daoTreasury\n    ) ImmutableOwner(_owner) LiquidityMining(_rewardsToken, _daoTreasury) {\n        underlying = IERC20(_underlying);\n        _underlyingDecimals = IERC20Metadata(_underlying).decimals();\n    }\n\n    function initialize(\n        uint256 _withdrawalWaitDuration\n    ) external virtual initializer {\n        __LockedVault_initialize(_withdrawalWaitDuration);\n    }\n\n    function startMining(\n        address rewardsFrom,\n        uint256 amount,\n        uint256 endTime\n    ) external override onlyOwner {\n        _startMining(rewardsFrom, amount, endTime);\n    }\n\n    function stopMining() external override onlyOwner {\n        _stopMining();\n    }\n\n    function setWithdrawalWaitDuration(uint256 _duration) external onlyOwner {\n        withdrawalWaitDuration = _duration;\n    }\n\n    function deposit(uint256 _amount) external {\n        deposit(_amount, msg.sender);\n    }\n\n    function deposit(uint256 _tokenAmount, address _delegate) public {\n        require(_delegate != address(0), \"no delegation to 0\");\n        require(_tokenAmount > 0, \"cannot deposit zero amount\");\n\n        underlying.transferFrom(msg.sender, address(this), _tokenAmount);\n\n        VotingPowerHistory.Record memory current = history.currentRecord(\n            msg.sender\n        );\n\n        // internal accounting is done with 18 decimals\n        uint256 scaledAmount = _tokenAmount.changeScale(\n            _underlyingDecimals,\n            18\n        );\n        history.updateVotingPower(\n            msg.sender,\n            current.baseVotingPower + scaledAmount,\n            current.multiplier,\n            current.netDelegatedVotes\n        );\n        if (_delegate != address(0) && _delegate != msg.sender) {\n            _delegateVote(msg.sender, _delegate, scaledAmount);\n        }\n        totalSupply += scaledAmount;\n        _stake(msg.sender, scaledAmount);\n\n        emit Deposit(msg.sender, _delegate, _tokenAmount);\n    }\n\n    function initiateWithdrawal(\n        uint256 _vaultTokenAmount,\n        address _delegate\n    ) external returns (uint256) {\n        require(_vaultTokenAmount >= 0, \"invalid withdrawal amount\");\n\n        VotingPowerHistory.Record memory currentVotingPower = history\n            .currentRecord(msg.sender);\n\n        bool undelegating = _delegate != address(0) && _delegate != msg.sender;\n\n        // NOTE: voting power in locked vault always has a multiplier of 1e18 (default on initialization) and is never updated\n        // therefore, we do not need to worry about it in the calculation of the condition below\n        require(\n            currentVotingPower.baseVotingPower >= _vaultTokenAmount &&\n                (undelegating ||\n                    currentVotingPower.baseVotingPower -\n                        history.delegatedVotingPower(msg.sender) >=\n                    _vaultTokenAmount),\n            \"not enough to undelegate\"\n        );\n        history.updateVotingPower(\n            msg.sender,\n            currentVotingPower.baseVotingPower - _vaultTokenAmount,\n            currentVotingPower.multiplier,\n            currentVotingPower.netDelegatedVotes\n        );\n        if (undelegating) {\n            _undelegateVote(msg.sender, _delegate, _vaultTokenAmount);\n        }\n        totalSupply -= _vaultTokenAmount;\n        _unstake(msg.sender, _vaultTokenAmount);\n\n        DataTypes.PendingWithdrawal memory withdrawal = DataTypes\n            .PendingWithdrawal({\n                id: nextWithdrawalId,\n                withdrawableAt: block.timestamp + withdrawalWaitDuration,\n                amount: _vaultTokenAmount,\n                to: msg.sender,\n                delegate: _delegate\n            });\n        pendingWithdrawals[withdrawal.id] = withdrawal;\n        userPendingWithdrawalIds[msg.sender].add(withdrawal.id);\n        nextWithdrawalId++;\n\n        emit WithdrawalQueued(\n            withdrawal.id,\n            withdrawal.to,\n            withdrawal.delegate,\n            withdrawal.withdrawableAt,\n            withdrawal.amount\n        );\n\n        return withdrawal.id;\n    }\n\n    function withdraw(uint256 withdrawalId) external {\n        DataTypes.PendingWithdrawal memory pending = pendingWithdrawals[\n            withdrawalId\n        ];\n        require(pending.to == msg.sender, \"matching withdrawal does not exist\");\n        require(\n            pending.withdrawableAt <= block.timestamp,\n            \"no valid pending withdrawal\"\n        );\n\n        uint256 underlyingTokenAmount = pending.amount.changeScale(\n            18,\n            _underlyingDecimals\n        );\n\n        underlying.transfer(pending.to, underlyingTokenAmount);\n\n        delete pendingWithdrawals[withdrawalId];\n        userPendingWithdrawalIds[pending.to].remove(withdrawalId);\n\n        emit WithdrawalCompleted(withdrawalId, pending.to, pending.amount);\n    }\n\n    function getRawVotingPower(\n        address _user,\n        uint256 timestamp\n    ) public view override returns (uint256) {\n        return history.getVotingPower(_user, timestamp);\n    }\n\n    function getTotalRawVotingPower()\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return totalSupply;\n    }\n\n    function listPendingWithdrawals(\n        address _user\n    ) external view returns (DataTypes.PendingWithdrawal[] memory) {\n        EnumerableSet.UintSet storage ids = userPendingWithdrawalIds[_user];\n        DataTypes.PendingWithdrawal[]\n            memory pending = new DataTypes.PendingWithdrawal[](ids.length());\n        for (uint256 i = 0; i < ids.length(); i++) {\n            pending[i] = pendingWithdrawals[ids.at(i)];\n        }\n        return pending;\n    }\n\n    function getVaultType() external pure returns (string memory) {\n        return _VAULT_TYPE;\n    }\n\n    function __LockedVault_initialize(\n        uint256 _withdrawalWaitDuration\n    ) internal {\n        withdrawalWaitDuration = _withdrawalWaitDuration;\n        globalCheckpoint();\n    }\n}\n"
    },
    "IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Internal function that returns the initialized version. Returns `_initialized`\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Internal function that returns the initialized version. Returns `_initializing`\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "ILockingVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\nimport \"IERC20.sol\";\n\ninterface ILockingVault {\n    function underlying() external view returns (IERC20);\n\n    function deposit(uint256 _amount) external;\n\n    function deposit(uint256 _amount, address _delegate) external;\n\n    event Deposit(\n        address indexed from,\n        address indexed delegate,\n        uint256 amount\n    );\n\n    function initiateWithdrawal(\n        uint256 _amount,\n        address _delegate\n    ) external returns (uint256);\n\n    function withdraw(uint256 withdrawalId) external;\n\n    event WithdrawalQueued(\n        uint256 indexed id,\n        address indexed to,\n        address indexed delegate,\n        uint256 withdrawalAt,\n        uint256 amount\n    );\n    event WithdrawalCompleted(\n        uint256 indexed id,\n        address indexed to,\n        uint256 amount\n    );\n}\n"
    },
    "DataTypes.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\nimport \"EnumerableMap.sol\";\n\nlibrary DataTypes {\n    enum Status {\n        Undefined,\n        Active,\n        Rejected,\n        Queued,\n        Executed,\n        Vetoed\n    }\n\n    struct ProposalAction {\n        address target;\n        bytes data;\n    }\n\n    struct Proposal {\n        uint64 createdAt;\n        uint64 executableAt;\n        uint64 votingEndsAt;\n        uint64 voteThreshold;\n        uint64 quorum;\n        uint16 id;\n        uint8 actionLevel;\n        address proposer;\n        Status status;\n        ProposalAction[] actions;\n    }\n\n    struct PendingWithdrawal {\n        uint256 id;\n        uint256 withdrawableAt;\n        uint256 amount;\n        address to;\n        address delegate;\n    }\n\n    struct VaultWeightSchedule {\n        VaultWeightConfiguration[] vaults;\n        uint256 startsAt;\n        uint256 endsAt;\n    }\n\n    struct VaultWeightConfiguration {\n        address vaultAddress;\n        uint256 initialWeight;\n        uint256 targetWeight;\n    }\n\n    struct VaultWeight {\n        address vaultAddress;\n        uint256 currentWeight;\n        uint256 initialWeight;\n        uint256 targetWeight;\n    }\n\n    struct VaultVotingPower {\n        address vaultAddress;\n        uint256 votingPower;\n    }\n\n    struct Tier {\n        uint64 quorum;\n        uint64 proposalThreshold;\n        uint64 voteThreshold;\n        uint32 timeLockDuration;\n        uint32 proposalLength;\n        uint8 actionLevel;\n    }\n\n    struct EmergencyRecoveryProposal {\n        uint64 createdAt;\n        uint64 completesAt;\n        Status status;\n        bytes payload;\n        EnumerableMap.AddressToUintMap vetos;\n    }\n\n    enum Ballot {\n        Undefined,\n        For,\n        Against,\n        Abstain\n    }\n\n    struct VoteTotals {\n        VaultVotingPower[] _for;\n        VaultVotingPower[] against;\n        VaultVotingPower[] abstentions;\n    }\n\n    struct VaultSnapshot {\n        address vaultAddress;\n        uint256 weight;\n        uint256 totalVotingPower;\n    }\n\n    enum ProposalOutcome {\n        Undefined,\n        QuorumNotMet,\n        ThresholdNotMet,\n        Successful\n    }\n\n    struct LimitUpgradeabilityParameters {\n        uint8 actionLevelThreshold;\n        uint256 emaThreshold;\n        uint256 minBGYDSupply;\n        address tierStrategy;\n    }\n\n    struct Delegation {\n        address delegate;\n        uint256 amount;\n    }\n}\n"
    },
    "EnumerableMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableMap.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableMap.js.\n\npragma solidity ^0.8.0;\n\nimport \"EnumerableSet.sol\";\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * The following map types are supported:\n *\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32Map`) since v4.6.0\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableMap.\n * ====\n */\nlibrary EnumerableMap {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct Bytes32ToBytes32Map {\n        // Storage of keys\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 => bytes32) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        Bytes32ToBytes32Map storage map,\n        bytes32 key,\n        bytes32 value\n    ) internal returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\n        bytes32 key = map._keys.at(index);\n        return (key, map._values[key]);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\n        bytes32 value = map._values[key];\n        if (value == bytes32(0)) {\n            return (contains(map, key), bytes32(0));\n        } else {\n            return (true, value);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || contains(map, key), \"EnumerableMap: nonexistent key\");\n        return value;\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        Bytes32ToBytes32Map storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) internal view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || contains(map, key), errorMessage);\n        return value;\n    }\n\n    // UintToUintMap\n\n    struct UintToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        UintToUintMap storage map,\n        uint256 key,\n        uint256 value\n    ) internal returns (bool) {\n        return set(map._inner, bytes32(key), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (uint256(key), uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(key)));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        UintToUintMap storage map,\n        uint256 key,\n        string memory errorMessage\n    ) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(key), errorMessage));\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        UintToAddressMap storage map,\n        uint256 key,\n        address value\n    ) internal returns (bool) {\n        return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        UintToAddressMap storage map,\n        uint256 key,\n        string memory errorMessage\n    ) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, bytes32(key), errorMessage))));\n    }\n\n    // AddressToUintMap\n\n    struct AddressToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        AddressToUintMap storage map,\n        address key,\n        uint256 value\n    ) internal returns (bool) {\n        return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(AddressToUintMap storage map, address key) internal returns (bool) {\n        return remove(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\n        return contains(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(AddressToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (address(uint160(uint256(key))), uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        AddressToUintMap storage map,\n        address key,\n        string memory errorMessage\n    ) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(uint256(uint160(key))), errorMessage));\n    }\n\n    // Bytes32ToUintMap\n\n    struct Bytes32ToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        Bytes32ToUintMap storage map,\n        bytes32 key,\n        uint256 value\n    ) internal returns (bool) {\n        return set(map._inner, key, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\n        return remove(map._inner, key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\n        return contains(map._inner, key);\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (key, uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, key);\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\n        return uint256(get(map._inner, key));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        Bytes32ToUintMap storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) internal view returns (uint256) {\n        return uint256(get(map._inner, key, errorMessage));\n    }\n}\n"
    },
    "ScaledMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\nlibrary ScaledMath {\n    uint256 internal constant ONE = 1e18;\n\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a * b) / ONE;\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a * ONE) / b;\n    }\n\n    function changeScale(\n        uint256 a,\n        uint256 from,\n        uint256 to\n    ) internal pure returns (uint256) {\n        if (from == to) return a;\n        else if (from < to) return a * 10 ** (to - from);\n        else return a / 10 ** (from - to);\n    }\n}\n"
    },
    "VotingPowerHistory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\nimport \"ScaledMath.sol\";\n\nlibrary VotingPowerHistory {\n    using VotingPowerHistory for History;\n    using VotingPowerHistory for Record;\n    using ScaledMath for uint256;\n\n    struct Record {\n        uint256 at;\n        uint256 baseVotingPower;\n        uint256 multiplier;\n        int256 netDelegatedVotes;\n    }\n\n    function zeroRecord() internal pure returns (Record memory) {\n        return\n            Record({\n                at: 0,\n                baseVotingPower: 0,\n                multiplier: ScaledMath.ONE,\n                netDelegatedVotes: 0\n            });\n    }\n\n    function total(Record memory record) internal pure returns (uint256) {\n        return\n            uint256(\n                int256(record.baseVotingPower.mulDown(record.multiplier)) +\n                    record.netDelegatedVotes\n            );\n    }\n\n    struct History {\n        mapping(address => Record[]) votes;\n        mapping(address => mapping(address => uint256)) _delegations;\n        mapping(address => uint256) _delegatedToOthers;\n        mapping(address => uint256) _delegatedToSelf;\n    }\n\n    event VotesDelegated(address from, address to, uint256 amount);\n    event VotesUndelegated(address from, address to, uint256 amount);\n\n    function updateVotingPower(\n        History storage history,\n        address for_,\n        uint256 baseVotingPower,\n        uint256 multiplier,\n        int256 netDelegatedVotes\n    ) internal returns (Record memory) {\n        Record[] storage votesFor = history.votes[for_];\n        Record memory updatedRecord = Record({\n            at: block.timestamp,\n            baseVotingPower: baseVotingPower,\n            multiplier: multiplier,\n            netDelegatedVotes: netDelegatedVotes\n        });\n        Record memory lastRecord = history.currentRecord(for_);\n        if (lastRecord.at == block.timestamp && votesFor.length > 0) {\n            votesFor[votesFor.length - 1] = updatedRecord;\n        } else {\n            history.votes[for_].push(updatedRecord);\n        }\n        return updatedRecord;\n    }\n\n    function getVotingPower(\n        History storage history,\n        address for_,\n        uint256 at\n    ) internal view returns (uint256) {\n        (, Record memory record) = binarySearch(history.votes[for_], at);\n        return record.total();\n    }\n\n    function currentRecord(\n        History storage history,\n        address for_\n    ) internal view returns (Record memory) {\n        Record[] memory records = history.votes[for_];\n        if (records.length == 0) {\n            return zeroRecord();\n        } else {\n            return records[records.length - 1];\n        }\n    }\n\n    function binarySearch(\n        Record[] memory records,\n        uint256 at\n    ) internal view returns (bool found, Record memory) {\n        return _binarySearch(records, at, 0, records.length);\n    }\n\n    function _binarySearch(\n        Record[] memory records,\n        uint256 at,\n        uint256 startIdx,\n        uint256 endIdx\n    ) internal view returns (bool found, Record memory) {\n        if (startIdx >= endIdx) {\n            return (false, zeroRecord());\n        }\n\n        if (endIdx - startIdx == 1) {\n            Record memory rec = records[startIdx];\n            return rec.at <= at ? (true, rec) : (false, zeroRecord());\n        }\n\n        uint256 midIdx = (endIdx + startIdx) / 2;\n        Record memory lowerBound = records[midIdx - 1];\n        Record memory upperBound = records[midIdx];\n        if (lowerBound.at <= at && at < upperBound.at) {\n            return (true, lowerBound);\n        } else if (upperBound.at <= at) {\n            return _binarySearch(records, at, midIdx, endIdx);\n        } else {\n            return _binarySearch(records, at, startIdx, midIdx);\n        }\n    }\n\n    function delegateVote(\n        History storage history,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        Record memory fromCurrent = history.currentRecord(from);\n\n        uint256 availableToDelegate = fromCurrent.baseVotingPower.mulDown(\n            fromCurrent.multiplier\n        ) - history._delegatedToOthers[from];\n        require(\n            availableToDelegate >= amount,\n            \"insufficient balance to delegate\"\n        );\n\n        history._delegatedToSelf[to] += amount;\n        history._delegatedToOthers[from] += amount;\n        history._delegations[from][to] += amount;\n\n        history.updateVotingPower(\n            from,\n            fromCurrent.baseVotingPower,\n            fromCurrent.multiplier,\n            history.netDelegatedVotingPower(from)\n        );\n        Record memory toCurrent = history.currentRecord(to);\n        history.updateVotingPower(\n            to,\n            toCurrent.baseVotingPower,\n            toCurrent.multiplier,\n            history.netDelegatedVotingPower(to)\n        );\n\n        emit VotesDelegated(from, to, amount);\n    }\n\n    function undelegateVote(\n        History storage history,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        require(\n            history._delegations[from][to] >= amount,\n            \"user has not delegated enough to delegate\"\n        );\n\n        history._delegatedToSelf[to] -= amount;\n        history._delegatedToOthers[from] -= amount;\n        history._delegations[from][to] -= amount;\n\n        Record memory fromCurrent = history.currentRecord(from);\n        history.updateVotingPower(\n            from,\n            fromCurrent.baseVotingPower,\n            fromCurrent.multiplier,\n            history.netDelegatedVotingPower(from)\n        );\n        Record memory toCurrent = history.currentRecord(to);\n        history.updateVotingPower(\n            to,\n            toCurrent.baseVotingPower,\n            toCurrent.multiplier,\n            history.netDelegatedVotingPower(to)\n        );\n\n        emit VotesUndelegated(from, to, amount);\n    }\n\n    function netDelegatedVotingPower(\n        History storage history,\n        address who\n    ) internal view returns (int256) {\n        return\n            int256(history._delegatedToSelf[who]) -\n            int256(history._delegatedToOthers[who]);\n    }\n\n    function delegatedVotingPower(\n        History storage history,\n        address who\n    ) internal view returns (uint256) {\n        return history._delegatedToOthers[who];\n    }\n\n    function updateMultiplier(\n        History storage history,\n        address who,\n        uint256 multiplier\n    ) internal {\n        Record memory current = history.currentRecord(who);\n        require(current.multiplier <= multiplier, \"cannot decrease multiplier\");\n        history.updateVotingPower(\n            who,\n            current.baseVotingPower,\n            multiplier,\n            current.netDelegatedVotes\n        );\n    }\n}\n"
    },
    "ImmutableOwner.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\nimport \"Errors.sol\";\n\ncontract ImmutableOwner {\n    address public immutable owner;\n\n    modifier onlyOwner() {\n        if (msg.sender != owner) revert Errors.NotAuthorized(msg.sender, owner);\n        _;\n    }\n\n    constructor(address _owner) {\n        owner = _owner;\n    }\n}\n"
    },
    "Errors.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\nlibrary Errors {\n    error DuplicatedVault(address vault);\n    error InvalidTotalWeight(uint256 totalWeight);\n    error NotAuthorized(address actual, address expected);\n    error InvalidVotingPowerUpdate(\n        uint256 actualTotalPower,\n        uint256 givenTotalPower\n    );\n    error MultisigSunset();\n\n    error ZeroDivision();\n}\n"
    },
    "LiquidityMining.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\nimport \"ILiquidityMining.sol\";\nimport \"FixedPoint.sol\";\n\nimport \"IERC20.sol\";\nimport \"SafeERC20.sol\";\n\n/// @dev Base contract for liquidity mining.\n/// `startMining` and `stopMining` would typically be implemented by the subcontract to perform\n/// its own authorization and then call the underscore versions\nabstract contract LiquidityMining is ILiquidityMining {\n    using FixedPoint for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 public override totalStaked;\n\n    uint256 internal _totalStakedIntegral;\n    uint256 internal _lastCheckpointTime;\n    /// @dev This contract only tracks these, we don't use it; but it may be convenient for inheriting contracts.\n    uint256 internal _totalUnclaimedRewards;\n    mapping(address => uint256) internal _perUserStakedIntegral;\n    mapping(address => uint256) internal _perUserShare;\n    mapping(address => uint256) internal _perUserStaked;\n\n    uint256 internal _rewardsEmissionRate;\n    uint256 public override rewardsEmissionEndTime;\n\n    IERC20 public immutable rewardToken;\n    address public immutable daoTreasury;\n\n    constructor(address _rewardToken, address _daoTreasury) {\n        _lastCheckpointTime = block.timestamp;\n        rewardToken = IERC20(_rewardToken);\n        daoTreasury = _daoTreasury;\n    }\n\n    function claimRewards() external returns (uint256) {\n        userCheckpoint(msg.sender);\n        uint256 amount = _perUserShare[msg.sender];\n        if (amount == 0) return 0;\n        delete _perUserShare[msg.sender];\n        emit Claim(msg.sender, amount);\n        _totalUnclaimedRewards -= amount;\n        return _mintRewards(msg.sender, amount);\n    }\n\n    function claimableRewards(\n        address beneficiary\n    ) external view virtual returns (uint256) {\n        uint256 totalStakedIntegral = _totalStakedIntegral;\n        if (totalStaked > 0) {\n            totalStakedIntegral += (rewardsEmissionRate() *\n                (block.timestamp - _lastCheckpointTime)).divDown(totalStaked);\n        }\n\n        return\n            _perUserShare[beneficiary] +\n            stakedBalanceOf(beneficiary).mulDown(\n                totalStakedIntegral - _perUserStakedIntegral[beneficiary]\n            );\n    }\n\n    function stakedBalanceOf(address account) public view returns (uint256) {\n        return _perUserStaked[account];\n    }\n\n    function globalCheckpoint() public {\n        uint256 totalStaked_ = totalStaked;\n        if (totalStaked_ > 0) {\n            uint256 elapsedTime = block.timestamp - _lastCheckpointTime;\n            uint256 newRewards = rewardsEmissionRate() * elapsedTime;\n            _totalStakedIntegral += newRewards.divDown(totalStaked_);\n            _totalUnclaimedRewards += newRewards;\n        }\n        _lastCheckpointTime = block.timestamp;\n    }\n\n    function userCheckpoint(address account) public virtual {\n        globalCheckpoint();\n        uint256 totalStakedIntegral = _totalStakedIntegral;\n        _perUserShare[account] += stakedBalanceOf(account).mulDown(\n            totalStakedIntegral - _perUserStakedIntegral[account]\n        );\n        _perUserStakedIntegral[account] = totalStakedIntegral;\n    }\n\n    /// @dev this is a helper function to be used by the inheriting contract\n    /// this does not perform any checks on the amount that `account` may or not have deposited\n    /// and should be used with caution. All checks should be performed in the inheriting contract\n    function _stake(address account, uint256 amount) internal {\n        userCheckpoint(account);\n        totalStaked += amount;\n        _perUserStaked[account] += amount;\n        emit Stake(account, amount);\n    }\n\n    /// @dev same as `_stake` but for unstaking\n    function _unstake(address account, uint256 amount) internal {\n        userCheckpoint(account);\n        _perUserStaked[account] -= amount;\n        totalStaked -= amount;\n        emit Unstake(account, amount);\n    }\n\n    /// @dev Helper function for the inheriting contract. Authorization should be performed by the inheriting contract.\n    function _startMining(\n        address rewardsFrom,\n        uint256 amount,\n        uint256 endTime\n    ) internal {\n        globalCheckpoint();\n        rewardToken.safeTransferFrom(rewardsFrom, address(this), amount);\n        _rewardsEmissionRate = amount / (endTime - block.timestamp);\n        rewardsEmissionEndTime = endTime;\n        emit StartMining(amount, endTime);\n    }\n\n    /// @dev same as `_startLiquidityMining` but for stopping.\n    function _stopMining() internal {\n        globalCheckpoint();\n        uint256 reimbursementAmount = rewardToken.balanceOf(address(this)) -\n            _totalUnclaimedRewards;\n        rewardToken.safeTransfer(daoTreasury, reimbursementAmount);\n        rewardsEmissionEndTime = 0;\n        emit StopMining();\n    }\n\n    function _mintRewards(\n        address beneficiary,\n        uint256 amount\n    ) internal virtual returns (uint256) {\n        rewardToken.safeTransfer(beneficiary, amount);\n        return amount;\n    }\n\n    function rewardsEmissionRate() public view override returns (uint256) {\n        return\n            block.timestamp <= rewardsEmissionEndTime\n                ? _rewardsEmissionRate\n                : 0;\n    }\n}\n"
    },
    "ILiquidityMining.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\ninterface ILiquidityMining {\n    event Stake(address indexed account, uint256 amount);\n    event Unstake(address indexed account, uint256 amount);\n    event Claim(address indexed beneficiary, uint256 amount);\n\n    event StartMining(uint256 amount, uint256 endTime);\n    event StopMining();\n\n    /// @notice claims rewards for caller\n    function claimRewards() external returns (uint256);\n\n    /// @notice returns the amount of claimable rewards by `beneficiary`\n    function claimableRewards(\n        address beneficiary\n    ) external view returns (uint256);\n\n    /// @notice the total amount of tokens staked in the contract\n    function totalStaked() external view returns (uint256);\n\n    /// @notice the amount of tokens staked by `account`\n    function stakedBalanceOf(address account) external view returns (uint256);\n\n    /// @notice returns the number of rewards token that will be given per second for the contract\n    /// This emission will be given to all stakers in the contract proportionally to their stake\n    function rewardsEmissionRate() external view returns (uint256);\n\n    /// @notice time when rewards emission ends\n    function rewardsEmissionEndTime() external view returns (uint256);\n\n    /// @dev these functions will be called internally but can typically be called by anyone\n    /// to update the internal tracking state of the contract\n    function globalCheckpoint() external;\n\n    function userCheckpoint(address account) external;\n\n    /// @notice Deposit `amount` of the reward token from `rewardsFrom` and enable rewards until `endTime`. Typically governanceOnly. `amount` is spread evenly over the time period.\n    function startMining(\n        address rewardsFrom,\n        uint256 amount,\n        uint256 endTime\n    ) external;\n\n    /// @notice Stop liquidity mining early and reimburse leftover rewards to the DAO treasury.\n    /// This may also be needed after the mining period has ended when we had `totalStaked() == 0` for a while, where no rewards accrue.\n    function stopMining() external;\n}\n"
    },
    "FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: LicenseRef-Gyro-1.0\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\n\npragma solidity ^0.8.4;\n\nimport \"LogExpMath.sol\";\nimport \"Errors.sol\";\n\n/* solhint-disable private-vars-leading-underscore */\n\nlibrary FixedPoint {\n    uint256 internal constant ONE = 1e18; // 18 decimal places\n    uint256 internal constant MAX_POW_RELATIVE_ERROR = 10000; // 10^(-14)\n\n    // Minimum base for the power function when the exponent is 'free' (larger than ONE).\n    uint256 internal constant MIN_POW_BASE_FREE_EXPONENT = 0.7e18;\n\n    function absSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a - b : b - a;\n    }\n\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 product = a * b;\n\n        return product / ONE;\n    }\n\n    function mulUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 product = a * b;\n\n        if (product == 0) {\n            return 0;\n        } else {\n            // The traditional divUp formula is:\n            // divUp(x, y) := (x + y - 1) / y\n            // To avoid intermediate overflow in the addition, we distribute the division and get:\n            // divUp(x, y) := (x - 1) / y + 1\n            // Note that this requires x != 0, which we already tested for.\n\n            return ((product - 1) / ONE) + 1;\n        }\n    }\n\n    function squareUp(uint256 a) internal pure returns (uint256) {\n        return mulUp(a, a);\n    }\n\n    function squareDown(uint256 a) internal pure returns (uint256) {\n        return mulDown(a, a);\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) revert Errors.ZeroDivision();\n\n        if (a == 0) {\n            return 0;\n        } else {\n            uint256 aInflated = a * ONE;\n\n            return aInflated / b;\n        }\n    }\n\n    function divUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) revert Errors.ZeroDivision();\n\n        if (a == 0) {\n            return 0;\n        } else {\n            uint256 aInflated = a * ONE;\n\n            // The traditional divUp formula is:\n            // divUp(x, y) := (x + y - 1) / y\n            // To avoid intermediate overflow in the addition, we distribute the division and get:\n            // divUp(x, y) := (x - 1) / y + 1\n            // Note that this requires x != 0, which we already tested for.\n\n            unchecked {\n                return ((aInflated - 1) / b) + 1;\n            }\n        }\n    }\n\n    /**\n     * @dev Returns x^y, assuming both are fixed point numbers, rounding down. The result is guaranteed to not be above\n     * the true value (that is, the error function expected - actual is always positive).\n     */\n    function powDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        uint256 raw = LogExpMath.pow(x, y);\n        uint256 maxError = mulUp(raw, MAX_POW_RELATIVE_ERROR) + 1;\n\n        if (raw < maxError) {\n            return 0;\n        } else {\n            return raw - maxError;\n        }\n    }\n\n    /**\n     * @dev Returns x^y, assuming both are fixed point numbers, rounding up. The result is guaranteed to not be below\n     * the true value (that is, the error function expected - actual is always negative).\n     */\n    function powUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        uint256 raw = LogExpMath.pow(x, y);\n        uint256 maxError = mulUp(raw, MAX_POW_RELATIVE_ERROR) + 1;\n\n        return raw + maxError;\n    }\n\n    /**\n     * @dev Returns the complement of a value (1 - x), capped to 0 if x is larger than 1.\n     *\n     * Useful when computing the complement for values with some level of relative error, as it strips this error and\n     * prevents intermediate negative values.\n     */\n    function complement(uint256 x) internal pure returns (uint256) {\n        return (x < ONE) ? (ONE - x) : 0;\n    }\n\n    /**\n     * @dev returns the minimum between x and y\n     */\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\n        return x < y ? x : y;\n    }\n\n    /**\n     * @dev returns the maximum between x and y\n     */\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\n        return x > y ? x : y;\n    }\n\n    /**\n     * @notice This is taken from the Balancer V1 code base.\n     * Computes a**b where a is a scaled fixed-point number and b is an integer\n     * The computation is performed in O(log n)\n     */\n    function intPowDown(\n        uint256 base,\n        uint256 exp\n    ) internal pure returns (uint256) {\n        uint256 result = FixedPoint.ONE;\n        while (exp > 0) {\n            if (exp % 2 == 1) {\n                result = mulDown(result, base);\n            }\n            exp /= 2;\n            base = mulDown(base, base);\n        }\n        return result;\n    }\n}\n"
    },
    "LogExpMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n// documentation files (the Software), to deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the\n// Software.\n\n// THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\n// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\npragma solidity ^0.8.17;\n// Copied from:\n// https://github.com/balancer-labs/balancer-v2-monorepo/blob/master/pkg/solidity-utils/contracts/math/LogExpMath.sol\n\nimport \"BalancerErrors.sol\";\n\n/* solhint-disable */\n\n/**\n * @dev Exponentiation and logarithm functions for 18 decimal fixed point numbers (both base and exponent/argument).\n *\n * Exponentiation and logarithm with arbitrary bases (x^y and log_x(y)) are implemented by conversion to natural\n * exponentiation and logarithm (where the base is Euler's number).\n *\n * @author Fernando Martinelli - @fernandomartinelli\n * @author Sergio Yuhjtman - @sergioyuhjtman\n * @author Daniel Fernandez - @dmf7z\n */\nlibrary LogExpMath {\n    // All fixed point multiplications and divisions are inlined. This means we need to divide by ONE when multiplying\n    // two numbers, and multiply by ONE when dividing them.\n\n    // All arguments and return values are 18 decimal fixed point numbers.\n    int256 constant ONE_18 = 1e18;\n\n    // Internally, intermediate values are computed with higher precision as 20 decimal fixed point numbers, and in the\n    // case of ln36, 36 decimals.\n    int256 constant ONE_20 = 1e20;\n    int256 constant ONE_36 = 1e36;\n\n    // The domain of natural exponentiation is bound by the word size and number of decimals used.\n    //\n    // Because internally the result will be stored using 20 decimals, the largest possible result is\n    // (2^255 - 1) / 10^20, which makes the largest exponent ln((2^255 - 1) / 10^20) = 130.700829182905140221.\n    // The smallest possible result is 10^(-18), which makes largest negative argument\n    // ln(10^(-18)) = -41.446531673892822312.\n    // We use 130.0 and -41.0 to have some safety margin.\n    int256 constant MAX_NATURAL_EXPONENT = 130e18;\n    int256 constant MIN_NATURAL_EXPONENT = -41e18;\n\n    // Bounds for ln_36's argument. Both ln(0.9) and ln(1.1) can be represented with 36 decimal places in a fixed point\n    // 256 bit integer.\n    int256 constant LN_36_LOWER_BOUND = ONE_18 - 1e17;\n    int256 constant LN_36_UPPER_BOUND = ONE_18 + 1e17;\n\n    uint256 constant MILD_EXPONENT_BOUND = 2 ** 254 / uint256(ONE_20);\n\n    // 18 decimal constants\n    int256 constant x0 = 128000000000000000000; // 27\n    int256 constant a0 =\n        38877084059945950922200000000000000000000000000000000000; // e(x0) (no decimals)\n    int256 constant x1 = 64000000000000000000; // 26\n    int256 constant a1 = 6235149080811616882910000000; // e(x1) (no decimals)\n\n    // 20 decimal constants\n    int256 constant x2 = 3200000000000000000000; // 25\n    int256 constant a2 = 7896296018268069516100000000000000; // e(x2)\n    int256 constant x3 = 1600000000000000000000; // 24\n    int256 constant a3 = 888611052050787263676000000; // e(x3)\n    int256 constant x4 = 800000000000000000000; // 23\n    int256 constant a4 = 298095798704172827474000; // e(x4)\n    int256 constant x5 = 400000000000000000000; // 22\n    int256 constant a5 = 5459815003314423907810; // e(x5)\n    int256 constant x6 = 200000000000000000000; // 21\n    int256 constant a6 = 738905609893065022723; // e(x6)\n    int256 constant x7 = 100000000000000000000; // 20\n    int256 constant a7 = 271828182845904523536; // e(x7)\n    int256 constant x8 = 50000000000000000000; // 2-1\n    int256 constant a8 = 164872127070012814685; // e(x8)\n    int256 constant x9 = 25000000000000000000; // 2-2\n    int256 constant a9 = 128402541668774148407; // e(x9)\n    int256 constant x10 = 12500000000000000000; // 2-3\n    int256 constant a10 = 113314845306682631683; // e(x10)\n    int256 constant x11 = 6250000000000000000; // 2-4\n    int256 constant a11 = 106449445891785942956; // e(x11)\n\n    /**\n     * @dev Exponentiation (x^y) with unsigned 18 decimal fixed point base and exponent.\n     *\n     * Reverts if ln(x) * y is smaller than `MIN_NATURAL_EXPONENT`, or larger than `MAX_NATURAL_EXPONENT`.\n     */\n    function pow(uint256 x, uint256 y) internal pure returns (uint256) {\n        unchecked {\n            if (y == 0) {\n                // We solve the 0^0 indetermination by making it equal one.\n                return uint256(ONE_18);\n            }\n\n            if (x == 0) {\n                return 0;\n            }\n\n            // Instead of computing x^y directly, we instead rely on the properties of logarithms and exponentiation to\n            // arrive at that result. In particular, exp(ln(x)) = x, and ln(x^y) = y * ln(x). This means\n            // x^y = exp(y * ln(x)).\n\n            // The ln function takes a signed value, so we need to make sure x fits in the signed 256 bit range.\n            require(x < 2 ** 255, BalancerErrors.X_OUT_OF_BOUNDS);\n            int256 x_int256 = int256(x);\n\n            // We will compute y * ln(x) in a single step. Depending on the value of x, we can either use ln or ln_36. In\n            // both cases, we leave the division by ONE_18 (due to fixed point multiplication) to the end.\n\n            // This prevents y * ln(x) from overflowing, and at the same time guarantees y fits in the signed 256 bit range.\n            require(y < MILD_EXPONENT_BOUND, BalancerErrors.Y_OUT_OF_BOUNDS);\n            int256 y_int256 = int256(y);\n\n            int256 logx_times_y;\n            if (LN_36_LOWER_BOUND < x_int256 && x_int256 < LN_36_UPPER_BOUND) {\n                int256 ln_36_x = _ln_36(x_int256);\n\n                // ln_36_x has 36 decimal places, so multiplying by y_int256 isn't as straightforward, since we can't just\n                // bring y_int256 to 36 decimal places, as it might overflow. Instead, we perform two 18 decimal\n                // multiplications and add the results: one with the first 18 decimals of ln_36_x, and one with the\n                // (downscaled) last 18 decimals.\n                logx_times_y = ((ln_36_x / ONE_18) *\n                    y_int256 +\n                    ((ln_36_x % ONE_18) * y_int256) /\n                    ONE_18);\n            } else {\n                logx_times_y = _ln(x_int256) * y_int256;\n            }\n            logx_times_y /= ONE_18;\n\n            // Finally, we compute exp(y * ln(x)) to arrive at x^y\n            require(\n                MIN_NATURAL_EXPONENT <= logx_times_y &&\n                    logx_times_y <= MAX_NATURAL_EXPONENT,\n                BalancerErrors.PRODUCT_OUT_OF_BOUNDS\n            );\n\n            return uint256(exp(logx_times_y));\n        }\n    }\n\n    /**\n     * @dev Natural exponentiation (e^x) with signed 18 decimal fixed point exponent.\n     *\n     * Reverts if `x` is smaller than MIN_NATURAL_EXPONENT, or larger than `MAX_NATURAL_EXPONENT`.\n     */\n    function exp(int256 x) internal pure returns (int256) {\n        require(\n            x >= MIN_NATURAL_EXPONENT && x <= MAX_NATURAL_EXPONENT,\n            BalancerErrors.INVALID_EXPONENT\n        );\n        unchecked {\n            if (x < 0) {\n                // We only handle positive exponents: e^(-x) is computed as 1 / e^x. We can safely make x positive since it\n                // fits in the signed 256 bit range (as it is larger than MIN_NATURAL_EXPONENT).\n                // Fixed point division requires multiplying by ONE_18.\n                return ((ONE_18 * ONE_18) / exp(-x));\n            }\n\n            // First, we use the fact that e^(x+y) = e^x * e^y to decompose x into a sum of powers of two, which we call x_n,\n            // where x_n == 2^(7 - n), and e^x_n = a_n has been precomputed. We choose the first x_n, x0, to equal 2^7\n            // because all larger powers are larger than MAX_NATURAL_EXPONENT, and therefore not present in the\n            // decomposition.\n            // At the end of this process we will have the product of all e^x_n = a_n that apply, and the remainder of this\n            // decomposition, which will be lower than the smallest x_n.\n            // exp(x) = k_0 * a_0 * k_1 * a_1 * ... + k_n * a_n * exp(remainder), where each k_n equals either 0 or 1.\n            // We mutate x by subtracting x_n, making it the remainder of the decomposition.\n\n            // The first two a_n (e^(2^7) and e^(2^6)) are too large if stored as 18 decimal numbers, and could cause\n            // intermediate overflows. Instead we store them as plain integers, with 0 decimals.\n            // Additionally, x0 + x1 is larger than MAX_NATURAL_EXPONENT, which means they will not both be present in the\n            // decomposition.\n\n            // For each x_n, we test if that term is present in the decomposition (if x is larger than it), and if so deduct\n            // it and compute the accumulated product.\n\n            int256 firstAN;\n            if (x >= x0) {\n                x -= x0;\n                firstAN = a0;\n            } else if (x >= x1) {\n                x -= x1;\n                firstAN = a1;\n            } else {\n                firstAN = 1; // One with no decimal places\n            }\n\n            // We now transform x into a 20 decimal fixed point number, to have enhanced precision when computing the\n            // smaller terms.\n            x *= 100;\n\n            // `product` is the accumulated product of all a_n (except a0 and a1), which starts at 20 decimal fixed point\n            // one. Recall that fixed point multiplication requires dividing by ONE_20.\n            int256 product = ONE_20;\n\n            if (x >= x2) {\n                x -= x2;\n                product = (product * a2) / ONE_20;\n            }\n            if (x >= x3) {\n                x -= x3;\n                product = (product * a3) / ONE_20;\n            }\n            if (x >= x4) {\n                x -= x4;\n                product = (product * a4) / ONE_20;\n            }\n            if (x >= x5) {\n                x -= x5;\n                product = (product * a5) / ONE_20;\n            }\n            if (x >= x6) {\n                x -= x6;\n                product = (product * a6) / ONE_20;\n            }\n            if (x >= x7) {\n                x -= x7;\n                product = (product * a7) / ONE_20;\n            }\n            if (x >= x8) {\n                x -= x8;\n                product = (product * a8) / ONE_20;\n            }\n            if (x >= x9) {\n                x -= x9;\n                product = (product * a9) / ONE_20;\n            }\n\n            // x10 and x11 are unnecessary here since we have high enough precision already.\n\n            // Now we need to compute e^x, where x is small (in particular, it is smaller than x9). We use the Taylor series\n            // expansion for e^x: 1 + x + (x^2 / 2!) + (x^3 / 3!) + ... + (x^n / n!).\n\n            int256 seriesSum = ONE_20; // The initial one in the sum, with 20 decimal places.\n            int256 term; // Each term in the sum, where the nth term is (x^n / n!).\n\n            // The first term is simply x.\n            term = x;\n            seriesSum += term;\n\n            // Each term (x^n / n!) equals the previous one times x, divided by n. Since x is a fixed point number,\n            // multiplying by it requires dividing by ONE_20, but dividing by the non-fixed point n values does not.\n\n            term = ((term * x) / ONE_20) / 2;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 3;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 4;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 5;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 6;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 7;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 8;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 9;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 10;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 11;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 12;\n            seriesSum += term;\n\n            // 12 Taylor terms are sufficient for 18 decimal precision.\n\n            // We now have the first a_n (with no decimals), and the product of all other a_n present, and the Taylor\n            // approximation of the exponentiation of the remainder (both with 20 decimals). All that remains is to multiply\n            // all three (one 20 decimal fixed point multiplication, dividing by ONE_20, and one integer multiplication),\n            // and then drop two digits to return an 18 decimal value.\n\n            return (((product * seriesSum) / ONE_20) * firstAN) / 100;\n        }\n    }\n\n    /**\n     * @dev Logarithm (log(arg, base), with signed 18 decimal fixed point base and argument.\n     */\n    function log(int256 arg, int256 base) internal pure returns (int256) {\n        unchecked {\n            // This performs a simple base change: log(arg, base) = ln(arg) / ln(base).\n\n            // Both logBase and logArg are computed as 36 decimal fixed point numbers, either by using ln_36, or by\n            // upscaling.\n\n            int256 logBase;\n            if (LN_36_LOWER_BOUND < base && base < LN_36_UPPER_BOUND) {\n                logBase = _ln_36(base);\n            } else {\n                logBase = _ln(base) * ONE_18;\n            }\n\n            int256 logArg;\n            if (LN_36_LOWER_BOUND < arg && arg < LN_36_UPPER_BOUND) {\n                logArg = _ln_36(arg);\n            } else {\n                logArg = _ln(arg) * ONE_18;\n            }\n\n            // When dividing, we multiply by ONE_18 to arrive at a result with 18 decimal places\n            return (logArg * ONE_18) / logBase;\n        }\n    }\n\n    /**\n     * @dev Natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\n     */\n    function ln(int256 a) internal pure returns (int256) {\n        unchecked {\n            // The real natural logarithm is not defined for negative numbers or zero.\n            require(a > 0, BalancerErrors.OUT_OF_BOUNDS);\n            if (LN_36_LOWER_BOUND < a && a < LN_36_UPPER_BOUND) {\n                return _ln_36(a) / ONE_18;\n            } else {\n                return _ln(a);\n            }\n        }\n    }\n\n    /**\n     * @dev Internal natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\n     */\n    function _ln(int256 a) private pure returns (int256) {\n        unchecked {\n            if (a < ONE_18) {\n                // Since ln(a^k) = k * ln(a), we can compute ln(a) as ln(a) = ln((1/a)^(-1)) = - ln((1/a)). If a is less\n                // than one, 1/a will be greater than one, and this if statement will not be entered in the recursive call.\n                // Fixed point division requires multiplying by ONE_18.\n                return (-_ln((ONE_18 * ONE_18) / a));\n            }\n\n            // First, we use the fact that ln^(a * b) = ln(a) + ln(b) to decompose ln(a) into a sum of powers of two, which\n            // we call x_n, where x_n == 2^(7 - n), which are the natural logarithm of precomputed quantities a_n (that is,\n            // ln(a_n) = x_n). We choose the first x_n, x0, to equal 2^7 because the exponential of all larger powers cannot\n            // be represented as 18 fixed point decimal numbers in 256 bits, and are therefore larger than a.\n            // At the end of this process we will have the sum of all x_n = ln(a_n) that apply, and the remainder of this\n            // decomposition, which will be lower than the smallest a_n.\n            // ln(a) = k_0 * x_0 + k_1 * x_1 + ... + k_n * x_n + ln(remainder), where each k_n equals either 0 or 1.\n            // We mutate a by subtracting a_n, making it the remainder of the decomposition.\n\n            // For reasons related to how `exp` works, the first two a_n (e^(2^7) and e^(2^6)) are not stored as fixed point\n            // numbers with 18 decimals, but instead as plain integers with 0 decimals, so we need to multiply them by\n            // ONE_18 to convert them to fixed point.\n            // For each a_n, we test if that term is present in the decomposition (if a is larger than it), and if so divide\n            // by it and compute the accumulated sum.\n\n            int256 sum = 0;\n            if (a >= a0 * ONE_18) {\n                a /= a0; // Integer, not fixed point division\n                sum += x0;\n            }\n\n            if (a >= a1 * ONE_18) {\n                a /= a1; // Integer, not fixed point division\n                sum += x1;\n            }\n\n            // All other a_n and x_n are stored as 20 digit fixed point numbers, so we convert the sum and a to this format.\n            sum *= 100;\n            a *= 100;\n\n            // Because further a_n are  20 digit fixed point numbers, we multiply by ONE_20 when dividing by them.\n\n            if (a >= a2) {\n                a = (a * ONE_20) / a2;\n                sum += x2;\n            }\n\n            if (a >= a3) {\n                a = (a * ONE_20) / a3;\n                sum += x3;\n            }\n\n            if (a >= a4) {\n                a = (a * ONE_20) / a4;\n                sum += x4;\n            }\n\n            if (a >= a5) {\n                a = (a * ONE_20) / a5;\n                sum += x5;\n            }\n\n            if (a >= a6) {\n                a = (a * ONE_20) / a6;\n                sum += x6;\n            }\n\n            if (a >= a7) {\n                a = (a * ONE_20) / a7;\n                sum += x7;\n            }\n\n            if (a >= a8) {\n                a = (a * ONE_20) / a8;\n                sum += x8;\n            }\n\n            if (a >= a9) {\n                a = (a * ONE_20) / a9;\n                sum += x9;\n            }\n\n            if (a >= a10) {\n                a = (a * ONE_20) / a10;\n                sum += x10;\n            }\n\n            if (a >= a11) {\n                a = (a * ONE_20) / a11;\n                sum += x11;\n            }\n\n            // a is now a small number (smaller than a_11, which roughly equals 1.06). This means we can use a Taylor series\n            // that converges rapidly for values of `a` close to one - the same one used in ln_36.\n            // Let z = (a - 1) / (a + 1).\n            // ln(a) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\n\n            // Recall that 20 digit fixed point division requires multiplying by ONE_20, and multiplication requires\n            // division by ONE_20.\n            int256 z = ((a - ONE_20) * ONE_20) / (a + ONE_20);\n            int256 z_squared = (z * z) / ONE_20;\n\n            // num is the numerator of the series: the z^(2 * n + 1) term\n            int256 num = z;\n\n            // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\n            int256 seriesSum = num;\n\n            // In each step, the numerator is multiplied by z^2\n            num = (num * z_squared) / ONE_20;\n            seriesSum += num / 3;\n\n            num = (num * z_squared) / ONE_20;\n            seriesSum += num / 5;\n\n            num = (num * z_squared) / ONE_20;\n            seriesSum += num / 7;\n\n            num = (num * z_squared) / ONE_20;\n            seriesSum += num / 9;\n\n            num = (num * z_squared) / ONE_20;\n            seriesSum += num / 11;\n\n            // 6 Taylor terms are sufficient for 36 decimal precision.\n\n            // Finally, we multiply by 2 (non fixed point) to compute ln(remainder)\n            seriesSum *= 2;\n\n            // We now have the sum of all x_n present, and the Taylor approximation of the logarithm of the remainder (both\n            // with 20 decimals). All that remains is to sum these two, and then drop two digits to return a 18 decimal\n            // value.\n\n            return (sum + seriesSum) / 100;\n        }\n    }\n\n    /**\n     * @dev Intrnal high precision (36 decimal places) natural logarithm (ln(x)) with signed 18 decimal fixed point argument,\n     * for x close to one.\n     *\n     * Should only be used if x is between LN_36_LOWER_BOUND and LN_36_UPPER_BOUND.\n     */\n    function _ln_36(int256 x) private pure returns (int256) {\n        unchecked {\n            // Since ln(1) = 0, a value of x close to one will yield a very small result, which makes using 36 digits\n            // worthwhile.\n\n            // First, we transform x to a 36 digit fixed point value.\n            x *= ONE_18;\n\n            // We will use the following Taylor expansion, which converges very rapidly. Let z = (x - 1) / (x + 1).\n            // ln(x) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\n\n            // Recall that 36 digit fixed point division requires multiplying by ONE_36, and multiplication requires\n            // division by ONE_36.\n            int256 z = ((x - ONE_36) * ONE_36) / (x + ONE_36);\n            int256 z_squared = (z * z) / ONE_36;\n\n            // num is the numerator of the series: the z^(2 * n + 1) term\n            int256 num = z;\n\n            // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\n            int256 seriesSum = num;\n\n            // In each step, the numerator is multiplied by z^2\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 3;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 5;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 7;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 9;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 11;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 13;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 15;\n\n            // 8 Taylor terms are sufficient for 36 decimal precision.\n\n            // All that remains is multiplying by 2 (non fixed point).\n            return seriesSum * 2;\n        }\n    }\n\n    function sqrt(uint256 x) internal pure returns (uint256) {\n        return pow(x, uint256(ONE_18) / 2);\n    }\n}\n"
    },
    "BalancerErrors.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\nlibrary BalancerErrors {\n    string constant X_OUT_OF_BOUNDS = \"X_OUT_OF_BOUNDS\";\n    string constant Y_OUT_OF_BOUNDS = \"Y_OUT_OF_BOUNDS\";\n    string constant PRODUCT_OUT_OF_BOUNDS = \"PRODUCT_OUT_OF_BOUNDS\";\n    string constant INVALID_EXPONENT = \"INVALID_EXPONENT\";\n    string constant OUT_OF_BOUNDS = \"OUT_OF_BOUNDS\";\n}\n"
    },
    "SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"IERC20.sol\";\nimport \"draft-IERC20Permit.sol\";\nimport \"Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "BaseDelegatingVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\nimport \"IVault.sol\";\nimport \"IDelegatingVault.sol\";\n\nimport \"BaseVault.sol\";\n\nimport \"Errors.sol\";\nimport \"DataTypes.sol\";\nimport \"VotingPowerHistory.sol\";\n\nabstract contract BaseDelegatingVault is BaseVault, IDelegatingVault {\n    using VotingPowerHistory for VotingPowerHistory.History;\n    using EnumerableMap for EnumerableMap.AddressToUintMap;\n\n    // @notice A record of delegates per account\n    // this is the current delegates (not snapshot) and\n    // is only used to allow this information to be retrived (e.g. by the frontend)\n    mapping(address => EnumerableMap.AddressToUintMap)\n        internal _currentDelegations;\n\n    function delegateVote(address _delegate, uint256 _amount) external {\n        _delegateVote(msg.sender, _delegate, _amount);\n    }\n\n    function undelegateVote(address _delegate, uint256 _amount) external {\n        _undelegateVote(msg.sender, _delegate, _amount);\n    }\n\n    function changeDelegate(\n        address _oldDelegate,\n        address _newDelegate,\n        uint256 _amount\n    ) external {\n        _undelegateVote(msg.sender, _oldDelegate, _amount);\n        _delegateVote(msg.sender, _newDelegate, _amount);\n    }\n\n    function getDelegations(\n        address account\n    ) external view returns (DataTypes.Delegation[] memory delegations) {\n        EnumerableMap.AddressToUintMap storage delegates = _currentDelegations[\n            account\n        ];\n        uint256 len = delegates.length();\n        delegations = new DataTypes.Delegation[](len);\n        for (uint256 i = 0; i < len; i++) {\n            (address delegate, uint256 amount) = delegates.at(i);\n            delegations[i] = DataTypes.Delegation(delegate, amount);\n        }\n        return delegations;\n    }\n\n    function _delegateVote(address from, address to, uint256 amount) internal {\n        require(to != address(0), \"cannot delegate to 0 address\");\n        history.delegateVote(from, to, amount);\n        (bool exists, uint256 current) = _currentDelegations[from].tryGet(to);\n        uint256 newAmount = exists ? current + amount : amount;\n        _currentDelegations[from].set(to, newAmount);\n    }\n\n    function _undelegateVote(\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        history.undelegateVote(from, to, amount);\n        uint256 current = _currentDelegations[from].get(to);\n        if (current == amount) {\n            _currentDelegations[from].remove(to);\n        } else {\n            // amount < current\n            _currentDelegations[from].set(to, current - amount);\n        }\n    }\n}\n"
    },
    "IVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\nimport \"VotingPowerHistory.sol\";\n\ninterface IVault {\n    function getRawVotingPower(address account) external view returns (uint256);\n\n    function getCurrentRecord(\n        address account\n    ) external view returns (VotingPowerHistory.Record memory);\n\n    function getRawVotingPower(\n        address account,\n        uint256 timestamp\n    ) external view returns (uint256);\n\n    function getTotalRawVotingPower() external view returns (uint256);\n\n    function getVaultType() external view returns (string memory);\n}\n"
    },
    "IDelegatingVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\nimport \"DataTypes.sol\";\n\ninterface IDelegatingVault {\n    function delegateVote(address _delegate, uint256 _amount) external;\n\n    function undelegateVote(address _delegate, uint256 _amount) external;\n\n    function changeDelegate(\n        address _oldDelegate,\n        address _newDelegate,\n        uint256 _amount\n    ) external;\n\n    function getDelegations(\n        address account\n    ) external view returns (DataTypes.Delegation[] memory delegations);\n\n    event VotesDelegated(address delegator, address delegate, uint amount);\n    event VotesUndelegated(address delegator, address delegate, uint amount);\n}\n"
    },
    "BaseVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\nimport \"IVault.sol\";\n\nimport \"Errors.sol\";\nimport \"DataTypes.sol\";\nimport \"VotingPowerHistory.sol\";\n\nabstract contract BaseVault is IVault {\n    using VotingPowerHistory for VotingPowerHistory.History;\n\n    VotingPowerHistory.History internal history;\n\n    function getCurrentRecord(\n        address account\n    ) external view returns (VotingPowerHistory.Record memory) {\n        return history.currentRecord(account);\n    }\n\n    function getRawVotingPower(\n        address account\n    ) external view returns (uint256) {\n        return getRawVotingPower(account, block.timestamp);\n    }\n\n    function getRawVotingPower(\n        address account,\n        uint256 timestamp\n    ) public view virtual returns (uint256);\n}\n"
    },
    "VaultWithThreshold.sol": {
      "content": "// SPDX-License-Identifier: Unlicensed\npragma solidity ^0.8.17;\n\nimport \"IVaultWithThreshold.sol\";\n\ncontract VaultWithThreshold is IVaultWithThreshold {\n    uint256 public override threshold;\n\n    function setThreshold(uint256 _threshold) external {\n        threshold = _threshold;\n        emit ThresholdSet(_threshold);\n    }\n}\n"
    },
    "IVaultWithThreshold.sol": {
      "content": "// SPDX-License-Identifier: Unlicensed\npragma solidity ^0.8.17;\n\ninterface IVaultWithThreshold {\n    event ThresholdSet(uint256 threshold);\n\n    function threshold() external view returns (uint256);\n\n    function setThreshold(uint256 threshold) external;\n}\n"
    }
  },
  "settings": {
    "evmVersion": "london",
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "libraries": {
      "LockedVaultWithThreshold.sol": {}
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}