{{
  "language": "Solidity",
  "sources": {
    "src/eco/Relayer.sol": {
      "content": "// This file is part of Darwinia.\n// Copyright (C) 2018-2023 Darwinia Network\n// SPDX-License-Identifier: GPL-3.0\n//\n// Darwinia is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Darwinia is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Darwinia. If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity 0.8.17;\n\nimport \"../interfaces/IORMP.sol\";\n\ncontract Relayer {\n    event Assigned(bytes32 indexed msgHash, uint256 fee, bytes params, bytes32[32] proof);\n    event SetDstPrice(uint256 indexed chainId, uint128 dstPriceRatio, uint128 dstGasPriceInWei);\n    event SetDstConfig(uint256 indexed chainId, uint64 baseGas, uint64 gasPerByte);\n    event SetApproved(address operator, bool approve);\n\n    struct DstPrice {\n        uint128 dstPriceRatio; // dstPrice / localPrice * 10^10\n        uint128 dstGasPriceInWei;\n    }\n\n    struct DstConfig {\n        uint64 baseGas;\n        uint64 gasPerByte;\n    }\n\n    address public immutable PROTOCOL;\n\n    address public owner;\n    // chainId => price\n    mapping(uint256 => DstPrice) public priceOf;\n    mapping(uint256 => DstConfig) public configOf;\n    mapping(address => bool) public approvedOf;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"!owner\");\n        _;\n    }\n\n    modifier onlyApproved() {\n        require(isApproved(msg.sender), \"!approve\");\n        _;\n    }\n\n    constructor(address dao, address ormp) {\n        PROTOCOL = ormp;\n        owner = dao;\n    }\n\n    receive() external payable {}\n\n    function withdraw(address to, uint256 amount) external onlyApproved {\n        (bool success,) = to.call{value: amount}(\"\");\n        require(success, \"!withdraw\");\n    }\n\n    function isApproved(address operator) public view returns (bool) {\n        return approvedOf[operator];\n    }\n\n    function changeOwner(address owner_) external onlyOwner {\n        owner = owner_;\n    }\n\n    function setApproved(address operator, bool approve) public onlyOwner {\n        approvedOf[operator] = approve;\n        emit SetApproved(operator, approve);\n    }\n\n    function setDstPrice(uint256 chainId, uint128 dstPriceRatio, uint128 dstGasPriceInWei) external onlyApproved {\n        priceOf[chainId] = DstPrice(dstPriceRatio, dstGasPriceInWei);\n        emit SetDstPrice(chainId, dstPriceRatio, dstGasPriceInWei);\n    }\n\n    function setDstConfig(uint256 chainId, uint64 baseGas, uint64 gasPerByte) external onlyApproved {\n        configOf[chainId] = DstConfig(baseGas, gasPerByte);\n        emit SetDstConfig(chainId, baseGas, gasPerByte);\n    }\n\n    // extraGas = gasLimit\n    function fee(\n        uint256 toChainId,\n        address, /*ua*/\n        uint256 gasLimit,\n        bytes calldata encoded,\n        bytes calldata /*params*/\n    ) public view returns (uint256) {\n        uint256 size = encoded.length;\n        uint256 extraGas = gasLimit;\n        DstPrice memory p = priceOf[toChainId];\n        DstConfig memory c = configOf[toChainId];\n\n        require(c.baseGas != 0, \"!baseGas\");\n        // remoteToken = dstGasPriceInWei * (baseGas + extraGas)\n        uint256 remoteToken = p.dstGasPriceInWei * (c.baseGas + extraGas);\n        // dstPriceRatio = dstPrice / localPrice * 10^10\n        // sourceToken = RemoteToken * dstPriceRatio\n        uint256 sourceToken = remoteToken * p.dstPriceRatio / (10 ** 10);\n        uint256 payloadToken = c.gasPerByte * size * p.dstGasPriceInWei * p.dstPriceRatio / (10 ** 10);\n        return sourceToken + payloadToken;\n    }\n\n    function assign(bytes32 msgHash, bytes calldata params) external payable {\n        require(msg.sender == PROTOCOL, \"!ormp\");\n        emit Assigned(msgHash, msg.value, params, IORMP(PROTOCOL).prove());\n    }\n\n    function relay(Message calldata message, bytes calldata proof) external onlyApproved {\n        IORMP(PROTOCOL).recv(message, proof);\n    }\n}\n"
    },
    "src/interfaces/IORMP.sol": {
      "content": "// This file is part of Darwinia.\n// Copyright (C) 2018-2023 Darwinia Network\n// SPDX-License-Identifier: GPL-3.0\n//\n// Darwinia is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Darwinia is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Darwinia. If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity 0.8.17;\n\nimport \"../Common.sol\";\n\ninterface IORMP {\n    /// @dev Send a cross-chain message over the endpoint.\n    /// @notice follow https://eips.ethereum.org/EIPS/eip-5750\n    /// @param toChainId The Message destination chain id.\n    /// @param to User application contract address which receive the message.\n    /// @param gasLimit Gas limit for destination user application used.\n    /// @param encoded The calldata which encoded by ABI Encoding.\n    /// @param refund Return extra fee to refund address.\n    /// @param params General extensibility for relayer to custom functionality.\n    /// @return Return the hash of the message as message id.\n    function send(\n        uint256 toChainId,\n        address to,\n        uint256 gasLimit,\n        bytes calldata encoded,\n        address refund,\n        bytes calldata params\n    ) external payable returns (bytes32);\n\n    /// @notice Get a quote in source native gas, for the amount that send() requires to pay for message delivery.\n    /// @param toChainId The Message destination chain id.\n    //  @param ua User application contract address which send the message.\n    /// @param gasLimit Gas limit for destination user application used.\n    /// @param encoded The calldata which encoded by ABI Encoding.\n    /// @param params General extensibility for relayer to custom functionality.\n    function fee(uint256 toChainId, address ua, uint256 gasLimit, bytes calldata encoded, bytes calldata params)\n        external\n        view\n        returns (uint256);\n\n    /// @dev Recv verified message and dispatch to destination user application address.\n    /// @param message Verified receive message info.\n    /// @param proof Message proof of this message.\n    /// @return dispatchResult Result of the message dispatch.\n    function recv(Message calldata message, bytes calldata proof) external returns (bool dispatchResult);\n\n    function prove() external view returns (bytes32[32] memory);\n\n    /// @dev Fetch user application config.\n    /// @notice If user application has not configured, then the default config is used.\n    /// @param ua User application contract address.\n    /// @return user application config.\n    function getAppConfig(address ua) external view returns (UC memory);\n\n    /// @notice Set user application config.\n    /// @param oracle Oracle which user application choose.\n    /// @param relayer Relayer which user application choose.\n    function setAppConfig(address oracle, address relayer) external;\n\n    function defaultUC() external view returns (UC memory);\n}\n"
    },
    "src/Common.sol": {
      "content": "// This file is part of Darwinia.\n// Copyright (C) 2018-2023 Darwinia Network\n// SPDX-License-Identifier: GPL-3.0\n//\n// Darwinia is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Darwinia is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Darwinia. If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity 0.8.17;\n\n/// @dev The block of control information and data for comminicate\n/// between user applications. Messages are the exchange medium\n/// used by channels to send and receive data through cross-chain networks.\n/// A message is sent from a source chain to a destination chain.\n/// @param index The leaf index lives in channel's incremental mekle tree.\n/// @param fromChainId The message source chain id.\n/// @param from User application contract address which send the message.\n/// @param toChainId The message destination chain id.\n/// @param to User application contract address which receive the message.\n/// @param gasLimit Gas limit for destination UA used.\n/// @param encoded The calldata which encoded by ABI Encoding.\nstruct Message {\n    address channel;\n    uint256 index;\n    uint256 fromChainId;\n    address from;\n    uint256 toChainId;\n    address to;\n    uint256 gasLimit;\n    bytes encoded; /*(abi.encodePacked(SELECTOR, PARAMS))*/\n}\n\n/// @dev User application custom configuration.\n/// @param oracle Oracle contract address.\n/// @param relayer Relayer contract address.\nstruct UC {\n    address oracle;\n    address relayer;\n}\n\n/// @dev Hash of the message.\nfunction hash(Message memory message) pure returns (bytes32) {\n    return keccak256(abi.encode(message));\n}\n"
    }
  },
  "settings": {
    "remappings": [],
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "metadata": {
      "useLiteralContent": true,
      "bytecodeHash": "ipfs"
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "evmVersion": "london",
    "libraries": {}
  }
}}