{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "london",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "contracts/BlockStar_Presale.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\ninterface IERC20 {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(\n        address owner,\n        address spender\n    ) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external;\n\n    function transfer(address to, uint256 value) external;\n\n    function transferFrom(address from, address to, uint256 value) external;\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\ninterface AggregatorV3Interface {\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n\ncontract BlockStar_Presale {\n  IERC20 public Token;\n  IERC20 public USDT = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);\n  AggregatorV3Interface public priceFeed;\n\n  address payable public owner;\n\n  uint256 public tokenPerUsd = 33 ether;\n  uint256 public totalUsers;\n  uint256 public soldToken;\n  uint256 public totalSupply = 1500_000_000 ether;\n  uint256 public minimumBuyInUsdt = 1 * 1e6;\n  uint256 public minimumBuyInEth = 0.00054 ether;\n  uint256 public maximumBuy = 3000000 ether;\n  uint256 public amountRaisedETHUSDT;\n  uint256 public amountRaisedUSDT;\n\n  bool public presaleStatus;\n  bool public enableClaim;\n\n  uint256 public constant divider = 100;\n\n  // Define the vesting period (in seconds) for 70% of the tokens (12 weeks)\n  uint256 public vestingStartTime;\n  uint256 public vestingDuration = 90 days;\n\n  struct User {\n    uint256 eth_usdt_balance;\n    uint256 usdt_balance;\n    uint256 token_balance;\n    uint256 claimable_amount;\n    uint256 vesting_amount;\n    uint256 claimed_token;\n  }\n\n  mapping(address => User) public users;\n\n  event BuyToken(address indexed user, uint256 amount);\n  event ClaimToken(address indexed user, uint256 amount);\n  event UpdatePrice(uint256 oldPrice, uint256 newPrice);\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n  modifier onlyOwner() {\n    require(msg.sender == owner, \"Presale: Not an owner\");\n    _;\n  }\n\n  constructor(address _tokenAddress) {\n    Token = IERC20(_tokenAddress);\n    owner = payable(msg.sender);\n    priceFeed = AggregatorV3Interface(\n      0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419\n    );\n    presaleStatus = true;\n  }\n\n  receive() external payable {}\n\n  function getLatestPrice() public view returns (uint256) {\n    (, int256 price, , , ) = priceFeed.latestRoundData();\n    return uint256(price);\n  }\n\n  function buyToken() public payable {\n    require(presaleStatus, \"Presale: Presale is finished\");\n    require(\n      msg.value >= minimumBuyInEth,\n      \"Presale: Amount should be greater than minimum buy\"\n    );\n    require(soldToken <= totalSupply, \"Presale: All tokens sold\");\n\n    uint256 totalTokens = nativeToToken(msg.value);\n\n    // Calculate the amount to vest (70%)\n    uint256 vestingAmount = (totalTokens * 70) / 100;\n    uint256 nonVestingAmount = (totalTokens * 30) / 100;\n\n    // Update the soldToken, amountRaisedETHUSDT, and user balances\n    soldToken += totalTokens;\n    amountRaisedETHUSDT += (msg.value * getLatestPrice()) / (1 ether);\n\n    users[msg.sender].eth_usdt_balance +=\n      (msg.value * getLatestPrice()) /\n      (1 ether);\n\n    users[msg.sender].token_balance += totalTokens;\n    users[msg.sender].claimable_amount += nonVestingAmount;\n    users[msg.sender].vesting_amount += vestingAmount;\n\n    require(\n      users[msg.sender].token_balance <= maximumBuy,\n      \"Presale: Maximum buy limit reached\"\n    );\n\n    emit BuyToken(msg.sender, totalTokens);\n  }\n\n  function buyTokenUSDT(uint256 amount) external {\n    require(presaleStatus == true, \"Presale : Presale is finished\");\n    require(\n      amount >= minimumBuyInUsdt,\n      \"amount should be greater than minimum buy\"\n    );\n    require(soldToken <= totalSupply, \"All Sold\");\n\n    USDT.transferFrom(msg.sender, owner, amount);\n\n    uint256 totalTokens = usdtToToken(amount);\n\n    // Calculate the amount to vest (70%)\n    uint256 vestingAmount = (totalTokens * 70) / 100;\n    uint256 nonVestingAmount = (totalTokens * 30) / 100;\n\n    // Update soldToken and amountRaisedUSDT\n    soldToken = soldToken + (totalTokens);\n    amountRaisedUSDT = amountRaisedUSDT + (amount);\n\n    // Update user balances\n    users[msg.sender].usdt_balance += amount;\n    users[msg.sender].token_balance += totalTokens;\n    users[msg.sender].claimable_amount += nonVestingAmount;\n    users[msg.sender].vesting_amount += vestingAmount;\n\n    require(\n      users[msg.sender].token_balance <= maximumBuy,\n      \"Presale: Maximum buy limit reached\"\n    );\n  }\n\n  function endPresale() external onlyOwner {\n    require(presaleStatus, \"Presale: Presale is not active\");\n    presaleStatus = false;\n    vestingStartTime = block.timestamp;\n  }\n\n  // Existing buyToken and buyTokenUSDT functions...\n  function claimTokens() external {\n    require(enableClaim, \"Presale: Claim not active yet\");\n    require(vestingStartTime > 0, \"Presale: Vesting not started\");\n\n    (uint256 claimableAmount, bool isVestingUnlock) = getClaimableTokens(\n      msg.sender\n    );\n\n    require(claimableAmount > 0, \"Presale: No tokens to claim\");\n\n    users[msg.sender].claimed_token += claimableAmount;\n    users[msg.sender].token_balance -= claimableAmount;\n\n    if (isVestingUnlock) {\n      users[msg.sender].claimable_amount = 0;\n      users[msg.sender].vesting_amount = 0;\n    } else {\n      users[msg.sender].claimable_amount = 0;\n    }\n\n    Token.transfer(msg.sender, claimableAmount);\n\n    emit ClaimToken(msg.sender, claimableAmount);\n  }\n\n  function enableTokenClaim(bool _state) external onlyOwner {\n    enableClaim = _state;\n  }\n\n  function stopPresale(bool _off) external onlyOwner {\n    presaleStatus = _off;\n  }\n\n  function setMinimumBuyInUsdt(uint256 _minimumBuyInUsdt) external onlyOwner {\n    minimumBuyInUsdt = _minimumBuyInUsdt;\n  }\n\n  function setMinimumBuyInEth(uint256 _minimumBuyInEth) external onlyOwner {\n    minimumBuyInEth = _minimumBuyInEth;\n  }\n\n  function setMaxTokenBuy(uint256 _maxTokens) external onlyOwner {\n    maximumBuy = _maxTokens;\n  }\n\n  function nativeToToken(uint256 _amount) public view returns (uint256) {\n    uint256 ethToUsd = (_amount * getLatestPrice()) / (1 ether);\n    uint256 numberOfTokens = (ethToUsd * tokenPerUsd) / (1e8);\n    return numberOfTokens;\n  }\n\n  function usdtToToken(uint256 _amount) public view returns (uint256) {\n    uint256 numberOfTokens = (_amount * tokenPerUsd) / (1e6);\n    return numberOfTokens;\n  }\n\n  function changePrice(uint256 _price) external onlyOwner {\n    tokenPerUsd = _price;\n  }\n\n  function transferOwnership(address payable _newOwner) external onlyOwner {\n    require(_newOwner != address(0), \"Ownable: new owner is the zero address\");\n    address payable oldOwner = owner;\n    owner = _newOwner;\n    emit OwnershipTransferred(oldOwner, owner);\n  }\n\n  function changeToken(address _token) external onlyOwner {\n    Token = IERC20(_token);\n  }\n\n  function changeUSDT(address _USDT) external onlyOwner {\n    USDT = IERC20(_USDT);\n  }\n\n  function transferFunds(uint256 _value) external onlyOwner {\n    owner.transfer(_value);\n  }\n\n  function transferTokens(IERC20 token, uint256 _value) external onlyOwner {\n    token.transfer(msg.sender, _value);\n  }\n\n  function getClaimableTokens(\n    address _user\n  ) public view returns (uint256, bool) {\n    uint256 claimableAmount = users[_user].claimable_amount;\n    bool isVestingUnlock = block.timestamp >=\n      vestingStartTime + vestingDuration;\n\n    if (isVestingUnlock) {\n      claimableAmount += users[_user].vesting_amount;\n    }\n\n    return (claimableAmount, isVestingUnlock);\n  }\n}"
    }
  }
}}