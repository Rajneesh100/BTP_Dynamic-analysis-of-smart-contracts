{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "paris",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 0
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "contracts/Donations.sol": {
      "content": "/**\r\n *Submitted for verification at polygonscan.com on 2022-12-07\r\n */\r\n\r\n// SPDX-License-Identifier: MIT\r\n// File: Donations.sol\r\n\r\npragma solidity ^0.8.17;\r\n\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     *\r\n     * Furthermore, `isContract` will also return true if the target contract within\r\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\r\n     * which only has an effect at the end of a transaction.\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(\r\n            address(this).balance >= amount,\r\n            \"Address: insufficient balance\"\r\n        );\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(\r\n            success,\r\n            \"Address: unable to send value, recipient may have reverted\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data\r\n    ) internal returns (bytes memory) {\r\n        return\r\n            functionCallWithValue(\r\n                target,\r\n                data,\r\n                0,\r\n                \"Address: low-level call failed\"\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return\r\n            functionCallWithValue(\r\n                target,\r\n                data,\r\n                value,\r\n                \"Address: low-level call with value failed\"\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(\r\n            address(this).balance >= value,\r\n            \"Address: insufficient balance for call\"\r\n        );\r\n        (bool success, bytes memory returndata) = target.call{value: value}(\r\n            data\r\n        );\r\n        return\r\n            verifyCallResultFromTarget(\r\n                target,\r\n                success,\r\n                returndata,\r\n                errorMessage\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data\r\n    ) internal view returns (bytes memory) {\r\n        return\r\n            functionStaticCall(\r\n                target,\r\n                data,\r\n                \"Address: low-level static call failed\"\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return\r\n            verifyCallResultFromTarget(\r\n                target,\r\n                success,\r\n                returndata,\r\n                errorMessage\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data\r\n    ) internal returns (bytes memory) {\r\n        return\r\n            functionDelegateCall(\r\n                target,\r\n                data,\r\n                \"Address: low-level delegate call failed\"\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return\r\n            verifyCallResultFromTarget(\r\n                target,\r\n                success,\r\n                returndata,\r\n                errorMessage\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\r\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\r\n     *\r\n     * _Available since v4.8._\r\n     */\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        if (success) {\r\n            if (returndata.length == 0) {\r\n                // only check isContract if the call was successful and the return data is empty\r\n                // otherwise we already know that it was a contract\r\n                require(isContract(target), \"Address: call to non-contract\");\r\n            }\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason or using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    function _revert(\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) private pure {\r\n        // Look for revert reason and bubble it up if present\r\n        if (returndata.length > 0) {\r\n            // The easiest way to bubble the revert reason is using memory via assembly\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert(errorMessage);\r\n        }\r\n    }\r\n}\r\n\r\nabstract contract Initializable {\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     * @custom:oz-retyped-from bool\r\n     */\r\n    uint8 private _initialized;\r\n\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    bool private _initializing;\r\n\r\n    /**\r\n     * @dev Triggered when the contract has been initialized or reinitialized.\r\n     */\r\n    event Initialized(uint8 version);\r\n\r\n    /**\r\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\r\n     * `onlyInitializing` functions can be used to initialize parent contracts.\r\n     *\r\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\r\n     * constructor.\r\n     *\r\n     * Emits an {Initialized} event.\r\n     */\r\n    modifier initializer() {\r\n        bool isTopLevelCall = !_initializing;\r\n        require(\r\n            (isTopLevelCall && _initialized < 1) ||\r\n                (!Address.isContract(address(this)) && _initialized == 1),\r\n            \"Initializable: contract is already initialized\"\r\n        );\r\n        _initialized = 1;\r\n        if (isTopLevelCall) {\r\n            _initializing = true;\r\n        }\r\n        _;\r\n        if (isTopLevelCall) {\r\n            _initializing = false;\r\n            emit Initialized(1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\r\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\r\n     * used to initialize parent contracts.\r\n     *\r\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\r\n     * are added through upgrades and that require initialization.\r\n     *\r\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\r\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\r\n     *\r\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\r\n     * a contract, executing them in the right order is up to the developer or operator.\r\n     *\r\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\r\n     *\r\n     * Emits an {Initialized} event.\r\n     */\r\n    modifier reinitializer(uint8 version) {\r\n        require(\r\n            !_initializing && _initialized < version,\r\n            \"Initializable: contract is already initialized\"\r\n        );\r\n        _initialized = version;\r\n        _initializing = true;\r\n        _;\r\n        _initializing = false;\r\n        emit Initialized(version);\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\r\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\r\n     */\r\n    modifier onlyInitializing() {\r\n        require(_initializing, \"Initializable: contract is not initializing\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\r\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\r\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\r\n     * through proxies.\r\n     *\r\n     * Emits an {Initialized} event the first time it is successfully executed.\r\n     */\r\n    function _disableInitializers() internal virtual {\r\n        require(!_initializing, \"Initializable: contract is initializing\");\r\n        if (_initialized != type(uint8).max) {\r\n            _initialized = type(uint8).max;\r\n            emit Initialized(type(uint8).max);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\r\n     */\r\n    function _getInitializedVersion() internal view returns (uint8) {\r\n        return _initialized;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\r\n     */\r\n    function _isInitializing() internal view returns (bool) {\r\n        return _initializing;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\r\n    }\r\n\r\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\r\n    }\r\n\r\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\ncontract Donations is Initializable {\r\n    using SafeMath for uint;\r\n    address public admin;\r\n    address public VITreasury;\r\n    uint256 public VIRoyalty;\r\n    uint256 public minEthDonation;\r\n\r\n    purchaseData[] allPurchases;\r\n    rePurchaseData[] allRePurchases;\r\n\r\n    mapping(address => purchaseData[]) userPurchases;\r\n    mapping(address => rePurchaseData[]) userRePurchases;\r\n\r\n    event purchaseNft(purchaseData _data);\r\n    event Withdraw(address to, uint256 amount);\r\n\r\n    struct purchaseData {\r\n        uint timestamp;\r\n        address buyer;\r\n        address beneficiary;\r\n        uint donation;\r\n        uint tokenId;\r\n        string contractHash;\r\n        string buyerCsprWallet;\r\n    }\r\n\r\n    struct rePurchaseData {\r\n        uint timestamp;\r\n        address buyer;\r\n        address beneficiary;\r\n        uint donation;\r\n        address artist;\r\n        uint artist_spercentage;\r\n        uint tokenId;\r\n        string contrachHash;\r\n        string buyerCsprWallet;\r\n    }\r\n\r\n    function initialize(address _treasury) public initializer {\r\n        minEthDonation = 0.001 ether;\r\n        admin = msg.sender;\r\n        VITreasury = _treasury;\r\n        VIRoyalty = 2;\r\n    }\r\n\r\n    // constructor(address _treasury) {\r\n    //     admin = msg.sender;\r\n    //     VITreasury = _treasury;\r\n    //     VIRoyalty = 2;\r\n    // }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == admin, \"VINFTS: NOT AUTHORIZED\");\r\n        _;\r\n    }\r\n\r\n    // GETTER FUNCTIONS\r\n    function getUserPurchases(\r\n        address _doner\r\n    ) public view returns (purchaseData[] memory) {\r\n        return userPurchases[_doner];\r\n    }\r\n\r\n    function getUserRePurchases(\r\n        address _doner\r\n    ) public view returns (rePurchaseData[] memory) {\r\n        return userRePurchases[_doner];\r\n    }\r\n\r\n    function getAllPurchases() public view returns (purchaseData[] memory) {\r\n        return allPurchases;\r\n    }\r\n\r\n    function getAllRePurchases() public view returns (rePurchaseData[] memory) {\r\n        return allRePurchases;\r\n    }\r\n\r\n    // SETTER FUNCTIONS\r\n    // function to change VINFTS treasury wallet;\r\n    function changeTreasury(address _treasury) public onlyOwner {\r\n        VITreasury = _treasury;\r\n    }\r\n\r\n    // function to change royalty sent to VITreasuty wallet;\r\n    function changeRoyalty(uint _royalty) public onlyOwner {\r\n        // if you want 2% percent, you should set \"_royalty\" to be 2;\r\n        VIRoyalty = _royalty;\r\n    }\r\n\r\n    function purchaseToken(\r\n        address _beneficiary,\r\n        address _owner,\r\n        uint _ownerPercentage,\r\n        uint _tokenId,\r\n        string memory _contractHash,\r\n        string memory _buyerCSPRWallet\r\n    ) public payable {\r\n        //uint _toBeneficiary = msg.value.mul(100-VIRoyalty-_ownerPercentage).div(100); // calculate amount will be sent to beneficiary;\r\n        uint _toTreasury = msg.value.mul(VIRoyalty).div(100);\r\n        uint _toBeneficiary = (msg.value - _toTreasury)\r\n            .mul(100 - _ownerPercentage)\r\n            .div(100);\r\n        uint _toOwner = (msg.value - _toTreasury).mul(_ownerPercentage).div(\r\n            100\r\n        );\r\n        uint _transferCost = tx.gasprice.mul(2300); // calculate eth transfer cost;\r\n\r\n        require(\r\n            _toBeneficiary >= minEthDonation + _transferCost,\r\n            \"VINFTS: INSUFFICIENT AMOUNT FOR DONATION\"\r\n        );\r\n\r\n        payable(_beneficiary).transfer(_toBeneficiary);\r\n        payable(VITreasury).transfer(_toTreasury);\r\n        payable(_owner).transfer(_toOwner);\r\n\r\n        _savePurchaseData(\r\n            _beneficiary,\r\n            _tokenId,\r\n            _contractHash,\r\n            _buyerCSPRWallet\r\n        );\r\n    }\r\n\r\n    function _savePurchaseData(\r\n        address _beneficiary,\r\n        uint _tokenId,\r\n        string memory _contractHash,\r\n        string memory _buyerCSPRWallet\r\n    ) internal {\r\n        purchaseData memory entry = purchaseData(\r\n            block.timestamp,\r\n            msg.sender,\r\n            _beneficiary,\r\n            msg.value,\r\n            _tokenId,\r\n            _contractHash,\r\n            _buyerCSPRWallet\r\n        );\r\n        allPurchases.push(entry);\r\n        userPurchases[msg.sender].push(entry);\r\n        emit purchaseNft(entry);\r\n    }\r\n\r\n    function _saveRePurchaseData(\r\n        address _beneficiary,\r\n        address _owner,\r\n        uint _ownerPercentage,\r\n        uint _tokenId,\r\n        string memory _contractHash,\r\n        string memory _buyerCSPRWallet\r\n    ) internal {\r\n        rePurchaseData memory entry = rePurchaseData(\r\n            block.timestamp,\r\n            msg.sender,\r\n            _beneficiary,\r\n            msg.value,\r\n            _owner,\r\n            _ownerPercentage,\r\n            _tokenId,\r\n            _contractHash,\r\n            _buyerCSPRWallet\r\n        );\r\n        allRePurchases.push(entry);\r\n        userRePurchases[msg.sender].push(entry);\r\n    }\r\n\r\n    function _isApproved(\r\n        address _erc20,\r\n        uint _amount\r\n    ) internal view returns (bool) {\r\n        uint _allowed = IERC20(_erc20).allowance(msg.sender, address(this));\r\n        return _allowed >= _amount;\r\n    }\r\n\r\n    function _calcAmounts(\r\n        uint _amount,\r\n        uint _ownerPercentage\r\n    ) internal view returns (uint, uint, uint) {\r\n        uint _toTreasury = _amount.mul(VIRoyalty).div(100);\r\n        uint _toBeneficiary = (_amount - _toTreasury)\r\n            .mul(100 - _ownerPercentage)\r\n            .div(100);\r\n        uint _toOwner = (_amount - _toTreasury).mul(_ownerPercentage).div(100);\r\n\r\n        return (_toTreasury, _toBeneficiary, _toOwner);\r\n    }\r\n\r\n    function puchraseTokenWithERC20(\r\n        address _ERC20Address,\r\n        uint _tokenAmount,\r\n        address _beneficiary,\r\n        address _owner,\r\n        uint _ownerPercentage,\r\n        uint _tokenId,\r\n        string memory _contractHash,\r\n        string memory _buyerCSPRWallet\r\n    ) public {\r\n        bool isApproved = _isApproved(_ERC20Address, _tokenAmount);\r\n        require(isApproved, \"DONATIONS: NO ENOUGH TOKEN ALLOWANCE\");\r\n        (uint _toTreasury, uint _toBeneficiary, uint _toOwner) = _calcAmounts(\r\n            _tokenAmount,\r\n            _ownerPercentage\r\n        );\r\n\r\n        IERC20(_ERC20Address).transferFrom(msg.sender, VITreasury, _toTreasury);\r\n        IERC20(_ERC20Address).transferFrom(\r\n            msg.sender,\r\n            _beneficiary,\r\n            _toBeneficiary\r\n        );\r\n        IERC20(_ERC20Address).transferFrom(msg.sender, _owner, _toOwner);\r\n\r\n        _savePurchaseData(\r\n            _beneficiary,\r\n            _tokenId,\r\n            _contractHash,\r\n            _buyerCSPRWallet\r\n        );\r\n    }\r\n\r\n    function rePurchaseToken(\r\n        address _beneficiary,\r\n        address _owner,\r\n        uint _ownerPercentage,\r\n        uint _tokenId,\r\n        string memory _contractHash,\r\n        string memory _buyerCSPRWallet\r\n    ) public payable {\r\n        //uint _toBeneficiary = msg.value.mul(100-VIRoyalty-_ownerPercentage).div(100); // calculate amount will be sent to beneficiary;\r\n        (uint _toTreasury, uint _toBeneficiary, uint _toOwner) = _calcAmounts(\r\n            msg.value,\r\n            _ownerPercentage\r\n        );\r\n        uint _transferCost = tx.gasprice.mul(2300); // calculate eth transfer cost;\r\n\r\n        require(\r\n            _toBeneficiary >= minEthDonation + _transferCost,\r\n            \"VINFTS: INSUFFICIENT AMOUNT FOR DONATION\"\r\n        );\r\n\r\n        payable(_beneficiary).transfer(_toBeneficiary);\r\n        payable(VITreasury).transfer(_toTreasury);\r\n        payable(_owner).transfer(_toOwner);\r\n\r\n        _saveRePurchaseData(\r\n            _beneficiary,\r\n            _owner,\r\n            _ownerPercentage,\r\n            _tokenId,\r\n            _contractHash,\r\n            _buyerCSPRWallet\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice withdraw tokens from the contract by admin wallet only\r\n     * @param to wallet address\r\n     */\r\n    function emergencyWithdraw(address payable to) external onlyOwner {\r\n        uint256 amount = address(this).balance;\r\n        require(amount > 0, \"zero amount\");\r\n        to.transfer(amount);\r\n        emit Withdraw(to, amount);\r\n    }\r\n\r\n    receive() external payable {}\r\n}\r\n"
    }
  }
}}