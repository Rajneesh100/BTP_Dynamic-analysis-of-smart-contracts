{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "london",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Internal function that returns the initialized version. Returns `_initialized`\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Internal function that returns the initialized version. Returns `_initializing`\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/messaging/MerkleTreeManager.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {ProposedOwnableUpgradeable} from \"../shared/ProposedOwnableUpgradeable.sol\";\nimport {MerkleLib} from \"./libraries/MerkleLib.sol\";\n\n/**\n * @title MerkleTreeManager\n * @notice Contains a Merkle tree instance and exposes read/write functions for the tree.\n * @dev On the hub domain there are two MerkleTreeManager contracts, one for the hub and one for the MainnetSpokeConnector.\n */\ncontract MerkleTreeManager is ProposedOwnableUpgradeable {\n  // ========== Custom Errors ===========\n\n  error MerkleTreeManager__renounceOwnership_prohibited();\n  error MerkleTreeManager__setArborist_zeroAddress();\n  error MerkleTreeManager__setArborist_alreadyArborist();\n\n  // ============ Events ============\n\n  event ArboristUpdated(address previous, address updated);\n\n  event LeafInserted(bytes32 root, uint256 count, bytes32 leaf);\n\n  event LeavesInserted(bytes32 root, uint256 count, bytes32[] leaves);\n\n  // ============ Structs ============\n\n  // Status of Message:\n  //   0 - None - message has not been proven or processed\n  //   1 - Proven - message inclusion proof has been validated\n  //   2 - Processed - message has been dispatched to recipient\n  enum LeafStatus {\n    None,\n    Proven,\n    Processed\n  }\n\n  // ============ Libraries ============\n\n  using MerkleLib for MerkleLib.Tree;\n\n  // ============ Public Storage ============\n\n  /**\n   * @notice Core data structure with which this contract is tasked with keeping custody.\n   * Writable only by the designated arborist.\n   */\n  MerkleLib.Tree public tree;\n\n  /**\n   * @notice The arborist contract that has permission to write to this tree.\n   * @dev This could be the root manager contract or a spoke connector contract, for example.\n   */\n  address public arborist;\n\n  /**\n   * @notice The leaves that are proven already\n   */\n  mapping(bytes32 => LeafStatus) public leaves;\n\n  /**\n   * @notice domain => next available nonce for the domain.\n   */\n  mapping(uint32 => uint32) public nonces;\n\n  // ============ Modifiers ============\n\n  modifier onlyArborist() {\n    require(arborist == msg.sender, \"!arborist\");\n    _;\n  }\n\n  // ============ Getters ============\n\n  /**\n   * @notice Returns the current branch.\n   */\n  function branch() public view returns (bytes32[32] memory) {\n    return tree.branch;\n  }\n\n  /**\n   * @notice Calculates and returns the current root.\n   */\n  function root() public view returns (bytes32) {\n    return tree.root();\n  }\n\n  /**\n   * @notice Returns the number of inserted leaves in the tree (current index).\n   */\n  function count() public view returns (uint256) {\n    return tree.count;\n  }\n\n  /**\n   * @notice Convenience getter: returns the root and count.\n   */\n  function rootAndCount() public view returns (bytes32, uint256) {\n    return (tree.root(), tree.count);\n  }\n\n  // ======== Initializer =========\n\n  function initialize(address _arborist) public initializer {\n    __MerkleTreeManager_init(_arborist);\n    __ProposedOwnable_init();\n  }\n\n  /**\n   * @dev Initializes MerkleTreeManager instance. Sets the msg.sender as the initial permissioned\n   */\n  function __MerkleTreeManager_init(address _arborist) internal onlyInitializing {\n    __MerkleTreeManager_init_unchained(_arborist);\n  }\n\n  function __MerkleTreeManager_init_unchained(address _arborist) internal onlyInitializing {\n    arborist = _arborist;\n  }\n\n  // ============ Admin Functions ==============\n\n  /**\n   * @notice Method for the current arborist to assign write permissions to a new arborist.\n   * @param newArborist The new address to set as the current arborist.\n   */\n  function setArborist(address newArborist) external onlyOwner {\n    if (newArborist == address(0)) revert MerkleTreeManager__setArborist_zeroAddress();\n    address current = arborist;\n    if (current == newArborist) revert MerkleTreeManager__setArborist_alreadyArborist();\n\n    // Emit updated event\n    emit ArboristUpdated(current, newArborist);\n\n    arborist = newArborist;\n  }\n\n  /**\n   * @notice Remove ability to renounce ownership\n   * @dev Renounce ownership should be impossible as long as there is a possibility the\n   * arborist may change.\n   */\n  function renounceOwnership() public virtual override onlyOwner {\n    revert MerkleTreeManager__renounceOwnership_prohibited();\n  }\n\n  // ========= Public Functions =========\n\n  /**\n   * @notice Used to increment nonce\n   * @param _domain The domain the nonce will be used for\n   * @return _nonce The incremented nonce\n   */\n  function incrementNonce(uint32 _domain) public onlyArborist returns (uint32 _nonce) {\n    _nonce = nonces[_domain]++;\n  }\n\n  /**\n   * @notice Used to track proven leaves\n   * @param _leaf The leaf to mark as proven\n   */\n  function markAsProven(bytes32 _leaf) public onlyArborist {\n    require(leaves[_leaf] == LeafStatus.None, \"!empty\");\n    leaves[_leaf] = LeafStatus.Proven;\n  }\n\n  /**\n   * @notice Used to track processed leaves\n   * @param _leaf The leaf to mark as proven\n   */\n  function markAsProcessed(bytes32 _leaf) public onlyArborist {\n    require(leaves[_leaf] == LeafStatus.Proven, \"!proven\");\n    leaves[_leaf] = LeafStatus.Processed;\n  }\n\n  /**\n   * @notice Inserts the given leaves into the tree.\n   * @param _leaves The leaves to be inserted into the tree.\n   * @return _root Current root for convenience.\n   * @return _count Current node count (i.e. number of indices) AFTER the insertion of the new leaf,\n   * provided for convenience.\n   */\n  function insert(bytes32[] memory _leaves) public onlyArborist returns (bytes32 _root, uint256 _count) {\n    // For > 1 leaf, considerably more efficient to put this tree into memory, conduct operations,\n    // then re-assign it to storage - *especially* if we have multiple leaves to insert.\n    MerkleLib.Tree memory _tree = tree;\n\n    uint256 leafCount = _leaves.length;\n    for (uint256 i; i < leafCount; ) {\n      // Insert the new node (using in-memory method).\n      _tree = _tree.insert(_leaves[i]);\n      unchecked {\n        ++i;\n      }\n    }\n    // Write the newly updated tree to storage.\n    tree = _tree;\n\n    // Get return details for convenience.\n    _count = _tree.count;\n    // NOTE: Root calculation method currently reads from storage only.\n    _root = tree.root();\n\n    emit LeavesInserted(_root, _count, _leaves);\n  }\n\n  /**\n   * @notice Inserts the given leaf into the tree.\n   * @param leaf The leaf to be inserted into the tree.\n   * @return _root Current root for convenience.\n   * @return _count Current node count (i.e. number of indices) AFTER the insertion of the new leaf,\n   * provided for convenience.\n   */\n  function insert(bytes32 leaf) public onlyArborist returns (bytes32 _root, uint256 _count) {\n    // Insert the new node.\n    tree = tree.insert(leaf);\n    _count = tree.count;\n    _root = tree.root();\n\n    emit LeafInserted(_root, _count, leaf);\n  }\n\n  // ============ Upgrade Gap ============\n  uint256[46] private __GAP; // gap for upgrade safety\n}\n"
    },
    "contracts/messaging/WatcherClient.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport {ProposedOwnable} from \"../shared/ProposedOwnable.sol\";\nimport {WatcherManager} from \"./WatcherManager.sol\";\n\n/**\n * @notice This contract abstracts the functionality of the watcher manager.\n * Contracts can inherit this contract to be able to use the watcher manager's shared watcher set.\n */\n\ncontract WatcherClient is ProposedOwnable, Pausable {\n  // ============ Events ============\n  /**\n   * @notice Emitted when the manager address changes\n   * @param watcherManager The updated manager\n   */\n  event WatcherManagerChanged(address watcherManager);\n\n  // ============ Properties ============\n  /**\n   * @notice The `WatcherManager` contract governs the watcher allowlist.\n   * @dev Multiple clients can share a watcher set using the same manager\n   */\n  WatcherManager public watcherManager;\n\n  // ============ Constructor ============\n  constructor(address _watcherManager) ProposedOwnable() {\n    watcherManager = WatcherManager(_watcherManager);\n  }\n\n  // ============ Modifiers ============\n  /**\n   * @notice Enforces the sender is the watcher\n   */\n  modifier onlyWatcher() {\n    require(watcherManager.isWatcher(msg.sender), \"!watcher\");\n    _;\n  }\n\n  // ============ Admin fns ============\n  /**\n   * @notice Owner can enroll a watcher (abilities are defined by inheriting contracts)\n   */\n  function setWatcherManager(address _watcherManager) external onlyOwner {\n    require(_watcherManager != address(watcherManager), \"already watcher manager\");\n    watcherManager = WatcherManager(_watcherManager);\n    emit WatcherManagerChanged(_watcherManager);\n  }\n\n  /**\n   * @notice Owner can unpause contracts if fraud is detected by watchers\n   */\n  function unpause() external onlyOwner whenPaused {\n    _unpause();\n  }\n\n  /**\n   * @notice Remove ability to renounce ownership\n   * @dev Renounce ownership should be impossible as long as only the owner\n   * is able to unpause the contracts. You can still propose `address(0)`,\n   * but it will never be accepted.\n   */\n  function renounceOwnership() public virtual override onlyOwner {\n    require(false, \"prohibited\");\n  }\n\n  // ============ Watcher fns ============\n\n  /**\n   * @notice Watchers can pause contracts if fraud is detected\n   */\n  function pause() external onlyWatcher whenNotPaused {\n    _pause();\n  }\n}\n"
    },
    "contracts/messaging/WatcherManager.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {ProposedOwnable} from \"../shared/ProposedOwnable.sol\";\n\n/**\n * @notice This contract manages a set of watchers. This is meant to be used as a shared resource that contracts can\n * inherit to make use of the same watcher set.\n */\n\ncontract WatcherManager is ProposedOwnable {\n  // ============ Events ============\n  event WatcherAdded(address watcher);\n\n  event WatcherRemoved(address watcher);\n\n  // ============ Properties ============\n  mapping(address => bool) public isWatcher;\n\n  // ============ Constructor ============\n  constructor() ProposedOwnable() {\n    _setOwner(msg.sender);\n  }\n\n  // ============ Modifiers ============\n\n  // ============ Admin fns ============\n  /**\n   * @dev Owner can enroll a watcher (abilities are defined by inheriting contracts)\n   */\n  function addWatcher(address _watcher) external onlyOwner {\n    require(!isWatcher[_watcher], \"already watcher\");\n    isWatcher[_watcher] = true;\n    emit WatcherAdded(_watcher);\n  }\n\n  /**\n   * @dev Owner can unenroll a watcher (abilities are defined by inheriting contracts)\n   */\n  function removeWatcher(address _watcher) external onlyOwner {\n    require(isWatcher[_watcher], \"!exist\");\n    delete isWatcher[_watcher];\n    emit WatcherRemoved(_watcher);\n  }\n\n  /**\n   * @notice Remove ability to renounce ownership\n   * @dev Renounce ownership should be impossible as long as the watcher griefing\n   * vector exists. You can still propose `address(0)`, but it will never be accepted.\n   */\n  function renounceOwnership() public virtual override onlyOwner {\n    require(false, \"prohibited\");\n  }\n}\n"
    },
    "contracts/messaging/connectors/Connector.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport {ProposedOwnable} from \"../../shared/ProposedOwnable.sol\";\nimport {IConnector} from \"../interfaces/IConnector.sol\";\n\n/**\n * @title Connector\n * @author Connext Labs, Inc.\n * @notice This contract has the messaging interface functions used by all connectors.\n *\n * @dev This contract stores information about mirror connectors, but can be used as a\n * base for contracts that do not have a mirror (i.e. the connector handling messaging on\n * mainnet). In this case, the `mirrorConnector` and `MIRROR_DOMAIN`\n * will be empty\n *\n * @dev If ownership is renounced, this contract will be unable to update its `mirrorConnector`\n * or `mirrorGas`\n */\nabstract contract Connector is ProposedOwnable, IConnector {\n  // ========== Custom Errors ===========\n\n  error Connector__processMessage_notUsed();\n\n  // ============ Events ============\n\n  event NewConnector(\n    uint32 indexed domain,\n    uint32 indexed mirrorDomain,\n    address amb,\n    address rootManager,\n    address mirrorConnector\n  );\n\n  event MirrorConnectorUpdated(address previous, address current);\n\n  /**\n   * @notice Emitted when funds are withdrawn by the admin\n   * @dev See comments in `withdrawFunds`\n   * @param to The recipient of the funds\n   * @param amount The amount withdrawn\n   */\n  event FundsWithdrawn(address indexed to, uint256 amount);\n\n  // ============ Public Storage ============\n\n  /**\n   * @notice The domain of this Messaging (i.e. Connector) contract.\n   */\n  uint32 public immutable DOMAIN;\n\n  /**\n   * @notice Address of the AMB on this domain.\n   */\n  address public immutable AMB;\n\n  /**\n   * @notice RootManager contract address.\n   */\n  address public immutable ROOT_MANAGER;\n\n  /**\n   * @notice The domain of the corresponding messaging (i.e. Connector) contract.\n   */\n  uint32 public immutable MIRROR_DOMAIN;\n\n  /**\n   * @notice Connector on L2 for L1 connectors, and vice versa.\n   */\n  address public mirrorConnector;\n\n  // ============ Modifiers ============\n\n  /**\n   * @notice Errors if the msg.sender is not the registered AMB\n   */\n  modifier onlyAMB() {\n    require(msg.sender == AMB, \"!AMB\");\n    _;\n  }\n\n  /**\n   * @notice Errors if the msg.sender is not the registered ROOT_MANAGER\n   */\n  modifier onlyRootManager() {\n    // NOTE: RootManager will be zero address for spoke connectors.\n    // Only root manager can dispatch a message to spokes/L2s via the hub connector.\n    require(msg.sender == ROOT_MANAGER, \"!rootManager\");\n    _;\n  }\n\n  // ============ Constructor ============\n\n  /**\n   * @notice Creates a new HubConnector instance\n   * @dev The connectors are deployed such that there is one on each side of an AMB (i.e.\n   * for optimism, there is one connector on optimism and one connector on mainnet)\n   * @param _domain The domain this connector lives on\n   * @param _mirrorDomain The spoke domain\n   * @param _amb The address of the amb on the domain this connector lives on\n   * @param _rootManager The address of the RootManager on mainnet\n   * @param _mirrorConnector The address of the spoke connector\n   */\n  constructor(\n    uint32 _domain,\n    uint32 _mirrorDomain,\n    address _amb,\n    address _rootManager,\n    address _mirrorConnector\n  ) ProposedOwnable() {\n    // set the owner\n    _setOwner(msg.sender);\n\n    // sanity checks on values\n    require(_domain != 0, \"empty domain\");\n    require(_rootManager != address(0), \"empty rootManager\");\n    // see note at top of contract on why the mirror values are not sanity checked\n\n    // set immutables\n    DOMAIN = _domain;\n    AMB = _amb;\n    ROOT_MANAGER = _rootManager;\n    MIRROR_DOMAIN = _mirrorDomain;\n    // set mutables if defined\n    if (_mirrorConnector != address(0)) {\n      _setMirrorConnector(_mirrorConnector);\n    }\n\n    emit NewConnector(_domain, _mirrorDomain, _amb, _rootManager, _mirrorConnector);\n  }\n\n  // ============ Receivable ============\n  /**\n   * @notice Connectors may need to receive native asset to handle fees when sending a\n   * message\n   */\n  receive() external payable {}\n\n  // ============ Admin Functions ============\n\n  /**\n   * @notice Sets the address of the l2Connector for this domain\n   */\n  function setMirrorConnector(address _mirrorConnector) public onlyOwner {\n    _setMirrorConnector(_mirrorConnector);\n  }\n\n  /**\n   * @notice This function should be callable by owner, and send funds trapped on\n   * a connector to the provided recipient.\n   * @dev Withdraws the entire balance of the contract.\n   *\n   * @param _to The recipient of the funds withdrawn\n   */\n  function withdrawFunds(address _to) public onlyOwner {\n    uint256 amount = address(this).balance;\n    Address.sendValue(payable(_to), amount);\n    emit FundsWithdrawn(_to, amount);\n  }\n\n  // ============ Public Functions ============\n\n  /**\n   * @notice Processes a message received by an AMB\n   * @dev This is called by AMBs to process messages originating from mirror connector\n   */\n  function processMessage(bytes memory _data) external virtual onlyAMB {\n    _processMessage(_data);\n    emit MessageProcessed(_data, msg.sender);\n  }\n\n  /**\n   * @notice Checks the cross domain sender for a given address\n   */\n  function verifySender(address _expected) external returns (bool) {\n    return _verifySender(_expected);\n  }\n\n  // ============ Virtual Functions ============\n\n  /**\n   * @notice This function is used by the Connext contract on the l2 domain to send a message to the\n   * l1 domain (i.e. called by Connext on optimism to send a message to mainnet with roots)\n   * @param _data The contents of the message\n   * @param _encodedData Data used to send the message; specific to connector\n   */\n  function _sendMessage(bytes memory _data, bytes memory _encodedData) internal virtual;\n\n  /**\n   * @notice This function is used by the AMBs to handle incoming messages. Should store the latest\n   * root generated on the l2 domain.\n   */\n  function _processMessage(\n    bytes memory /* _data */\n  ) internal virtual {\n    // By default, reverts. This is to ensure the call path is not used unless this function is\n    // overridden by the inheriting class\n    revert Connector__processMessage_notUsed();\n  }\n\n  /**\n   * @notice Verify that the msg.sender is the correct AMB contract, and that the message's origin sender\n   * is the expected address.\n   * @dev Should be overridden by the implementing Connector contract.\n   */\n  function _verifySender(address _expected) internal virtual returns (bool);\n\n  // ============ Private Functions ============\n\n  function _setMirrorConnector(address _mirrorConnector) internal virtual {\n    emit MirrorConnectorUpdated(mirrorConnector, _mirrorConnector);\n    mirrorConnector = _mirrorConnector;\n  }\n}\n"
    },
    "contracts/messaging/connectors/ConnectorManager.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {IConnectorManager} from \"../interfaces/IConnectorManager.sol\";\nimport {IOutbox} from \"../interfaces/IOutbox.sol\";\n\n/**\n * @notice This is an interface to allow the `Messaging` contract to be used\n * as a `XappConnectionManager` on all router contracts.\n *\n * @dev Each nomad router contract has a `XappConnectionClient`, which references a\n * XappConnectionManager to get the `Home` (outbox) and approved `Replica` (inbox)\n * instances. At any point the client can replace the manager it's pointing to,\n * changing the underlying messaging connection.\n */\nabstract contract ConnectorManager is IConnectorManager {\n  constructor() {}\n\n  function home() public view returns (IOutbox) {\n    return IOutbox(address(this));\n  }\n\n  function isReplica(address _potentialReplica) public view returns (bool) {\n    return _potentialReplica == address(this);\n  }\n\n  function localDomain() external view virtual returns (uint32);\n}\n"
    },
    "contracts/messaging/connectors/SpokeConnector.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport {TypedMemView} from \"../../shared/libraries/TypedMemView.sol\";\nimport {ExcessivelySafeCall} from \"../../shared/libraries/ExcessivelySafeCall.sol\";\nimport {TypeCasts} from \"../../shared/libraries/TypeCasts.sol\";\n\nimport {MerkleLib} from \"../libraries/MerkleLib.sol\";\nimport {Message} from \"../libraries/Message.sol\";\nimport {RateLimited} from \"../libraries/RateLimited.sol\";\nimport {SnapshotId} from \"../libraries/SnapshotId.sol\";\n\nimport {MerkleTreeManager} from \"../MerkleTreeManager.sol\";\nimport {WatcherClient} from \"../WatcherClient.sol\";\n\nimport {Connector, ProposedOwnable} from \"./Connector.sol\";\nimport {ConnectorManager} from \"./ConnectorManager.sol\";\n\n/**\n * @title SpokeConnector\n * @author Connext Labs, Inc.\n * @notice This contract implements the messaging functions needed on the spoke-side of a given AMB.\n * The SpokeConnector extends the Connector functionality by being able to send, store, and prove\n * messages.\n *\n * @dev If you are deploying this contract to mainnet, then the mirror values stored in the HubConnector\n * will be unused\n */\nabstract contract SpokeConnector is Connector, ConnectorManager, WatcherClient, RateLimited, ReentrancyGuard {\n  // ============ Libraries ============\n\n  using MerkleLib for MerkleLib.Tree;\n  using TypedMemView for bytes;\n  using TypedMemView for bytes29;\n  using Message for bytes29;\n\n  // ============ Events ============\n\n  /**\n   * @notice Emitted when a new sender is whitelisted for messaging\n   * @param sender Whitelisted address\n   */\n  event SenderAdded(address indexed sender);\n\n  /**\n   * @notice Emitted when a new sender is de-whitelisted for messaging\n   * @param sender Removed address\n   */\n  event SenderRemoved(address indexed sender);\n\n  /**\n   * @notice Emitted when a new proposer is added\n   * @param proposer The address of the proposer\n   */\n  event ProposerAdded(address indexed proposer);\n\n  /**\n   * @notice Emitted when a proposer is removed\n   * @param proposer The address of the proposer\n   */\n  event ProposerRemoved(address indexed proposer);\n\n  /**\n   * @notice Emitted when a new aggregate root is delivered from the hub\n   * @param root Delivered root\n   */\n  event AggregateRootReceived(bytes32 indexed root);\n\n  /**\n   * @notice Emitted when a proposed aggregate root is removed by admin\n   * @param root Removed root\n   */\n  event AggregateRootRemoved(bytes32 indexed root);\n\n  /**\n   * @notice Emitted when an aggregate root has made it through the fraud period\n   * without being disputed\n   * @param root Newly verified root\n   */\n  event AggregateRootVerified(bytes32 indexed root);\n\n  /**\n   * @notice Emitted when a message is sent (leaf added to outbound root)\n   * @param leaf The hash added to tree\n   * @param index The index of the leaf\n   * @param root The updated outbound root after insertion\n   * @param message The raw message body\n   */\n  event Dispatch(bytes32 indexed leaf, uint256 indexed index, bytes32 indexed root, bytes message);\n\n  /**\n   * @notice Emitted when a message is handled (this is the destination domain)\n   * @param leaf The leaf processed\n   * @param success Whether `handle` call on recipient is successful\n   * @param returnData The data returned from the `handle` call on recipient\n   */\n  event Process(bytes32 indexed leaf, bool success, bytes returnData);\n\n  /**\n   * @notice Emitted when the admin updates the delay blocks\n   * @param updated The new delay blocks\n   * @param caller The msg.sender of transaction\n   */\n  event DelayBlocksUpdated(uint256 indexed updated, address caller);\n\n  event SnapshotRootSaved(uint256 indexed snapshotId, bytes32 indexed root, uint256 indexed count);\n\n  /**\n   * @notice Emitted when a message (outbound root from different spoke) is proven\n   * against the aggregate root\n   * @param leaf The proven leaf\n   * @param aggregateRoot The root the leaf was proven against\n   * @param aggregateIndex Position of leaf in the aggregate root\n   */\n  event MessageProven(bytes32 indexed leaf, bytes32 indexed aggregateRoot, uint256 aggregateIndex);\n\n  /**\n   * @notice Emitted when slow mode is activated\n   * @param watcher The address of the watcher who called the function\n   */\n  event SlowModeActivated(address indexed watcher);\n\n  /**\n   * @notice Emitted when optimistic mode is activated\n   */\n  event OptimisticModeActivated();\n\n  /**\n   * @notice Emitted when a new aggregate root is proposed\n   * @param aggregateRoot The new aggregate root proposed\n   * @param endOfDispute  The block at which this root can't be disputed anymore and therefore it's deemed valid.\n   * @param rootTimestamp The timestamp at which the root was finalized in the root manager contract.\n   * @param domain        The domain where this root was proposed.\n   */\n  event AggregateRootProposed(\n    bytes32 indexed aggregateRoot,\n    uint256 indexed rootTimestamp,\n    uint256 indexed endOfDispute,\n    uint32 domain\n  );\n\n  /**\n   * @notice Emitted when a pending aggregate root is deleted from the pendingAggregateRoots mapping\n   * @param aggregateRoot The deleted aggregate root\n   */\n  event PendingAggregateRootDeleted(bytes32 indexed aggregateRoot);\n\n  /**\n   * @notice Emitted when the current proposed root is finalized\n   * @param aggregateRoot The aggregate root finalized\n   */\n  event ProposedRootFinalized(bytes32 aggregateRoot);\n\n  /**\n   * @notice Emitted when the number of dispute blocks is updated\n   * @param previous The previous number of blocks off-chain agents had to dispute a proposed root\n   * @param updated  The new number of blocks off-chain agents have to dispute a proposed root\n   */\n  event DisputeBlocksUpdated(uint256 previous, uint256 updated);\n\n  /**\n   * @notice Emitted whem the number of minimum dispute blocks is updated\n   * @param previous The previous minimum number of dispute blocks to set\n   * @param updated  The new minimum number of dispute blocks to set\n   */\n  event MinDisputeBlocksUpdated(uint256 previous, uint256 updated);\n\n  // ============ Errors ============\n\n  error SpokeConnector_onlyOptimisticMode__SlowModeOn();\n  error SpokeConnector_activateOptimisticMode__OptimisticModeOn();\n  error SpokeConnector_onlyProposer__NotAllowlistedProposer();\n  error SpokeConnector_proposeAggregateRoot__ProposeInProgress();\n  error SpokeConnector_finalize__ProposeInProgress();\n  error SpokeConnector_finalize__InvalidInputHash();\n  error SpokeConnector_finalize__ProposedHashIsFinalizedHash();\n  error SpokeConnector_setMinDisputeBlocks__SameMinDisputeBlocksAsBefore();\n  error SpokeConnector_setDisputeBlocks__DisputeBlocksLowerThanMin();\n  error SpokeConnector_setDisputeBlocks__SameDisputeBlocksAsBefore();\n  error SpokeConnector_receiveAggregateRoot__OptimisticModeOn();\n  error SpokeConnector_constructor__DisputeBlocksLowerThanMin();\n\n  // ============ Structs ============\n\n  /**\n   * Struct for submitting a proof for a given message. Used in `proveAndProcess` below.\n   * @param message Bytes of message to be processed. The hash of this message is considered the leaf.\n   * @param path Path in tree for given leaf.\n   * @param index Index of leaf in home's merkle tree.\n   */\n  struct Proof {\n    bytes message;\n    bytes32[32] path;\n    uint256 index;\n  }\n\n  /**\n   * Struct containing the base construstor arguments of a SpokeConnector\n   * @param domain The domain this connector lives on.\n   * @param mirrorDomain The hub domain.\n   * @param amb The address of the AMB on the spoke domain this connector lives on.\n   * @param rootManager The address of the RootManager on the hub.\n   * @param mirrorConnector The address of the spoke connector.\n   * @param processGas The gas costs used in `handle` to ensure meaningful state changes can occur (minimum gas needed\n   * to handle transaction).\n   * @param reserveGas The gas costs reserved when `handle` is called to ensure failures are handled.\n   * @param delayBlocks The delay for the validation period for incoming messages in blocks.\n   * @param merkle The address of the MerkleTreeManager on this spoke domain.\n   * @param watcherManager The address of the WatcherManager to whom this connector is a client.\n   * @param minDisputeBlocks The minimum number of dispute blocks that can be set.\n   * @param disputeBlocks The number of dispute blocks off-chain agents will have to dispute proposed roots.\n   */\n  struct ConstructorParams {\n    uint32 domain;\n    uint32 mirrorDomain;\n    address amb;\n    address rootManager;\n    address mirrorConnector;\n    uint256 processGas;\n    uint256 reserveGas;\n    uint256 delayBlocks;\n    address merkle;\n    address watcherManager;\n    uint256 minDisputeBlocks;\n    uint256 disputeBlocks;\n  }\n\n  // ============ Public Storage ============\n\n  /**\n   * @notice Number of blocks to delay the processing of a message to allow for watchers to verify\n   * the validity and pause if necessary.\n   */\n  uint256 public delayBlocks;\n\n  /**\n   * @notice MerkleTreeManager contract instance. Will hold the active tree of message hashes, whose root\n   * will be sent crosschain to the hub for aggregation and redistribution.\n   */\n  MerkleTreeManager public immutable MERKLE;\n\n  /**\n   * @notice Minimum gas for processing a received message (reserved for handle)\n   */\n  uint256 public immutable PROCESS_GAS;\n\n  /**\n   * @notice Reserved gas (to ensure tx completes in case message processing runs out)\n   */\n  uint256 public immutable RESERVE_GAS;\n\n  /**\n   * @notice This will hold the commit block for incoming aggregateRoots from the hub chain. Once\n   * they are verified, (i.e. have surpassed the verification period in `delayBlocks`) they can\n   * be used for proving inclusion of crosschain messages.\n   *\n   * @dev NOTE: A commit block of 0 should be considered invalid (it is an empty entry in the\n   * mapping). We must ALWAYS ensure the value is not 0 before checking whether it has surpassed the\n   * verification period.\n   */\n  mapping(bytes32 => uint256) public pendingAggregateRoots;\n\n  /**\n   * @notice This tracks the roots of the aggregate tree containing outbound roots from all other\n   * supported domains. The current version is the one that is known to be past the delayBlocks\n   * time period.\n   * @dev This root is the root of the tree that is aggregated on mainnet (composed of all the roots\n   * of previous trees).\n   */\n  mapping(bytes32 => bool) public provenAggregateRoots;\n\n  /**\n   * @notice This tracks whether the root has been proven to exist within the given aggregate root.\n   * @dev Tracking this is an optimization so you dont have to prove inclusion of the same constituent\n   * root many times.\n   */\n  mapping(bytes32 => bool) public provenMessageRoots;\n\n  /**\n   * @notice This mapping records all message roots that have already been sent in order to prevent\n   * redundant message roots from being sent to hub.\n   */\n  mapping(bytes32 => bool) public sentMessageRoots;\n\n  /**\n   * @notice Records all whitelisted senders\n   * @dev This is used for the `onlyAllowlistedSender` modifier, which gates who\n   * can send messages using `dispatch`.\n   */\n  mapping(address => bool) public allowlistedSenders;\n\n  /**\n   * @notice Mapping of the snapshot roots for a specific index. Used for data availability for off-chain scripts\n   */\n  mapping(uint256 => bytes32) public snapshotRoots;\n\n  /**\n   * @notice The resulting hash of keccaking the proposed aggregate root, the timestamp at which it was finalized in the root manager\n   *      and the block at which the time to dispute it ends.\n   * @dev Set to 0x1 to prevent someone from calling finalize() the moment the contract is deployed.\n   */\n  bytes32 public proposedAggregateRootHash = 0x0000000000000000000000000000000000000000000000000000000000000001;\n\n  /*\n    @notice The number of blocks off-chain agents have to dispute a given proposal.\n  */\n  uint256 public disputeBlocks;\n\n  /**\n   * @notice The minimum number of blocks disputeBlocks can be set to.\n   */\n  uint256 public minDisputeBlocks;\n\n  /**\n   * @notice Hash used to keep the proposal slot warm once a given proposal has been finalized.\n   * @dev It also represents the empty state. This means if a proposal holds this hash, it's deemed empty.\n   */\n  bytes32 public constant FINALIZED_HASH = 0x0000000000000000000000000000000000000000000000000000000000000001;\n\n  /**\n   * @notice True if the system is working in optimistic mode. Otherwise is working in slow mode\n   */\n  bool public optimisticMode;\n\n  /**\n   * @notice This is used for the `onlyProposers` modifier, which gates who\n   * can propose new roots using `proposeAggregateRoot`.\n   */\n  mapping(address => bool) public allowlistedProposers;\n\n  // ============ Modifiers ============\n\n  /**\n   * @notice Ensures the msg.sender is allowlisted\n   */\n  modifier onlyAllowlistedSender() {\n    require(allowlistedSenders[msg.sender], \"!allowlisted\");\n    _;\n  }\n\n  /**\n   * @notice Ensures the msg.sender is an allowlisted proposer\n   */\n  modifier onlyAllowlistedProposer() {\n    if (!allowlistedProposers[msg.sender]) revert SpokeConnector_onlyProposer__NotAllowlistedProposer();\n    _;\n  }\n\n  /**\n   * @notice Checks if this spoke connector is working in optimistic mode\n   */\n  modifier onlyOptimisticMode() {\n    if (!optimisticMode) revert SpokeConnector_onlyOptimisticMode__SlowModeOn();\n    _;\n  }\n\n  // ============ Constructor ============\n\n  /**\n   * @notice Creates a new SpokeConnector instance.\n   * @param _params The constructor parameters.\n   */\n  constructor(\n    ConstructorParams memory _params\n  )\n    ConnectorManager()\n    Connector(_params.domain, _params.mirrorDomain, _params.amb, _params.rootManager, _params.mirrorConnector)\n    WatcherClient(_params.watcherManager)\n  {\n    uint256 _disputeBlocks = _params.disputeBlocks;\n    uint256 _minDisputeBlocks = _params.minDisputeBlocks;\n    if (_disputeBlocks < _minDisputeBlocks) revert SpokeConnector_constructor__DisputeBlocksLowerThanMin();\n    // Sanity check: constants are reasonable.\n    require(_params.processGas > 850_000 - 1, \"!process gas\");\n    require(_params.reserveGas > 15_000 - 1, \"!reserve gas\");\n    PROCESS_GAS = _params.processGas;\n    RESERVE_GAS = _params.reserveGas;\n\n    require(_params.merkle != address(0), \"!zero merkle\");\n    MERKLE = MerkleTreeManager(_params.merkle);\n\n    delayBlocks = _params.delayBlocks;\n    minDisputeBlocks = _minDisputeBlocks;\n    disputeBlocks = _disputeBlocks;\n  }\n\n  // ============ Admin Functions ============\n\n  /**\n   * @notice Adds a sender to the allowlist.\n   * @dev Only allowlisted routers (senders) can call `dispatch`.\n   * @param _sender Sender to whitelist\n   */\n  function addSender(address _sender) external onlyOwner {\n    require(!allowlistedSenders[_sender], \"allowed\");\n    allowlistedSenders[_sender] = true;\n    emit SenderAdded(_sender);\n  }\n\n  /**\n   * @notice Removes a sender from the allowlist.\n   * @dev Only allowlisted routers (senders) can call `dispatch`.\n   * @param _sender Sender to remove from whitelist\n   */\n  function removeSender(address _sender) external onlyOwner {\n    require(allowlistedSenders[_sender], \"!allowed\");\n    delete allowlistedSenders[_sender];\n    emit SenderRemoved(_sender);\n  }\n\n  /**\n   * @notice Adds a proposer to the allowlist.\n   * @dev Only allowlisted proposers can call `proposeAggregateRoot`.\n   */\n  function addProposer(address _proposer) external onlyOwner {\n    allowlistedProposers[_proposer] = true;\n    emit ProposerAdded(_proposer);\n  }\n\n  /**\n   * @notice Removes a proposer from the allowlist.\n   * @dev Only allowlisted proposers can call `proposeAggregateRoot`.\n   */\n  function removeProposer(address _proposer) external onlyOwner {\n    delete allowlistedProposers[_proposer];\n    emit ProposerRemoved(_proposer);\n  }\n\n  /**\n   * @notice Set the `minDisputeBlocks` variable to the provided parameter.\n   */\n  function setMinDisputeBlocks(uint256 _minDisputeBlocks) external onlyOwner {\n    if (_minDisputeBlocks == minDisputeBlocks)\n      revert SpokeConnector_setMinDisputeBlocks__SameMinDisputeBlocksAsBefore();\n    emit MinDisputeBlocksUpdated(minDisputeBlocks, _minDisputeBlocks);\n    minDisputeBlocks = _minDisputeBlocks;\n  }\n\n  /**\n   * @notice Set the `disputeBlocks`, the duration, in blocks, of the dispute process for\n   * a given proposed root\n   */\n  function setDisputeBlocks(uint256 _disputeBlocks) external onlyOwner {\n    if (_disputeBlocks < minDisputeBlocks) revert SpokeConnector_setDisputeBlocks__DisputeBlocksLowerThanMin();\n    if (_disputeBlocks == disputeBlocks) revert SpokeConnector_setDisputeBlocks__SameDisputeBlocksAsBefore();\n    emit DisputeBlocksUpdated(disputeBlocks, _disputeBlocks);\n    disputeBlocks = _disputeBlocks;\n  }\n\n  /**\n   * @notice Set the `delayBlocks`, the period in blocks over which an incoming message\n   * is verified.\n   * @param _delayBlocks Updated delay block value\n   */\n  function setDelayBlocks(uint256 _delayBlocks) external onlyOwner {\n    require(_delayBlocks != delayBlocks, \"!delayBlocks\");\n    emit DelayBlocksUpdated(_delayBlocks, msg.sender);\n    delayBlocks = _delayBlocks;\n  }\n\n  /**\n   * @notice Set the rate limit (number of blocks) at which we can send messages from\n   * this contract to the hub chain using the `send` method.\n   * @dev Rate limit is used to mitigate DoS vectors. (See `RateLimited` for more info.)\n   * @param _rateLimit The number of blocks require between sending messages. If set to\n   * 0, rate limiting for this spoke connector will be disabled.\n   */\n  function setRateLimitBlocks(uint256 _rateLimit) external onlyOwner {\n    _setRateLimitBlocks(_rateLimit);\n  }\n\n  /**\n   * @notice Manually remove a pending aggregateRoot by owner if the contract is paused.\n   * @dev This method is required for handling fraud cases in the current construction. Specifically,\n   * this will protect against a fraudulent aggregate root getting transported, not fraudulent\n   * roots that constitute a given aggregate root (i.e. can protect against fraudulent\n   * hub -> spoke transport, not spoke -> hub transport).\n   * @param _fraudulentRoot Target fraudulent root that should be erased from the\n   * `pendingAggregateRoots` mapping.\n   */\n  function removePendingAggregateRoot(bytes32 _fraudulentRoot) external onlyOwner whenPaused {\n    // Sanity check: pending aggregate root exists.\n    require(pendingAggregateRoots[_fraudulentRoot] != 0, \"aggregateRoot !exists\");\n    delete pendingAggregateRoots[_fraudulentRoot];\n    emit AggregateRootRemoved(_fraudulentRoot);\n  }\n\n  /**\n   * @notice Remove ability to renounce ownership\n   * @dev Renounce ownership should be impossible as long as it is impossible in the\n   * WatcherClient, and as long as only the owner can remove pending roots in case of\n   * fraud.\n   */\n  function renounceOwnership() public virtual override(ProposedOwnable, WatcherClient) onlyOwner {\n    require(false, \"prohibited\");\n  }\n\n  /**\n   * @notice Watcher can set the system in slow mode.\n   * @dev Sets the proposed aggregate root hash to FINALIZED_HASH, invalidating it.\n   */\n  function activateSlowMode() external onlyWatcher onlyOptimisticMode {\n    optimisticMode = false;\n    proposedAggregateRootHash = FINALIZED_HASH;\n    emit SlowModeActivated(msg.sender);\n  }\n\n  /**\n   * @notice Owner can set the system to optimistic mode.\n   */\n  function activateOptimisticMode() external onlyOwner {\n    if (optimisticMode) revert SpokeConnector_activateOptimisticMode__OptimisticModeOn();\n    optimisticMode = true;\n    emit OptimisticModeActivated();\n  }\n\n  // ============ Public Functions ============\n\n  /**\n   * @notice This returns the root of all messages with the origin domain as this domain (i.e.\n   * all outbound messages)\n   */\n  function outboundRoot() external view returns (bytes32) {\n    return MERKLE.root();\n  }\n\n  /**\n   * @notice This provides the implementation for what is defined in the ConnectorManager\n   * to avoid storing the domain redundantly\n   */\n  function localDomain() external view override returns (uint32) {\n    return DOMAIN;\n  }\n\n  /**\n   * @notice This dispatches outbound root to hub via AMB\n   * @param _encodedData Data needed to send crosschain message by associated amb\n   */\n  function send(bytes memory _encodedData) external payable virtual whenNotPaused rateLimited {\n    bytes32 root = MERKLE.root();\n    require(sentMessageRoots[root] == false, \"root already sent\");\n    // mark as sent\n    sentMessageRoots[root] = true;\n\n    // call internal function\n    _sendRoot(root, _encodedData);\n  }\n\n  /**\n   * @notice This function adds transfers to the outbound transfer merkle tree.\n   * @dev The root of this tree will eventually be dispatched to mainnet via `send`. On mainnet (the \"hub\"),\n   * it will be combined into a single aggregate root by RootManager (along with outbound roots from other\n   * chains). This aggregate root will be redistributed to all destination chains.\n   * @dev This function is also in charge of saving the snapshot root when needed. If the message being added to the\n   * tree is the first of the current period this means the last snapshot finished and its root must be saved. The saving\n   * happens before adding the new message to the tree.\n   *\n   * NOTE: okay to leave dispatch operational when paused as pause is designed for crosschain interactions\n   * @param _destinationDomain Domain message is intended for\n   * @param _recipientAddress Address for message recipient\n   * @param _messageBody Message contents\n   */\n  function dispatch(\n    uint32 _destinationDomain,\n    bytes32 _recipientAddress,\n    bytes memory _messageBody\n  ) external onlyAllowlistedSender returns (bytes32, bytes memory) {\n    // Before inserting the new message to the tree we need to check if the last snapshot root must be calculated and set.\n    uint256 _lastCompletedSnapshotId = SnapshotId.getLastCompletedSnapshotId();\n    if (snapshotRoots[_lastCompletedSnapshotId] == 0) {\n      // Saves current tree root as last snapshot root before adding the new message.\n      bytes32 _currentRoot = MERKLE.root();\n      snapshotRoots[_lastCompletedSnapshotId] = _currentRoot;\n      emit SnapshotRootSaved(_lastCompletedSnapshotId, _currentRoot, MERKLE.count());\n    }\n\n    // Get the next nonce for the destination domain, then increment it.\n    uint32 _nonce = MERKLE.incrementNonce(_destinationDomain);\n\n    // Format the message into packed bytes.\n    bytes memory _message = Message.formatMessage(\n      DOMAIN,\n      TypeCasts.addressToBytes32(msg.sender),\n      _nonce,\n      _destinationDomain,\n      _recipientAddress,\n      _messageBody\n    );\n\n    // Insert the hashed message into the Merkle tree.\n    bytes32 _messageHash = keccak256(_message);\n\n    // Returns the root calculated after insertion of message, needed for events for\n    // watchers\n    (bytes32 _root, uint256 _count) = MERKLE.insert(_messageHash);\n\n    // Emit Dispatch event with message information.\n    // NOTE: Current leaf index is count - 1 since new leaf has already been inserted.\n    emit Dispatch(_messageHash, _count - 1, _root, _message);\n    return (_messageHash, _message);\n  }\n\n  /**\n   * @notice Propose a new aggregate root\n   * @dev _rootTimestamp is required for off-chain agents to be able to know which root they should fetch from the root manager contract\n   *                     in order to compare it with the one being proposed. The off-chain agents should also ensure the proposed root is\n   *                     not an old one.\n   * @param _aggregateRoot The aggregate root to propose.\n   * @param _rootTimestamp Block.timestamp at which the root was finalized in the root manager contract.\n   */\n  function proposeAggregateRoot(\n    bytes32 _aggregateRoot,\n    uint256 _rootTimestamp\n  ) external virtual whenNotPaused onlyAllowlistedProposer onlyOptimisticMode {\n    if (proposedAggregateRootHash != FINALIZED_HASH) revert SpokeConnector_proposeAggregateRoot__ProposeInProgress();\n    if (pendingAggregateRoots[_aggregateRoot] != 0) {\n      delete pendingAggregateRoots[_aggregateRoot];\n      emit PendingAggregateRootDeleted(_aggregateRoot);\n    }\n\n    uint256 _endOfDispute = block.number + disputeBlocks;\n    proposedAggregateRootHash = keccak256(abi.encode(_aggregateRoot, _rootTimestamp, _endOfDispute));\n\n    emit AggregateRootProposed(_aggregateRoot, _rootTimestamp, _endOfDispute, DOMAIN);\n  }\n\n  /**\n   * @notice Finalizes the proposed aggregate root. This confirms the root validity. Therefore, it can be proved and processed.\n   * @dev Finalized roots won't be monitored by off-chain agents as they are deemed valid.\n   *\n   * @param _proposedAggregateRoot The aggregate root currently proposed\n   * @param _endOfDispute          The block in which the dispute period for proposedAggregateRootHash concludes\n   */\n  function finalize(\n    bytes32 _proposedAggregateRoot,\n    uint256 _rootTimestamp,\n    uint256 _endOfDispute\n  ) external virtual whenNotPaused onlyOptimisticMode {\n    if (_endOfDispute > block.number) revert SpokeConnector_finalize__ProposeInProgress();\n\n    bytes32 _proposedAggregateRootHash = proposedAggregateRootHash;\n    if (_proposedAggregateRootHash == FINALIZED_HASH) revert SpokeConnector_finalize__ProposedHashIsFinalizedHash();\n\n    bytes32 _userInputHash = keccak256(abi.encode(_proposedAggregateRoot, _rootTimestamp, _endOfDispute));\n    if (_userInputHash != _proposedAggregateRootHash) revert SpokeConnector_finalize__InvalidInputHash();\n\n    provenAggregateRoots[_proposedAggregateRoot] = true;\n    proposedAggregateRootHash = FINALIZED_HASH;\n\n    emit ProposedRootFinalized(_proposedAggregateRoot);\n  }\n\n  /**\n   * @notice Must be able to call the `handle` function on the BridgeRouter contract. This is called\n   * on the destination domain to handle incoming messages.\n   *\n   * Proving:\n   * Calculates the expected inbound root from an origin chain given a leaf (message hash),\n   * the index of the leaf, and the merkle proof of inclusion (path). Next, we check to ensure that this\n   * calculated inbound root is included in the current aggregateRoot, given its index in the aggregator\n   * tree and the proof of inclusion.\n   *\n   * Processing:\n   * After all messages have been proven, we dispatch each message to Connext (BridgeRouter) for\n   * execution.\n   *\n   * @dev Currently, ALL messages in a given batch must path to the same shared inboundRoot, meaning they\n   * must all share an origin. See open TODO below for a potential solution to enable multi-origin batches.\n   * @dev Intended to be called by the relayer at specific intervals during runtime.\n   * @dev Will record a calculated root as having been proven if we've already proven that it was included\n   * in the aggregateRoot.\n   *\n   * @param _proofs Batch of Proofs containing messages for proving/processing.\n   * @param _aggregateRoot The target aggregate root we want to prove inclusion for. This root must have\n   * already been delivered to this spoke connector contract and surpassed the validation period.\n   * @param _aggregatePath Merkle path of inclusion for the inbound root.\n   * @param _aggregateIndex Index of the inbound root in the aggregator's merkle tree in the hub.\n   */\n  function proveAndProcess(\n    Proof[] calldata _proofs,\n    bytes32 _aggregateRoot,\n    bytes32[32] calldata _aggregatePath,\n    uint256 _aggregateIndex\n  ) external whenNotPaused nonReentrant {\n    // Sanity check: proofs are included.\n    require(_proofs.length > 0, \"!proofs\");\n\n    // Optimization: calculate the inbound root for the first message in the batch and validate that\n    // it's included in the aggregator tree. We can use this as a reference for every calculation\n    // below to minimize storage access calls.\n    bytes32 _messageHash = keccak256(_proofs[0].message);\n    // TODO: Could use an array of sharedRoots so you can submit a message batch of messages with\n    // different origins.\n    bytes32 _messageRoot = calculateMessageRoot(_messageHash, _proofs[0].path, _proofs[0].index);\n\n    // Handle proving this message root is included in the target aggregate root.\n    proveMessageRoot(_messageRoot, _aggregateRoot, _aggregatePath, _aggregateIndex);\n    // Assuming the inbound message root was proven, the first message is now considered proven.\n    MERKLE.markAsProven(_messageHash);\n\n    // Now we handle proving all remaining messages in the batch - they should all share the same\n    // inbound root!\n    uint256 len = _proofs.length;\n    for (uint32 i = 1; i < len; ) {\n      _messageHash = keccak256(_proofs[i].message);\n      bytes32 _calculatedRoot = calculateMessageRoot(_messageHash, _proofs[i].path, _proofs[i].index);\n      // Make sure this root matches the validated inbound root.\n      require(_calculatedRoot == _messageRoot, \"!sharedRoot\");\n      // Message is proven!\n      MERKLE.markAsProven(_messageHash);\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    // All messages have been proven. We iterate separately here to process each message in the batch.\n    // NOTE: Going through the proving phase for all messages in the batch BEFORE processing ensures\n    // we hit reverts before we consume unbounded gas from `process` calls.\n    for (uint32 i = 0; i < len; ) {\n      process(_proofs[i].message);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @notice This function gets the last completed snapshot id\n   * @dev The value is calculated through an internal function to reuse code and save gas\n   * @return _lastCompletedSnapshotId The last completed snapshot id\n   */\n  function getLastCompletedSnapshotId() external view returns (uint256 _lastCompletedSnapshotId) {\n    _lastCompletedSnapshotId = SnapshotId.getLastCompletedSnapshotId();\n  }\n\n  /**\n   * @notice Get the duration of the snapshot\n   *\n   * @return _snapshotDuration The duration of the snapshot\n   */\n  function getSnapshotDuration() external pure returns (uint256 _snapshotDuration) {\n    _snapshotDuration = SnapshotId.SNAPSHOT_DURATION;\n  }\n\n  // ============ Private Functions ============\n\n  function _sendRoot(bytes32 _root, bytes memory _encodedData) internal {\n    // call internal function\n    bytes memory _data = abi.encodePacked(_root);\n    _sendMessage(_data, _encodedData);\n    emit MessageSent(_data, _encodedData, msg.sender);\n  }\n\n  /**\n   * @notice Called to accept aggregate root dispatched from the RootManager on the hub.\n   * @dev Must check the msg.sender on the origin chain to ensure only the root manager is passing\n   * these roots.\n   * @param _newRoot Received aggregate\n   */\n  function receiveAggregateRoot(bytes32 _newRoot) internal {\n    if (optimisticMode) revert SpokeConnector_receiveAggregateRoot__OptimisticModeOn();\n    require(_newRoot != bytes32(\"\"), \"new root empty\");\n    require(pendingAggregateRoots[_newRoot] == 0, \"root already pending\");\n    require(!provenAggregateRoots[_newRoot], \"root already proven\");\n\n    pendingAggregateRoots[_newRoot] = block.number;\n    emit AggregateRootReceived(_newRoot);\n  }\n\n  /**\n   * @notice Checks whether the given aggregate root has surpassed the verification period.\n   * @dev Reverts if the given aggregate root is invalid (does not exist) OR has not surpassed\n   * verification period.\n   * @dev If the target aggregate root is pending and HAS surpassed the verification period, then we will\n   * move it over to the proven mapping.\n   * @param _aggregateRoot Target aggregate root to verify.\n   */\n  function verifyAggregateRoot(bytes32 _aggregateRoot) internal {\n    // 0. Sanity check: root is not 0.\n    require(_aggregateRoot != bytes32(\"\"), \"aggregateRoot empty\");\n\n    // 1. Check to see if the target *aggregate* root has already been proven.\n    if (provenAggregateRoots[_aggregateRoot]) {\n      return; // Short circuit if this root is proven.\n    }\n\n    // 2. The target aggregate root must be pending. Aggregate root commit block entry MUST exist.\n    uint256 _aggregateRootCommitBlock = pendingAggregateRoots[_aggregateRoot];\n    require(_aggregateRootCommitBlock != 0, \"aggregateRoot !exist\");\n\n    // 3. Pending aggregate root has surpassed the `delayBlocks` verification period.\n    require(block.number - _aggregateRootCommitBlock >= delayBlocks, \"aggregateRoot !verified\");\n\n    // 4. The target aggregate root has surpassed verification period, we can move it over to the\n    // proven mapping.\n    provenAggregateRoots[_aggregateRoot] = true;\n    emit AggregateRootVerified(_aggregateRoot);\n    // May as well delete the pending aggregate root entry for the gas refund: it should no longer\n    // be needed.\n    delete pendingAggregateRoots[_aggregateRoot];\n  }\n\n  /**\n   * @notice Checks whether a given message is valid. If so, calculates the expected inbound root from an\n   * origin chain given a leaf (message hash), the index of the leaf, and the merkle proof of inclusion.\n   * @dev Reverts if message's LeafStatus != None (i.e. if message was already proven or processed).\n   *\n   * @param _messageHash Leaf (message hash) that requires proving.\n   * @param _messagePath Merkle path of inclusion for the leaf.\n   * @param _messageIndex Index of leaf in the merkle tree on the origin chain of the message.\n   * @return bytes32 Calculated root.\n   **/\n  function calculateMessageRoot(\n    bytes32 _messageHash,\n    bytes32[32] calldata _messagePath,\n    uint256 _messageIndex\n  ) internal view returns (bytes32) {\n    // Ensure that the given message has not already been proven and processed.\n    require(MERKLE.leaves(_messageHash) == MerkleTreeManager.LeafStatus.None, \"!LeafStatus.None\");\n    // Calculate the expected inbound root from the message origin based on the proof.\n    // NOTE: Assuming a valid message was submitted with correct path/index, this should be an inbound root\n    // that the hub has received. If the message were invalid, the root calculated here would not exist in the\n    // aggregate root.\n    return MerkleLib.branchRoot(_messageHash, _messagePath, _messageIndex);\n  }\n\n  /**\n   * @notice Prove an inbound message root from another chain is included in the target aggregateRoot.\n   * @param _messageRoot The message root we want to verify.\n   * @param _aggregateRoot The target aggregate root we want to prove inclusion for. This root must have\n   * already been delivered to this spoke connector contract and surpassed the validation period.\n   * @param _aggregatePath Merkle path of inclusion for the inbound root.\n   * @param _aggregateIndex Index of the inbound root in the aggregator's merkle tree in the hub.\n   */\n  function proveMessageRoot(\n    bytes32 _messageRoot,\n    bytes32 _aggregateRoot,\n    bytes32[32] calldata _aggregatePath,\n    uint256 _aggregateIndex\n  ) internal {\n    // 0. Check to see if the root for this batch has already been proven.\n    if (provenMessageRoots[_messageRoot]) {\n      // NOTE: It seems counter-intuitive, but we do NOT need to prove the given `_aggregateRoot` param\n      // is valid IFF the `_messageRoot` has already been proven; we know that the `_messageRoot` has to\n      // have been included in *some* proven aggregate root historically.\n      return;\n    }\n\n    // 1. Ensure aggregate root has been proven.\n    verifyAggregateRoot(_aggregateRoot);\n\n    // 2. Calculate an aggregate root, given this inbound root (as leaf), path (proof), and index.\n    bytes32 _calculatedAggregateRoot = MerkleLib.branchRoot(_messageRoot, _aggregatePath, _aggregateIndex);\n\n    // 3. Check to make sure it matches the current aggregate root we have stored.\n    require(_calculatedAggregateRoot == _aggregateRoot, \"invalid inboundRoot\");\n\n    // This inbound root has been proven. We should specify that to optimize future calls.\n    provenMessageRoots[_messageRoot] = true;\n    emit MessageProven(_messageRoot, _aggregateRoot, _aggregateIndex);\n  }\n\n  /**\n   * @notice Given formatted message, attempts to dispatch message payload to end recipient.\n   * @dev Recipient must implement a `handle` method (refer to IMessageRecipient.sol)\n   * Reverts if formatted message's destination domain is not the Replica's domain,\n   * if message has not been proven,\n   * or if not enough gas is provided for the dispatch transaction.\n   * @param _message Formatted message\n   * @return _success TRUE iff dispatch transaction succeeded\n   */\n  function process(bytes memory _message) internal returns (bool _success) {\n    bytes29 _m = _message.ref(0);\n    // ensure message was meant for this domain\n    require(_m.destination() == DOMAIN, \"!destination\");\n    // ensure message has been proven\n    bytes32 _messageHash = _m.keccak();\n    // check re-entrancy guard\n    // require(entered == 1, \"!reentrant\");\n    // entered = 0;\n    // update message status as processed\n    MERKLE.markAsProcessed(_messageHash);\n    // A call running out of gas TYPICALLY errors the whole tx. We want to\n    // a) ensure the call has a sufficient amount of gas to make a\n    //    meaningful state change.\n    // b) ensure that if the subcall runs out of gas, that the tx as a whole\n    //    does not revert (i.e. we still mark the message processed)\n    // To do this, we require that we have enough gas to process\n    // and still return. We then delegate only the minimum processing gas.\n    require(gasleft() > PROCESS_GAS + RESERVE_GAS - 1, \"!gas\");\n    // get the message recipient\n    address _recipient = _m.recipientAddress();\n    // set up for assembly call\n    uint256 _gas = PROCESS_GAS;\n    uint16 _maxCopy = 256;\n    // allocate memory for returndata\n    bytes memory _returnData = new bytes(_maxCopy);\n    bytes memory _calldata = abi.encodeWithSignature(\n      \"handle(uint32,uint32,bytes32,bytes)\",\n      _m.origin(),\n      _m.nonce(),\n      _m.sender(),\n      _m.body().clone()\n    );\n\n    (_success, _returnData) = ExcessivelySafeCall.excessivelySafeCall(_recipient, _gas, 0, _maxCopy, _calldata);\n\n    // emit process results\n    emit Process(_messageHash, _success, _returnData);\n  }\n}\n"
    },
    "contracts/messaging/connectors/mainnet/MainnetSpokeConnector.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {IRootManager} from \"../../interfaces/IRootManager.sol\";\nimport {IHubConnector} from \"../../interfaces/IHubConnector.sol\";\nimport {IHubSpokeConnector} from \"../../interfaces/IHubSpokeConnector.sol\";\n\nimport {SpokeConnector} from \"../SpokeConnector.sol\";\n\ncontract MainnetSpokeConnector is SpokeConnector, IHubConnector, IHubSpokeConnector {\n  // ============ Errors ============\n  error MainnetSpokeConnector_proposeAggregateRoot__DeprecatedInHubDomain();\n  error MainnetSpokeConnector_finalize__DeprecatedInHubDomain();\n  error MainnetSpokeConnector_saveAggregateRoot__OnlyOptimisticMode();\n  error MainnetSpokeConnector_saveAggregateRoot__CallerIsNotRootManager();\n  error MainnetSpokeConnector_saveAggregateRoot__RootAlreadyProven();\n  error MainnetSpokeConnector_saveAggregateRoot__EmptyRoot();\n\n  // ============ Constructor ============\n  constructor(ConstructorParams memory _baseSpokeParams) SpokeConnector(_baseSpokeParams) {}\n\n  // ============ Public fns ============\n  /**\n   * @notice Sends a message over the amb\n   * @dev This is called by the root manager *only* on mainnet to propagate the aggregate root\n   * @dev Get 'Base constructor arguments given twice' when trying to inherit\n   */\n  function sendMessage(bytes memory _data, bytes memory _encodedData) external payable onlyRootManager {\n    // Should not include specialized calldata\n    require(_encodedData.length == 0, \"!data length\");\n    _sendMessage(_data, _encodedData);\n    emit MessageSent(_data, _encodedData, msg.sender);\n  }\n\n  // ============ Private fns ============\n  /**\n   * @dev Asserts the sender of a cross domain message. On mainnet all senders should be this\n   */\n  function _verifySender(address _expected) internal view override returns (bool) {\n    return msg.sender == _expected;\n  }\n\n  /**\n   * @dev There are two times messages get \"sent\" from this connector:\n   * 1. `RootManager` calls `sendMessage` during `propagate`\n   * 2. Relayers call `send`, which calls `_sendMessage` to set the outbound root\n   */\n  function _sendMessage(bytes memory _data, bytes memory _encodedData) internal override {\n    // Should not include specialized calldata\n    require(_encodedData.length == 0, \"!data length\");\n    // get the data (should be either the outbound or aggregate root, depending on sender)\n    require(_data.length == 32, \"!length\");\n    if (msg.sender == ROOT_MANAGER) {\n      // update the aggregate root\n      receiveAggregateRoot(bytes32(_data));\n      return;\n    }\n    // otherwise is relayer, update the outbound root on the root manager\n    IRootManager(ROOT_MANAGER).aggregate(DOMAIN, bytes32(_data));\n  }\n\n  /**\n   * @notice Saves a aggregateRoot after it has been deemed valid by the RootManager.\n   * @dev This function is used when optimistic mode is on. This function exists only on the hub domain's spoke connector given that\n   * it resides on the same chain as the RootManager, meaning it can take advantage of the RootManager performing the propose\n   * and finalize flow and simply recieve the finalized root directly.\n   * @param _aggregateRoot The aggregateRoot to store as proven.\n   */\n  function saveAggregateRoot(bytes32 _aggregateRoot) external {\n    if (_aggregateRoot == 0) revert MainnetSpokeConnector_saveAggregateRoot__EmptyRoot();\n    if (!optimisticMode) revert MainnetSpokeConnector_saveAggregateRoot__OnlyOptimisticMode();\n    if (msg.sender != ROOT_MANAGER) revert MainnetSpokeConnector_saveAggregateRoot__CallerIsNotRootManager();\n    if (provenAggregateRoots[_aggregateRoot]) revert MainnetSpokeConnector_saveAggregateRoot__RootAlreadyProven();\n    if (pendingAggregateRoots[_aggregateRoot] != 0) {\n      delete pendingAggregateRoots[_aggregateRoot];\n      emit PendingAggregateRootDeleted(_aggregateRoot);\n    }\n\n    provenAggregateRoots[_aggregateRoot] = true;\n    emit ProposedRootFinalized(_aggregateRoot);\n  }\n\n  /**\n   * @notice Proposes a new aggregate root.\n   * @dev Reverts in the hub domain as there's no need to propose nor finalize.\n   * @param _aggregateRoot The aggregate root to propose.\n   * @param _rootTimestamp Block.timestamp at which the root was finalized in the root manager contract.\n   */\n  function proposeAggregateRoot(bytes32 _aggregateRoot, uint256 _rootTimestamp) external override {\n    revert MainnetSpokeConnector_proposeAggregateRoot__DeprecatedInHubDomain();\n  }\n\n  /**\n   * @notice Finalizes the proposed aggregate root. This confirms the root validity. Therefore, it can be proved and processed.\n   * @dev Reverts in the hub domain as there's no need to propose nor finalize.\n   *\n   * @param _proposedAggregateRoot The aggregate root currently proposed\n   * @param _endOfDispute          The block in which the dispute period for proposedAggregateRootHash concludes\n   */\n  function finalize(bytes32 _proposedAggregateRoot, uint256 _rootTimestamp, uint256 _endOfDispute) external override {\n    revert MainnetSpokeConnector_finalize__DeprecatedInHubDomain();\n  }\n}\n"
    },
    "contracts/messaging/interfaces/IConnector.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {IProposedOwnable} from \"../../shared/interfaces/IProposedOwnable.sol\";\n\n/**\n * @notice This interface is what the Connext contract will send and receive messages through.\n * The messaging layer should conform to this interface, and should be interchangeable (i.e.\n * could be Nomad or a generic AMB under the hood).\n *\n * @dev This uses the nomad format to ensure nomad can be added in as it comes back online.\n *\n * Flow from transfer from polygon to optimism:\n * 1. User calls `xcall` with destination specified\n * 2. This will swap in to the bridge assets\n * 3. The swapped assets will get burned\n * 4. The Connext contract will call `dispatch` on the messaging contract to add the transfer\n *    to the root\n * 5. [At some time interval] Relayers call `send` to send the current root from polygon to\n *    mainnet. This is done on all \"spoke\" domains.\n * 6. [At some time interval] Relayers call `propagate` [better name] on mainnet, this generates a new merkle\n *    root from all of the AMBs\n *    - This function must be able to read root data from all AMBs and aggregate them into a single merkle\n *      tree root\n *    - Will send the mixed root from all chains back through the respective AMBs to all other chains\n * 7. AMB will call `update` to update the latest root on the messaging contract on spoke domains\n * 8. [At any point] Relayers can call `proveAndProcess` to prove inclusion of dispatched message, and call\n *    process on the `Connext` contract\n * 9. Takes minted bridge tokens and credits the LP\n *\n * AMB requirements:\n * - Access `msg.sender` both from mainnet -> spoke and vice versa\n * - Ability to read *our root* from the AMB\n *\n * AMBs:\n * - PoS bridge from polygon\n * - arbitrum bridge\n * - optimism bridge\n * - gnosis chain\n * - bsc (use multichain for messaging)\n */\ninterface IConnector is IProposedOwnable {\n  // ============ Events ============\n  /**\n   * @notice Emitted whenever a message is successfully sent over an AMB\n   * @param data The contents of the message\n   * @param encodedData Data used to send the message; specific to connector\n   * @param caller Who called the function (sent the message)\n   */\n  event MessageSent(bytes data, bytes encodedData, address caller);\n\n  /**\n   * @notice Emitted whenever a message is successfully received over an AMB\n   * @param data The contents of the message\n   * @param caller Who called the function\n   */\n  event MessageProcessed(bytes data, address caller);\n\n  // ============ Public fns ============\n\n  function processMessage(bytes memory _data) external;\n\n  function verifySender(address _expected) external returns (bool);\n}\n"
    },
    "contracts/messaging/interfaces/IConnectorManager.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {IOutbox} from \"./IOutbox.sol\";\n\n/**\n * @notice Each router extends the `XAppConnectionClient` contract. This contract\n * allows an admin to call `setXAppConnectionManager` to update the underlying\n * pointers to the messaging inboxes (Replicas) and outboxes (Homes).\n *\n * @dev This interface only contains the functions needed for the `XAppConnectionClient`\n * will interface with.\n */\ninterface IConnectorManager {\n  /**\n   * @notice Get the local inbox contract from the xAppConnectionManager\n   * @return The local inbox contract\n   * @dev The local inbox contract is a SpokeConnector with AMBs, and a\n   * Home contract with nomad\n   */\n  function home() external view returns (IOutbox);\n\n  /**\n   * @notice Determine whether _potentialReplica is an enrolled Replica from the xAppConnectionManager\n   * @return True if _potentialReplica is an enrolled Replica\n   */\n  function isReplica(address _potentialReplica) external view returns (bool);\n\n  /**\n   * @notice Get the local domain from the xAppConnectionManager\n   * @return The local domain\n   */\n  function localDomain() external view returns (uint32);\n}\n"
    },
    "contracts/messaging/interfaces/IHubConnector.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {IConnector} from \"./IConnector.sol\";\n\ninterface IHubConnector is IConnector {\n  function sendMessage(bytes memory _data, bytes memory _encodedData) external payable;\n}\n"
    },
    "contracts/messaging/interfaces/IHubSpokeConnector.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\ninterface IHubSpokeConnector {\n  function saveAggregateRoot(bytes32 _aggregateRoot) external;\n}\n"
    },
    "contracts/messaging/interfaces/IOutbox.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\n/**\n * @notice Interface for all contracts sending messages originating on their\n * current domain.\n *\n * @dev These are the Home.sol interface methods used by the `Router`\n * and exposed via `home()` on the `XAppConnectionClient`\n */\ninterface IOutbox {\n  /**\n   * @notice Emitted when a new message is added to an outbound message merkle root\n   * @param leafIndex Index of message's leaf in merkle tree\n   * @param destinationAndNonce Destination and destination-specific\n   * nonce combined in single field ((destination << 32) & nonce)\n   * @param messageHash Hash of message; the leaf inserted to the Merkle tree for the message\n   * @param committedRoot the latest notarized root submitted in the last signed Update\n   * @param message Raw bytes of message\n   */\n  event Dispatch(\n    bytes32 indexed messageHash,\n    uint256 indexed leafIndex,\n    uint64 indexed destinationAndNonce,\n    bytes32 committedRoot,\n    bytes message\n  );\n\n  /**\n   * @notice Dispatch the message it to the destination domain & recipient\n   * @dev Format the message, insert its hash into Merkle tree,\n   * enqueue the new Merkle root, and emit `Dispatch` event with message information.\n   * @param _destinationDomain Domain of destination chain\n   * @param _recipientAddress Address of recipient on destination chain as bytes32\n   * @param _messageBody Raw bytes content of message\n   * @return bytes32 The leaf added to the tree\n   */\n  function dispatch(\n    uint32 _destinationDomain,\n    bytes32 _recipientAddress,\n    bytes memory _messageBody\n  ) external returns (bytes32, bytes memory);\n\n  /**\n   * @notice domain => next available nonce for the domain.\n   */\n  function nonces(uint32 domain) external returns (uint32);\n}\n"
    },
    "contracts/messaging/interfaces/IRootManager.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\ninterface IRootManager {\n  /**\n   * @notice This is called by relayers to generate + send the mixed root from mainnet via AMB to\n   * spoke domains.\n   * @dev This must read information for the root from the registered AMBs.\n   */\n  function propagate(\n    address[] calldata _connectors,\n    uint256[] calldata _fees,\n    bytes[] memory _encodedData\n  ) external payable;\n\n  /**\n   * @notice Called by the connectors for various domains on the hub to aggregate their latest\n   * inbound root.\n   * @dev This must read information for the root from the registered AMBs\n   */\n  function aggregate(uint32 _domain, bytes32 _outbound) external;\n}\n"
    },
    "contracts/messaging/libraries/MerkleLib.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\n/**\n * @title MerkleLib\n * @author Illusory Systems Inc.\n * @notice An incremental merkle tree modeled on the eth2 deposit contract.\n **/\nlibrary MerkleLib {\n  // ========== Custom Errors ===========\n\n  error MerkleLib__insert_treeIsFull();\n\n  // ============ Constants =============\n\n  uint256 internal constant TREE_DEPTH = 32;\n  uint256 internal constant MAX_LEAVES = 2**TREE_DEPTH - 1;\n\n  /**\n   * @dev Z_i represent the hash values at different heights for a binary tree with leaf values equal to `0`.\n   * (e.g. Z_1 is the keccak256 hash of (0x0, 0x0), Z_2 is the keccak256 hash of (Z_1, Z_1), etc...)\n   * Z_0 is the bottom of the 33-layer tree, Z_32 is the top (i.e. root).\n   * Used to shortcut calculation in root calculation methods below.\n   */\n  bytes32 internal constant Z_0 = hex\"0000000000000000000000000000000000000000000000000000000000000000\";\n  bytes32 internal constant Z_1 = hex\"ad3228b676f7d3cd4284a5443f17f1962b36e491b30a40b2405849e597ba5fb5\";\n  bytes32 internal constant Z_2 = hex\"b4c11951957c6f8f642c4af61cd6b24640fec6dc7fc607ee8206a99e92410d30\";\n  bytes32 internal constant Z_3 = hex\"21ddb9a356815c3fac1026b6dec5df3124afbadb485c9ba5a3e3398a04b7ba85\";\n  bytes32 internal constant Z_4 = hex\"e58769b32a1beaf1ea27375a44095a0d1fb664ce2dd358e7fcbfb78c26a19344\";\n  bytes32 internal constant Z_5 = hex\"0eb01ebfc9ed27500cd4dfc979272d1f0913cc9f66540d7e8005811109e1cf2d\";\n  bytes32 internal constant Z_6 = hex\"887c22bd8750d34016ac3c66b5ff102dacdd73f6b014e710b51e8022af9a1968\";\n  bytes32 internal constant Z_7 = hex\"ffd70157e48063fc33c97a050f7f640233bf646cc98d9524c6b92bcf3ab56f83\";\n  bytes32 internal constant Z_8 = hex\"9867cc5f7f196b93bae1e27e6320742445d290f2263827498b54fec539f756af\";\n  bytes32 internal constant Z_9 = hex\"cefad4e508c098b9a7e1d8feb19955fb02ba9675585078710969d3440f5054e0\";\n  bytes32 internal constant Z_10 = hex\"f9dc3e7fe016e050eff260334f18a5d4fe391d82092319f5964f2e2eb7c1c3a5\";\n  bytes32 internal constant Z_11 = hex\"f8b13a49e282f609c317a833fb8d976d11517c571d1221a265d25af778ecf892\";\n  bytes32 internal constant Z_12 = hex\"3490c6ceeb450aecdc82e28293031d10c7d73bf85e57bf041a97360aa2c5d99c\";\n  bytes32 internal constant Z_13 = hex\"c1df82d9c4b87413eae2ef048f94b4d3554cea73d92b0f7af96e0271c691e2bb\";\n  bytes32 internal constant Z_14 = hex\"5c67add7c6caf302256adedf7ab114da0acfe870d449a3a489f781d659e8becc\";\n  bytes32 internal constant Z_15 = hex\"da7bce9f4e8618b6bd2f4132ce798cdc7a60e7e1460a7299e3c6342a579626d2\";\n  bytes32 internal constant Z_16 = hex\"2733e50f526ec2fa19a22b31e8ed50f23cd1fdf94c9154ed3a7609a2f1ff981f\";\n  bytes32 internal constant Z_17 = hex\"e1d3b5c807b281e4683cc6d6315cf95b9ade8641defcb32372f1c126e398ef7a\";\n  bytes32 internal constant Z_18 = hex\"5a2dce0a8a7f68bb74560f8f71837c2c2ebbcbf7fffb42ae1896f13f7c7479a0\";\n  bytes32 internal constant Z_19 = hex\"b46a28b6f55540f89444f63de0378e3d121be09e06cc9ded1c20e65876d36aa0\";\n  bytes32 internal constant Z_20 = hex\"c65e9645644786b620e2dd2ad648ddfcbf4a7e5b1a3a4ecfe7f64667a3f0b7e2\";\n  bytes32 internal constant Z_21 = hex\"f4418588ed35a2458cffeb39b93d26f18d2ab13bdce6aee58e7b99359ec2dfd9\";\n  bytes32 internal constant Z_22 = hex\"5a9c16dc00d6ef18b7933a6f8dc65ccb55667138776f7dea101070dc8796e377\";\n  bytes32 internal constant Z_23 = hex\"4df84f40ae0c8229d0d6069e5c8f39a7c299677a09d367fc7b05e3bc380ee652\";\n  bytes32 internal constant Z_24 = hex\"cdc72595f74c7b1043d0e1ffbab734648c838dfb0527d971b602bc216c9619ef\";\n  bytes32 internal constant Z_25 = hex\"0abf5ac974a1ed57f4050aa510dd9c74f508277b39d7973bb2dfccc5eeb0618d\";\n  bytes32 internal constant Z_26 = hex\"b8cd74046ff337f0a7bf2c8e03e10f642c1886798d71806ab1e888d9e5ee87d0\";\n  bytes32 internal constant Z_27 = hex\"838c5655cb21c6cb83313b5a631175dff4963772cce9108188b34ac87c81c41e\";\n  bytes32 internal constant Z_28 = hex\"662ee4dd2dd7b2bc707961b1e646c4047669dcb6584f0d8d770daf5d7e7deb2e\";\n  bytes32 internal constant Z_29 = hex\"388ab20e2573d171a88108e79d820e98f26c0b84aa8b2f4aa4968dbb818ea322\";\n  bytes32 internal constant Z_30 = hex\"93237c50ba75ee485f4c22adf2f741400bdf8d6a9cc7df7ecae576221665d735\";\n  bytes32 internal constant Z_31 = hex\"8448818bb4ae4562849e949e17ac16e0be16688e156b5cf15e098c627c0056a9\";\n  bytes32 internal constant Z_32 = hex\"27ae5ba08d7291c96c8cbddcc148bf48a6d68c7974b94356f53754ef6171d757\";\n\n  // ============= Structs ==============\n\n  /**\n   * @notice Struct representing incremental merkle tree. Contains current\n   * branch and the number of inserted leaves in the tree.\n   **/\n  struct Tree {\n    bytes32[TREE_DEPTH] branch;\n    uint256 count;\n  }\n\n  // ========= Write Methods =========\n\n  /**\n   * @notice Inserts a given node (leaf) into merkle tree. Operates on an in-memory tree and\n   * returns an updated version of that tree.\n   * @dev Reverts if the tree is already full.\n   * @param node Element to insert into tree.\n   * @return Tree Updated tree.\n   **/\n  function insert(Tree memory tree, bytes32 node) internal pure returns (Tree memory) {\n    // Update tree.count to increase the current count by 1 since we'll be including a new node.\n    uint256 size = ++tree.count;\n    if (size > MAX_LEAVES) revert MerkleLib__insert_treeIsFull();\n\n    // Loop starting at 0, ending when we've finished inserting the node (i.e. hashing it) into\n    // the active branch. Each loop we cut size in half, hashing the inserted node up the active\n    // branch along the way.\n    for (uint256 i; i < TREE_DEPTH; ) {\n      // Check if the current size is odd; if so, we set this index in the branch to be the node.\n      if ((size & 1) == 1) {\n        // If i > 0, then this node will be a hash of the original node with every layer up\n        // until layer `i`.\n        tree.branch[i] = node;\n        return tree;\n      }\n      // If the size is not yet odd, we hash the current index in the tree branch with the node.\n      node = keccak256(abi.encodePacked(tree.branch[i], node));\n      size >>= 1; // Cut size in half (statement equivalent to: `size /= 2`).\n\n      unchecked {\n        ++i;\n      }\n    }\n    // As the loop should always end prematurely with the `return` statement, this code should\n    // be unreachable. We revert here just to be safe.\n    revert MerkleLib__insert_treeIsFull();\n  }\n\n  // ========= Read Methods =========\n\n  /**\n   * @notice Calculates and returns tree's current root.\n   * @return _current bytes32 root.\n   **/\n  function root(Tree storage tree) internal view returns (bytes32 _current) {\n    uint256 _index = tree.count;\n\n    if (_index == 0) {\n      return Z_32;\n    }\n\n    uint256 i;\n    assembly {\n      let TREE_SLOT := tree.slot\n\n      for {\n\n      } true {\n\n      } {\n        for {\n\n        } true {\n\n        } {\n          if and(_index, 1) {\n            mstore(0, sload(TREE_SLOT))\n            mstore(0x20, Z_0)\n            _current := keccak256(0, 0x40)\n            break\n          }\n\n          if and(_index, shl(1, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 1)))\n            mstore(0x20, Z_1)\n            _current := keccak256(0, 0x40)\n            i := 1\n            break\n          }\n\n          if and(_index, shl(2, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 2)))\n            mstore(0x20, Z_2)\n            _current := keccak256(0, 0x40)\n            i := 2\n            break\n          }\n\n          if and(_index, shl(3, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 3)))\n            mstore(0x20, Z_3)\n            _current := keccak256(0, 0x40)\n            i := 3\n            break\n          }\n\n          if and(_index, shl(4, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 4)))\n            mstore(0x20, Z_4)\n            _current := keccak256(0, 0x40)\n            i := 4\n            break\n          }\n\n          if and(_index, shl(5, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 5)))\n            mstore(0x20, Z_5)\n            _current := keccak256(0, 0x40)\n            i := 5\n            break\n          }\n\n          if and(_index, shl(6, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 6)))\n            mstore(0x20, Z_6)\n            _current := keccak256(0, 0x40)\n            i := 6\n            break\n          }\n\n          if and(_index, shl(7, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 7)))\n            mstore(0x20, Z_7)\n            _current := keccak256(0, 0x40)\n            i := 7\n            break\n          }\n\n          if and(_index, shl(8, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 8)))\n            mstore(0x20, Z_8)\n            _current := keccak256(0, 0x40)\n            i := 8\n            break\n          }\n\n          if and(_index, shl(9, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 9)))\n            mstore(0x20, Z_9)\n            _current := keccak256(0, 0x40)\n            i := 9\n            break\n          }\n\n          if and(_index, shl(10, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 10)))\n            mstore(0x20, Z_10)\n            _current := keccak256(0, 0x40)\n            i := 10\n            break\n          }\n\n          if and(_index, shl(11, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 11)))\n            mstore(0x20, Z_11)\n            _current := keccak256(0, 0x40)\n            i := 11\n            break\n          }\n\n          if and(_index, shl(12, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 12)))\n            mstore(0x20, Z_12)\n            _current := keccak256(0, 0x40)\n            i := 12\n            break\n          }\n\n          if and(_index, shl(13, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 13)))\n            mstore(0x20, Z_13)\n            _current := keccak256(0, 0x40)\n            i := 13\n            break\n          }\n\n          if and(_index, shl(14, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 14)))\n            mstore(0x20, Z_14)\n            _current := keccak256(0, 0x40)\n            i := 14\n            break\n          }\n\n          if and(_index, shl(15, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 15)))\n            mstore(0x20, Z_15)\n            _current := keccak256(0, 0x40)\n            i := 15\n            break\n          }\n\n          if and(_index, shl(16, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 16)))\n            mstore(0x20, Z_16)\n            _current := keccak256(0, 0x40)\n            i := 16\n            break\n          }\n\n          if and(_index, shl(17, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 17)))\n            mstore(0x20, Z_17)\n            _current := keccak256(0, 0x40)\n            i := 17\n            break\n          }\n\n          if and(_index, shl(18, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 18)))\n            mstore(0x20, Z_18)\n            _current := keccak256(0, 0x40)\n            i := 18\n            break\n          }\n\n          if and(_index, shl(19, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 19)))\n            mstore(0x20, Z_19)\n            _current := keccak256(0, 0x40)\n            i := 19\n            break\n          }\n\n          if and(_index, shl(20, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 20)))\n            mstore(0x20, Z_20)\n            _current := keccak256(0, 0x40)\n            i := 20\n            break\n          }\n\n          if and(_index, shl(21, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 21)))\n            mstore(0x20, Z_21)\n            _current := keccak256(0, 0x40)\n            i := 21\n            break\n          }\n\n          if and(_index, shl(22, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 22)))\n            mstore(0x20, Z_22)\n            _current := keccak256(0, 0x40)\n            i := 22\n            break\n          }\n\n          if and(_index, shl(23, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 23)))\n            mstore(0x20, Z_23)\n            _current := keccak256(0, 0x40)\n            i := 23\n            break\n          }\n\n          if and(_index, shl(24, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 24)))\n            mstore(0x20, Z_24)\n            _current := keccak256(0, 0x40)\n            i := 24\n            break\n          }\n\n          if and(_index, shl(25, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 25)))\n            mstore(0x20, Z_25)\n            _current := keccak256(0, 0x40)\n            i := 25\n            break\n          }\n\n          if and(_index, shl(26, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 26)))\n            mstore(0x20, Z_26)\n            _current := keccak256(0, 0x40)\n            i := 26\n            break\n          }\n\n          if and(_index, shl(27, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 27)))\n            mstore(0x20, Z_27)\n            _current := keccak256(0, 0x40)\n            i := 27\n            break\n          }\n\n          if and(_index, shl(28, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 28)))\n            mstore(0x20, Z_28)\n            _current := keccak256(0, 0x40)\n            i := 28\n            break\n          }\n\n          if and(_index, shl(29, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 29)))\n            mstore(0x20, Z_29)\n            _current := keccak256(0, 0x40)\n            i := 29\n            break\n          }\n\n          if and(_index, shl(30, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 30)))\n            mstore(0x20, Z_30)\n            _current := keccak256(0, 0x40)\n            i := 30\n            break\n          }\n\n          if and(_index, shl(31, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 31)))\n            mstore(0x20, Z_31)\n            _current := keccak256(0, 0x40)\n            i := 31\n            break\n          }\n\n          _current := Z_32\n          i := 32\n          break\n        }\n\n        if gt(i, 30) {\n          break\n        }\n\n        {\n          if lt(i, 1) {\n            switch and(_index, shl(1, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_1)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 1)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 2) {\n            switch and(_index, shl(2, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_2)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 2)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 3) {\n            switch and(_index, shl(3, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_3)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 3)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 4) {\n            switch and(_index, shl(4, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_4)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 4)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 5) {\n            switch and(_index, shl(5, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_5)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 5)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 6) {\n            switch and(_index, shl(6, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_6)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 6)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 7) {\n            switch and(_index, shl(7, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_7)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 7)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 8) {\n            switch and(_index, shl(8, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_8)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 8)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 9) {\n            switch and(_index, shl(9, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_9)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 9)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 10) {\n            switch and(_index, shl(10, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_10)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 10)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 11) {\n            switch and(_index, shl(11, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_11)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 11)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 12) {\n            switch and(_index, shl(12, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_12)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 12)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 13) {\n            switch and(_index, shl(13, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_13)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 13)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 14) {\n            switch and(_index, shl(14, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_14)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 14)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 15) {\n            switch and(_index, shl(15, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_15)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 15)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 16) {\n            switch and(_index, shl(16, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_16)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 16)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 17) {\n            switch and(_index, shl(17, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_17)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 17)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 18) {\n            switch and(_index, shl(18, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_18)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 18)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 19) {\n            switch and(_index, shl(19, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_19)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 19)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 20) {\n            switch and(_index, shl(20, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_20)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 20)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 21) {\n            switch and(_index, shl(21, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_21)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 21)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 22) {\n            switch and(_index, shl(22, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_22)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 22)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 23) {\n            switch and(_index, shl(23, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_23)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 23)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 24) {\n            switch and(_index, shl(24, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_24)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 24)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 25) {\n            switch and(_index, shl(25, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_25)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 25)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 26) {\n            switch and(_index, shl(26, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_26)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 26)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 27) {\n            switch and(_index, shl(27, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_27)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 27)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 28) {\n            switch and(_index, shl(28, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_28)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 28)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 29) {\n            switch and(_index, shl(29, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_29)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 29)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 30) {\n            switch and(_index, shl(30, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_30)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 30)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 31) {\n            switch and(_index, shl(31, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_31)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 31)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n        }\n\n        break\n      }\n    }\n  }\n\n  /**\n   * @notice Calculates and returns the merkle root for the given leaf `_item`,\n   * a merkle branch, and the index of `_item` in the tree.\n   * @param _item Merkle leaf\n   * @param _branch Merkle proof\n   * @param _index Index of `_item` in tree\n   * @return _current Calculated merkle root\n   **/\n  function branchRoot(\n    bytes32 _item,\n    bytes32[TREE_DEPTH] memory _branch,\n    uint256 _index\n  ) internal pure returns (bytes32 _current) {\n    assembly {\n      _current := _item\n      let BRANCH_DATA_OFFSET := _branch\n      let f\n\n      f := shl(5, and(_index, 1))\n      mstore(f, _current)\n      mstore(sub(0x20, f), mload(BRANCH_DATA_OFFSET))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(1, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 1))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(2, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 2))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(3, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 3))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(4, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 4))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(5, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 5))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(6, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 6))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(7, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 7))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(8, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 8))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(9, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 9))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(10, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 10))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(11, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 11))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(12, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 12))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(13, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 13))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(14, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 14))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(15, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 15))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(16, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 16))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(17, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 17))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(18, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 18))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(19, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 19))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(20, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 20))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(21, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 21))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(22, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 22))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(23, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 23))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(24, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 24))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(25, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 25))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(26, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 26))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(27, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 27))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(28, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 28))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(29, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 29))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(30, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 30))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(31, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 31))))\n      _current := keccak256(0, 0x40)\n    }\n  }\n}\n"
    },
    "contracts/messaging/libraries/Message.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {TypedMemView} from \"../../shared/libraries/TypedMemView.sol\";\nimport {TypeCasts} from \"../../shared/libraries/TypeCasts.sol\";\n\n/**\n * @title Message Library\n * @author Illusory Systems Inc.\n * @notice Library for formatted messages used by Home and Replica.\n **/\nlibrary Message {\n  using TypedMemView for bytes;\n  using TypedMemView for bytes29;\n\n  // Number of bytes in formatted message before `body` field\n  uint256 internal constant PREFIX_LENGTH = 76;\n\n  /**\n   * @notice Returns formatted (packed) message with provided fields\n   * @param _originDomain Domain of home chain\n   * @param _sender Address of sender as bytes32\n   * @param _nonce Destination-specific nonce\n   * @param _destinationDomain Domain of destination chain\n   * @param _recipient Address of recipient on destination chain as bytes32\n   * @param _messageBody Raw bytes of message body\n   * @return Formatted message\n   **/\n  function formatMessage(\n    uint32 _originDomain,\n    bytes32 _sender,\n    uint32 _nonce,\n    uint32 _destinationDomain,\n    bytes32 _recipient,\n    bytes memory _messageBody\n  ) internal pure returns (bytes memory) {\n    return abi.encodePacked(_originDomain, _sender, _nonce, _destinationDomain, _recipient, _messageBody);\n  }\n\n  /**\n   * @notice Returns leaf of formatted message with provided fields.\n   * @param _origin Domain of home chain\n   * @param _sender Address of sender as bytes32\n   * @param _nonce Destination-specific nonce number\n   * @param _destination Domain of destination chain\n   * @param _recipient Address of recipient on destination chain as bytes32\n   * @param _body Raw bytes of message body\n   * @return Leaf (hash) of formatted message\n   **/\n  function messageHash(\n    uint32 _origin,\n    bytes32 _sender,\n    uint32 _nonce,\n    uint32 _destination,\n    bytes32 _recipient,\n    bytes memory _body\n  ) internal pure returns (bytes32) {\n    return keccak256(formatMessage(_origin, _sender, _nonce, _destination, _recipient, _body));\n  }\n\n  /// @notice Returns message's origin field\n  function origin(bytes29 _message) internal pure returns (uint32) {\n    return uint32(_message.indexUint(0, 4));\n  }\n\n  /// @notice Returns message's sender field\n  function sender(bytes29 _message) internal pure returns (bytes32) {\n    return _message.index(4, 32);\n  }\n\n  /// @notice Returns message's nonce field\n  function nonce(bytes29 _message) internal pure returns (uint32) {\n    return uint32(_message.indexUint(36, 4));\n  }\n\n  /// @notice Returns message's destination field\n  function destination(bytes29 _message) internal pure returns (uint32) {\n    return uint32(_message.indexUint(40, 4));\n  }\n\n  /// @notice Returns message's recipient field as bytes32\n  function recipient(bytes29 _message) internal pure returns (bytes32) {\n    return _message.index(44, 32);\n  }\n\n  /// @notice Returns message's recipient field as an address\n  function recipientAddress(bytes29 _message) internal pure returns (address) {\n    return TypeCasts.bytes32ToAddress(recipient(_message));\n  }\n\n  /// @notice Returns message's body field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n  function body(bytes29 _message) internal pure returns (bytes29) {\n    return _message.slice(PREFIX_LENGTH, _message.len() - PREFIX_LENGTH, 0);\n  }\n\n  function leaf(bytes29 _message) internal pure returns (bytes32) {\n    uint256 loc = _message.loc();\n    uint256 len = _message.len();\n    /*\n    prev:\n    return\n      messageHash(\n        origin(_message),\n        sender(_message),\n        nonce(_message),\n        destination(_message),\n        recipient(_message),\n        TypedMemView.clone(body(_message))\n      );\n\n      below added for gas optimization\n     */\n    bytes32 hash;\n    assembly {\n      hash := keccak256(loc, len)\n    }\n    return hash;\n  }\n}\n"
    },
    "contracts/messaging/libraries/RateLimited.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\n/**\n * @notice An abstract contract intended to manage the rate limiting aspect of spoke\n * connector messaging. Rate limiting the number of messages we can send over a span of\n * blocks is used to mitigate key DoSing vectors for transporting messages between chains.\n */\nabstract contract RateLimited {\n  // ========== Custom Errors ===========\n\n  error RateLimited__rateLimited_messageSendRateExceeded();\n\n  // ============ Events ============\n\n  event SendRateLimitUpdated(address updater, uint256 newRateLimit);\n\n  // ============ Public Storage ============\n\n  /**\n   * @notice The number of blocks required between message sending events.\n   * @dev NOTE: This value is 0 by default, meaning that rate limiting functionality\n   * will naturally be disabled by default.\n   */\n  uint256 public rateLimitBlocks;\n\n  /**\n   * @notice Tracks the last block that we sent a message.\n   */\n  uint256 public lastSentBlock;\n\n  // ============ Modifiers ============\n\n  /**\n   * @notice Checks to see if we can send this block, given the current rate limit\n   * setting and the last block we sent a message. If rate limit has been surpassed,\n   * we update the `lastSentBlock` to be the current block.\n   */\n  modifier rateLimited() {\n    // Check to make sure we have surpassed the number of rate limit blocks.\n    if (lastSentBlock + rateLimitBlocks > block.number) {\n      revert RateLimited__rateLimited_messageSendRateExceeded();\n    }\n    // Update the last block we sent a message to be the current one.\n    lastSentBlock = block.number;\n    _;\n  }\n\n  // ============ Admin Functions ============\n\n  /**\n   * @notice Update the current rate limit to a new value.\n   */\n  function _setRateLimitBlocks(uint256 _newRateLimit) internal {\n    require(_newRateLimit != rateLimitBlocks, \"!new rate limit\");\n    // NOTE: Setting the block rate limit interval to 0 will result in rate limiting\n    // being disabled.\n    rateLimitBlocks = _newRateLimit;\n    emit SendRateLimitUpdated(msg.sender, _newRateLimit);\n  }\n}\n"
    },
    "contracts/messaging/libraries/SnapshotId.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\n/**\n * @title SnapshotId library\n * @notice A library to be used in spoke connector and root manager to calculates the current snapshot id\n */\nlibrary SnapshotId {\n  /**\n   * @notice Duration of the snapshot\n   * @dev Off-chain agents could change the effective snapshot length by skipping snapshots. This is the\n   * smallest unit of snapshot duration, not just the only option.\n   */\n  uint256 constant SNAPSHOT_DURATION = 30 minutes;\n\n  /**\n   * @notice This function calculates the last completed snapshot id\n   * @return _lastCompletedSnapshotId The last completed snapshot id\n   */\n  function getLastCompletedSnapshotId() internal view returns (uint256 _lastCompletedSnapshotId) {\n    unchecked {\n      _lastCompletedSnapshotId = block.timestamp / SNAPSHOT_DURATION;\n    }\n  }\n}\n"
    },
    "contracts/shared/ProposedOwnable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\nimport {IProposedOwnable} from \"./interfaces/IProposedOwnable.sol\";\n\n/**\n * @title ProposedOwnable\n * @notice Contract module which provides a basic access control mechanism,\n * where there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed via a two step process:\n * 1. Call `proposeOwner`\n * 2. Wait out the delay period\n * 3. Call `acceptOwner`\n *\n * @dev This module is used through inheritance. It will make available the\n * modifier `onlyOwner`, which can be applied to your functions to restrict\n * their use to the owner.\n *\n * @dev The majority of this code was taken from the openzeppelin Ownable\n * contract\n *\n */\nabstract contract ProposedOwnable is IProposedOwnable {\n  // ========== Custom Errors ===========\n\n  error ProposedOwnable__onlyOwner_notOwner();\n  error ProposedOwnable__onlyProposed_notProposedOwner();\n  error ProposedOwnable__ownershipDelayElapsed_delayNotElapsed();\n  error ProposedOwnable__proposeNewOwner_invalidProposal();\n  error ProposedOwnable__proposeNewOwner_noOwnershipChange();\n  error ProposedOwnable__renounceOwnership_noProposal();\n  error ProposedOwnable__renounceOwnership_invalidProposal();\n\n  // ============ Properties ============\n\n  address private _owner;\n\n  address private _proposed;\n  uint256 private _proposedOwnershipTimestamp;\n\n  uint256 private constant _delay = 7 days;\n\n  // ======== Getters =========\n\n  /**\n   * @notice Returns the address of the current owner.\n   */\n  function owner() public view virtual returns (address) {\n    return _owner;\n  }\n\n  /**\n   * @notice Returns the address of the proposed owner.\n   */\n  function proposed() public view virtual returns (address) {\n    return _proposed;\n  }\n\n  /**\n   * @notice Returns the address of the proposed owner.\n   */\n  function proposedTimestamp() public view virtual returns (uint256) {\n    return _proposedOwnershipTimestamp;\n  }\n\n  /**\n   * @notice Returns the delay period before a new owner can be accepted.\n   */\n  function delay() public view virtual returns (uint256) {\n    return _delay;\n  }\n\n  /**\n   * @notice Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    if (_owner != msg.sender) revert ProposedOwnable__onlyOwner_notOwner();\n    _;\n  }\n\n  /**\n   * @notice Throws if called by any account other than the proposed owner.\n   */\n  modifier onlyProposed() {\n    if (_proposed != msg.sender) revert ProposedOwnable__onlyProposed_notProposedOwner();\n    _;\n  }\n\n  /**\n   * @notice Throws if the ownership delay has not elapsed\n   */\n  modifier ownershipDelayElapsed() {\n    // Ensure delay has elapsed\n    if ((block.timestamp - _proposedOwnershipTimestamp) <= _delay)\n      revert ProposedOwnable__ownershipDelayElapsed_delayNotElapsed();\n    _;\n  }\n\n  /**\n   * @notice Indicates if the ownership has been renounced() by\n   * checking if current owner is address(0)\n   */\n  function renounced() public view returns (bool) {\n    return _owner == address(0);\n  }\n\n  // ======== External =========\n\n  /**\n   * @notice Sets the timestamp for an owner to be proposed, and sets the\n   * newly proposed owner as step 1 in a 2-step process\n   */\n  function proposeNewOwner(address newlyProposed) public virtual onlyOwner {\n    // Contract as source of truth\n    if (_proposed == newlyProposed && _proposedOwnershipTimestamp != 0)\n      revert ProposedOwnable__proposeNewOwner_invalidProposal();\n\n    // Sanity check: reasonable proposal\n    if (_owner == newlyProposed) revert ProposedOwnable__proposeNewOwner_noOwnershipChange();\n\n    _setProposed(newlyProposed);\n  }\n\n  /**\n   * @notice Renounces ownership of the contract after a delay\n   */\n  function renounceOwnership() public virtual onlyOwner ownershipDelayElapsed {\n    // Ensure there has been a proposal cycle started\n    if (_proposedOwnershipTimestamp == 0) revert ProposedOwnable__renounceOwnership_noProposal();\n\n    // Require proposed is set to 0\n    if (_proposed != address(0)) revert ProposedOwnable__renounceOwnership_invalidProposal();\n\n    // Emit event, set new owner, reset timestamp\n    _setOwner(address(0));\n  }\n\n  /**\n   * @notice Transfers ownership of the contract to a new account (`newOwner`).\n   * Can only be called by the current owner.\n   */\n  function acceptProposedOwner() public virtual onlyProposed ownershipDelayElapsed {\n    // NOTE: no need to check if _owner == _proposed, because the _proposed\n    // is 0-d out and this check is implicitly enforced by modifier\n\n    // NOTE: no need to check if _proposedOwnershipTimestamp > 0 because\n    // the only time this would happen is if the _proposed was never\n    // set (will fail from modifier) or if the owner == _proposed (checked\n    // above)\n\n    // Emit event, set new owner, reset timestamp\n    _setOwner(_proposed);\n  }\n\n  // ======== Internal =========\n\n  function _setOwner(address newOwner) internal {\n    emit OwnershipTransferred(_owner, newOwner);\n    _owner = newOwner;\n    delete _proposedOwnershipTimestamp;\n    delete _proposed;\n  }\n\n  function _setProposed(address newlyProposed) private {\n    _proposedOwnershipTimestamp = block.timestamp;\n    _proposed = newlyProposed;\n    emit OwnershipProposed(newlyProposed);\n  }\n}\n"
    },
    "contracts/shared/ProposedOwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport {ProposedOwnable} from \"./ProposedOwnable.sol\";\n\nabstract contract ProposedOwnableUpgradeable is Initializable, ProposedOwnable {\n  /**\n   * @dev Initializes the contract setting the deployer as the initial\n   */\n  function __ProposedOwnable_init() internal onlyInitializing {\n    __ProposedOwnable_init_unchained();\n  }\n\n  function __ProposedOwnable_init_unchained() internal onlyInitializing {\n    _setOwner(msg.sender);\n  }\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint256[47] private __GAP;\n}\n"
    },
    "contracts/shared/interfaces/IProposedOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @title IProposedOwnable\n * @notice Defines a minimal interface for ownership with a two step proposal and acceptance\n * process\n */\ninterface IProposedOwnable {\n  /**\n   * @dev This emits when change in ownership of a contract is proposed.\n   */\n  event OwnershipProposed(address indexed proposedOwner);\n\n  /**\n   * @dev This emits when ownership of a contract changes.\n   */\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  /**\n   * @notice Get the address of the owner\n   * @return owner_ The address of the owner.\n   */\n  function owner() external view returns (address owner_);\n\n  /**\n   * @notice Get the address of the proposed owner\n   * @return proposed_ The address of the proposed.\n   */\n  function proposed() external view returns (address proposed_);\n\n  /**\n   * @notice Set the address of the proposed owner of the contract\n   * @param newlyProposed The proposed new owner of the contract\n   */\n  function proposeNewOwner(address newlyProposed) external;\n\n  /**\n   * @notice Set the address of the proposed owner of the contract\n   */\n  function acceptProposedOwner() external;\n}\n"
    },
    "contracts/shared/libraries/ExcessivelySafeCall.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\n// Taken from: https://github.com/nomad-xyz/ExcessivelySafeCall\n// NOTE: There is a difference between npm latest and github main versions\n// where the latest github version allows you to specify an ether value.\n\nlibrary ExcessivelySafeCall {\n  uint256 constant LOW_28_MASK = 0x00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n  /// @notice Use when you _really_ really _really_ don't trust the called\n  /// contract. This prevents the called contract from causing reversion of\n  /// the caller in as many ways as we can.\n  /// @dev The main difference between this and a solidity low-level call is\n  /// that we limit the number of bytes that the callee can cause to be\n  /// copied to caller memory. This prevents stupid things like malicious\n  /// contracts returning 10,000,000 bytes causing a local OOG when copying\n  /// to memory.\n  /// @param _target The address to call\n  /// @param _gas The amount of gas to forward to the remote contract\n  /// @param _value The value in wei to send to the remote contract\n  /// @param _maxCopy The maximum number of bytes of returndata to copy\n  /// to memory.\n  /// @param _calldata The data to send to the remote contract\n  /// @return success and returndata, as `.call()`. Returndata is capped to\n  /// `_maxCopy` bytes.\n  function excessivelySafeCall(\n    address _target,\n    uint256 _gas,\n    uint256 _value,\n    uint16 _maxCopy,\n    bytes memory _calldata\n  ) internal returns (bool, bytes memory) {\n    // set up for assembly call\n    uint256 _toCopy;\n    bool _success;\n    bytes memory _returnData = new bytes(_maxCopy);\n    // dispatch message to recipient\n    // by assembly calling \"handle\" function\n    // we call via assembly to avoid memcopying a very large returndata\n    // returned by a malicious contract\n    assembly {\n      _success := call(\n        _gas, // gas\n        _target, // recipient\n        _value, // ether value\n        add(_calldata, 0x20), // inloc\n        mload(_calldata), // inlen\n        0, // outloc\n        0 // outlen\n      )\n      // limit our copy to 256 bytes\n      _toCopy := returndatasize()\n      if gt(_toCopy, _maxCopy) {\n        _toCopy := _maxCopy\n      }\n      // Store the length of the copied bytes\n      mstore(_returnData, _toCopy)\n      // copy the bytes from returndata[0:_toCopy]\n      returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n    }\n    return (_success, _returnData);\n  }\n\n  /// @notice Use when you _really_ really _really_ don't trust the called\n  /// contract. This prevents the called contract from causing reversion of\n  /// the caller in as many ways as we can.\n  /// @dev The main difference between this and a solidity low-level call is\n  /// that we limit the number of bytes that the callee can cause to be\n  /// copied to caller memory. This prevents stupid things like malicious\n  /// contracts returning 10,000,000 bytes causing a local OOG when copying\n  /// to memory.\n  /// @param _target The address to call\n  /// @param _gas The amount of gas to forward to the remote contract\n  /// @param _maxCopy The maximum number of bytes of returndata to copy\n  /// to memory.\n  /// @param _calldata The data to send to the remote contract\n  /// @return success and returndata, as `.call()`. Returndata is capped to\n  /// `_maxCopy` bytes.\n  function excessivelySafeStaticCall(\n    address _target,\n    uint256 _gas,\n    uint16 _maxCopy,\n    bytes memory _calldata\n  ) internal view returns (bool, bytes memory) {\n    // set up for assembly call\n    uint256 _toCopy;\n    bool _success;\n    bytes memory _returnData = new bytes(_maxCopy);\n    // dispatch message to recipient\n    // by assembly calling \"handle\" function\n    // we call via assembly to avoid memcopying a very large returndata\n    // returned by a malicious contract\n    assembly {\n      _success := staticcall(\n        _gas, // gas\n        _target, // recipient\n        add(_calldata, 0x20), // inloc\n        mload(_calldata), // inlen\n        0, // outloc\n        0 // outlen\n      )\n      // limit our copy to 256 bytes\n      _toCopy := returndatasize()\n      if gt(_toCopy, _maxCopy) {\n        _toCopy := _maxCopy\n      }\n      // Store the length of the copied bytes\n      mstore(_returnData, _toCopy)\n      // copy the bytes from returndata[0:_toCopy]\n      returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n    }\n    return (_success, _returnData);\n  }\n\n  /**\n   * @notice Swaps function selectors in encoded contract calls\n   * @dev Allows reuse of encoded calldata for functions with identical\n   * argument types but different names. It simply swaps out the first 4 bytes\n   * for the new selector. This function modifies memory in place, and should\n   * only be used with caution.\n   * @param _newSelector The new 4-byte selector\n   * @param _buf The encoded contract args\n   */\n  function swapSelector(bytes4 _newSelector, bytes memory _buf) internal pure {\n    require(_buf.length > 4 - 1);\n    uint256 _mask = LOW_28_MASK;\n    assembly {\n      // load the first word of\n      let _word := mload(add(_buf, 0x20))\n      // mask out the top 4 bytes\n      // /x\n      _word := and(_word, _mask)\n      _word := or(_newSelector, _word)\n      mstore(add(_buf, 0x20), _word)\n    }\n  }\n}\n"
    },
    "contracts/shared/libraries/TypeCasts.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {TypedMemView} from \"./TypedMemView.sol\";\n\nlibrary TypeCasts {\n  using TypedMemView for bytes;\n  using TypedMemView for bytes29;\n\n  // alignment preserving cast\n  function addressToBytes32(address _addr) internal pure returns (bytes32) {\n    return bytes32(uint256(uint160(_addr)));\n  }\n\n  // alignment preserving cast\n  function bytes32ToAddress(bytes32 _buf) internal pure returns (address) {\n    return address(uint160(uint256(_buf)));\n  }\n}\n"
    },
    "contracts/shared/libraries/TypedMemView.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nlibrary TypedMemView {\n  // Why does this exist?\n  // the solidity `bytes memory` type has a few weaknesses.\n  // 1. You can't index ranges effectively\n  // 2. You can't slice without copying\n  // 3. The underlying data may represent any type\n  // 4. Solidity never deallocates memory, and memory costs grow\n  //    superlinearly\n\n  // By using a memory view instead of a `bytes memory` we get the following\n  // advantages:\n  // 1. Slices are done on the stack, by manipulating the pointer\n  // 2. We can index arbitrary ranges and quickly convert them to stack types\n  // 3. We can insert type info into the pointer, and typecheck at runtime\n\n  // This makes `TypedMemView` a useful tool for efficient zero-copy\n  // algorithms.\n\n  // Why bytes29?\n  // We want to avoid confusion between views, digests, and other common\n  // types so we chose a large and uncommonly used odd number of bytes\n  //\n  // Note that while bytes are left-aligned in a word, integers and addresses\n  // are right-aligned. This means when working in assembly we have to\n  // account for the 3 unused bytes on the righthand side\n  //\n  // First 5 bytes are a type flag.\n  // - ff_ffff_fffe is reserved for unknown type.\n  // - ff_ffff_ffff is reserved for invalid types/errors.\n  // next 12 are memory address\n  // next 12 are len\n  // bottom 3 bytes are empty\n\n  // Assumptions:\n  // - non-modification of memory.\n  // - No Solidity updates\n  // - - wrt free mem point\n  // - - wrt bytes representation in memory\n  // - - wrt memory addressing in general\n\n  // Usage:\n  // - create type constants\n  // - use `assertType` for runtime type assertions\n  // - - unfortunately we can't do this at compile time yet :(\n  // - recommended: implement modifiers that perform type checking\n  // - - e.g.\n  // - - `uint40 constant MY_TYPE = 3;`\n  // - - ` modifer onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n  // - instantiate a typed view from a bytearray using `ref`\n  // - use `index` to inspect the contents of the view\n  // - use `slice` to create smaller views into the same memory\n  // - - `slice` can increase the offset\n  // - - `slice can decrease the length`\n  // - - must specify the output type of `slice`\n  // - - `slice` will return a null view if you try to overrun\n  // - - make sure to explicitly check for this with `notNull` or `assertType`\n  // - use `equal` for typed comparisons.\n\n  // The null view\n  bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n  uint256 constant LOW_12_MASK = 0xffffffffffffffffffffffff;\n  uint256 constant TWENTY_SEVEN_BYTES = 8 * 27;\n  uint256 private constant _27_BYTES_IN_BITS = 8 * 27; // <--- also used this named constant where ever 216 is used.\n  uint256 private constant LOW_27_BYTES_MASK = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffff; // (1 << _27_BYTES_IN_BITS) - 1;\n\n  // ========== Custom Errors ===========\n\n  error TypedMemView__assertType_typeAssertionFailed(uint256 actual, uint256 expected);\n  error TypedMemView__index_overrun(uint256 loc, uint256 len, uint256 index, uint256 slice);\n  error TypedMemView__index_indexMoreThan32Bytes();\n  error TypedMemView__unsafeCopyTo_nullPointer();\n  error TypedMemView__unsafeCopyTo_invalidPointer();\n  error TypedMemView__unsafeCopyTo_identityOOG();\n  error TypedMemView__assertValid_validityAssertionFailed();\n\n  /**\n   * @notice          Changes the endianness of a uint256.\n   * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n   * @param _b        The unsigned integer to reverse\n   * @return          v - The reversed value\n   */\n  function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n    v = _b;\n\n    // swap bytes\n    v =\n      ((v >> 8) & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n      ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\n    // swap 2-byte long pairs\n    v =\n      ((v >> 16) & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n      ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\n    // swap 4-byte long pairs\n    v =\n      ((v >> 32) & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n      ((v & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) << 32);\n    // swap 8-byte long pairs\n    v =\n      ((v >> 64) & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n      ((v & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) << 64);\n    // swap 16-byte long pairs\n    v = (v >> 128) | (v << 128);\n  }\n\n  /**\n   * @notice      Create a mask with the highest `_len` bits set.\n   * @param _len  The length\n   * @return      mask - The mask\n   */\n  function leftMask(uint8 _len) private pure returns (uint256 mask) {\n    // ugly. redo without assembly?\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      mask := sar(sub(_len, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n    }\n  }\n\n  /**\n   * @notice      Return the null view.\n   * @return      bytes29 - The null view\n   */\n  function nullView() internal pure returns (bytes29) {\n    return NULL;\n  }\n\n  /**\n   * @notice      Check if the view is null.\n   * @return      bool - True if the view is null\n   */\n  function isNull(bytes29 memView) internal pure returns (bool) {\n    return memView == NULL;\n  }\n\n  /**\n   * @notice      Check if the view is not null.\n   * @return      bool - True if the view is not null\n   */\n  function notNull(bytes29 memView) internal pure returns (bool) {\n    return !isNull(memView);\n  }\n\n  /**\n   * @notice          Check if the view is of a invalid type and points to a valid location\n   *                  in memory.\n   * @dev             We perform this check by examining solidity's unallocated memory\n   *                  pointer and ensuring that the view's upper bound is less than that.\n   * @param memView   The view\n   * @return          ret - True if the view is invalid\n   */\n  function isNotValid(bytes29 memView) internal pure returns (bool ret) {\n    if (typeOf(memView) == 0xffffffffff) {\n      return true;\n    }\n    uint256 _end = end(memView);\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      ret := gt(_end, mload(0x40))\n    }\n  }\n\n  /**\n   * @notice          Require that a typed memory view be valid.\n   * @dev             Returns the view for easy chaining.\n   * @param memView   The view\n   * @return          bytes29 - The validated view\n   */\n  function assertValid(bytes29 memView) internal pure returns (bytes29) {\n    if (isNotValid(memView)) revert TypedMemView__assertValid_validityAssertionFailed();\n    return memView;\n  }\n\n  /**\n   * @notice          Return true if the memview is of the expected type. Otherwise false.\n   * @param memView   The view\n   * @param _expected The expected type\n   * @return          bool - True if the memview is of the expected type\n   */\n  function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n    return typeOf(memView) == _expected;\n  }\n\n  /**\n   * @notice          Require that a typed memory view has a specific type.\n   * @dev             Returns the view for easy chaining.\n   * @param memView   The view\n   * @param _expected The expected type\n   * @return          bytes29 - The view with validated type\n   */\n  function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n    if (!isType(memView, _expected)) {\n      revert TypedMemView__assertType_typeAssertionFailed(uint256(typeOf(memView)), uint256(_expected));\n    }\n    return memView;\n  }\n\n  /**\n   * @notice          Return an identical view with a different type.\n   * @param memView   The view\n   * @param _newType  The new type\n   * @return          newView - The new view with the specified type\n   */\n  function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n    // then | in the new type\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      // shift off the top 5 bytes\n      newView := or(and(memView, LOW_27_BYTES_MASK), shl(_27_BYTES_IN_BITS, _newType))\n    }\n  }\n\n  /**\n   * @notice          Unsafe raw pointer construction. This should generally not be called\n   *                  directly. Prefer `ref` wherever possible.\n   * @dev             Unsafe raw pointer construction. This should generally not be called\n   *                  directly. Prefer `ref` wherever possible.\n   * @param _type     The type\n   * @param _loc      The memory address\n   * @param _len      The length\n   * @return          newView - The new view with the specified type, location and length\n   */\n  function unsafeBuildUnchecked(\n    uint256 _type,\n    uint256 _loc,\n    uint256 _len\n  ) private pure returns (bytes29 newView) {\n    uint256 _uint96Bits = 96;\n    uint256 _emptyBits = 24;\n\n    // Cast params to ensure input is of correct length\n    uint96 len_ = uint96(_len);\n    uint96 loc_ = uint96(_loc);\n    require(len_ == _len && loc_ == _loc, \"!truncated\");\n\n    assembly {\n      // solium-disable-previous-line security/no-inline-assembly\n      newView := shl(_uint96Bits, _type) // insert type\n      newView := shl(_uint96Bits, or(newView, loc_)) // insert loc\n      newView := shl(_emptyBits, or(newView, len_)) // empty bottom 3 bytes\n    }\n  }\n\n  /**\n   * @notice          Instantiate a new memory view. This should generally not be called\n   *                  directly. Prefer `ref` wherever possible.\n   * @dev             Instantiate a new memory view. This should generally not be called\n   *                  directly. Prefer `ref` wherever possible.\n   * @param _type     The type\n   * @param _loc      The memory address\n   * @param _len      The length\n   * @return          newView - The new view with the specified type, location and length\n   */\n  function build(\n    uint256 _type,\n    uint256 _loc,\n    uint256 _len\n  ) internal pure returns (bytes29 newView) {\n    uint256 _end = _loc + _len;\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      if gt(_end, mload(0x40)) {\n        _end := 0\n      }\n    }\n    if (_end == 0) {\n      return NULL;\n    }\n    newView = unsafeBuildUnchecked(_type, _loc, _len);\n  }\n\n  /**\n   * @notice          Instantiate a memory view from a byte array.\n   * @dev             Note that due to Solidity memory representation, it is not possible to\n   *                  implement a deref, as the `bytes` type stores its len in memory.\n   * @param arr       The byte array\n   * @param newType   The type\n   * @return          bytes29 - The memory view\n   */\n  function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n    uint256 _len = arr.length;\n\n    uint256 _loc;\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      _loc := add(arr, 0x20) // our view is of the data, not the struct\n    }\n\n    return build(newType, _loc, _len);\n  }\n\n  /**\n   * @notice          Return the associated type information.\n   * @param memView   The memory view\n   * @return          _type - The type associated with the view\n   */\n  function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      // 216 == 256 - 40\n      _type := shr(_27_BYTES_IN_BITS, memView) // shift out lower 24 bytes\n    }\n  }\n\n  /**\n   * @notice          Return the memory address of the underlying bytes.\n   * @param memView   The view\n   * @return          _loc - The memory address\n   */\n  function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n    uint256 _mask = LOW_12_MASK; // assembly can't use globals\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      // 120 bits = 12 bytes (the encoded loc) + 3 bytes (empty low space)\n      _loc := and(shr(120, memView), _mask)\n    }\n  }\n\n  /**\n   * @notice          The number of memory words this memory view occupies, rounded up.\n   * @param memView   The view\n   * @return          uint256 - The number of memory words\n   */\n  function words(bytes29 memView) internal pure returns (uint256) {\n    return (uint256(len(memView)) + 31) / 32;\n  }\n\n  /**\n   * @notice          The in-memory footprint of a fresh copy of the view.\n   * @param memView   The view\n   * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n   */\n  function footprint(bytes29 memView) internal pure returns (uint256) {\n    return words(memView) * 32;\n  }\n\n  /**\n   * @notice          The number of bytes of the view.\n   * @param memView   The view\n   * @return          _len - The length of the view\n   */\n  function len(bytes29 memView) internal pure returns (uint96 _len) {\n    uint256 _mask = LOW_12_MASK; // assembly can't use globals\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      _len := and(shr(24, memView), _mask)\n    }\n  }\n\n  /**\n   * @notice          Returns the endpoint of `memView`.\n   * @param memView   The view\n   * @return          uint256 - The endpoint of `memView`\n   */\n  function end(bytes29 memView) internal pure returns (uint256) {\n    unchecked {\n      return loc(memView) + len(memView);\n    }\n  }\n\n  /**\n   * @notice          Safe slicing without memory modification.\n   * @param memView   The view\n   * @param _index    The start index\n   * @param _len      The length\n   * @param newType   The new type\n   * @return          bytes29 - The new view\n   */\n  function slice(\n    bytes29 memView,\n    uint256 _index,\n    uint256 _len,\n    uint40 newType\n  ) internal pure returns (bytes29) {\n    uint256 _loc = loc(memView);\n\n    // Ensure it doesn't overrun the view\n    if (_loc + _index + _len > end(memView)) {\n      return NULL;\n    }\n\n    _loc = _loc + _index;\n    return build(newType, _loc, _len);\n  }\n\n  /**\n   * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n   * @param memView   The view\n   * @param _len      The length\n   * @param newType   The new type\n   * @return          bytes29 - The new view\n   */\n  function prefix(\n    bytes29 memView,\n    uint256 _len,\n    uint40 newType\n  ) internal pure returns (bytes29) {\n    return slice(memView, 0, _len, newType);\n  }\n\n  /**\n   * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n   * @param memView   The view\n   * @param _len      The length\n   * @param newType   The new type\n   * @return          bytes29 - The new view\n   */\n  function postfix(\n    bytes29 memView,\n    uint256 _len,\n    uint40 newType\n  ) internal pure returns (bytes29) {\n    return slice(memView, uint256(len(memView)) - _len, _len, newType);\n  }\n\n  /**\n   * @notice          Load up to 32 bytes from the view onto the stack.\n   * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n   *                  This can be immediately cast to a smaller fixed-length byte array.\n   *                  To automatically cast to an integer, use `indexUint`.\n   * @param memView   The view\n   * @param _index    The index\n   * @param _bytes    The bytes\n   * @return          result - The 32 byte result\n   */\n  function index(\n    bytes29 memView,\n    uint256 _index,\n    uint8 _bytes\n  ) internal pure returns (bytes32 result) {\n    if (_bytes == 0) {\n      return bytes32(0);\n    }\n    if (_index + _bytes > len(memView)) {\n      // \"TypedMemView/index - Overran the view. Slice is at {loc} with length {len}. Attempted to index at offset {index} with length {slice},\n      revert TypedMemView__index_overrun(loc(memView), len(memView), _index, uint256(_bytes));\n    }\n    if (_bytes > 32) revert TypedMemView__index_indexMoreThan32Bytes();\n\n    uint8 bitLength;\n    unchecked {\n      bitLength = _bytes * 8;\n    }\n    uint256 _loc = loc(memView);\n    uint256 _mask = leftMask(bitLength);\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      result := and(mload(add(_loc, _index)), _mask)\n    }\n  }\n\n  /**\n   * @notice          Parse an unsigned integer from the view at `_index`.\n   * @dev             Requires that the view have >= `_bytes` bytes following that index.\n   * @param memView   The view\n   * @param _index    The index\n   * @param _bytes    The bytes\n   * @return          result - The unsigned integer\n   */\n  function indexUint(\n    bytes29 memView,\n    uint256 _index,\n    uint8 _bytes\n  ) internal pure returns (uint256 result) {\n    return uint256(index(memView, _index, _bytes)) >> ((32 - _bytes) * 8);\n  }\n\n  /**\n   * @notice          Parse an unsigned integer from LE bytes.\n   * @param memView   The view\n   * @param _index    The index\n   * @param _bytes    The bytes\n   * @return          result - The unsigned integer\n   */\n  function indexLEUint(\n    bytes29 memView,\n    uint256 _index,\n    uint8 _bytes\n  ) internal pure returns (uint256 result) {\n    return reverseUint256(uint256(index(memView, _index, _bytes)));\n  }\n\n  /**\n   * @notice          Parse an address from the view at `_index`. Requires that the view have >= 20 bytes\n   *                  following that index.\n   * @param memView   The view\n   * @param _index    The index\n   * @return          address - The address\n   */\n  function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n    return address(uint160(indexUint(memView, _index, 20)));\n  }\n\n  /**\n   * @notice          Return the keccak256 hash of the underlying memory\n   * @param memView   The view\n   * @return          digest - The keccak256 hash of the underlying memory\n   */\n  function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n    uint256 _loc = loc(memView);\n    uint256 _len = len(memView);\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      digest := keccak256(_loc, _len)\n    }\n  }\n\n  /**\n   * @notice          Return true if the underlying memory is equal. Else false.\n   * @param left      The first view\n   * @param right     The second view\n   * @return          bool - True if the underlying memory is equal\n   */\n  function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n    return (loc(left) == loc(right) && len(left) == len(right)) || keccak(left) == keccak(right);\n  }\n\n  /**\n   * @notice          Return false if the underlying memory is equal. Else true.\n   * @param left      The first view\n   * @param right     The second view\n   * @return          bool - False if the underlying memory is equal\n   */\n  function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n    return !untypedEqual(left, right);\n  }\n\n  /**\n   * @notice          Compares type equality.\n   * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n   * @param left      The first view\n   * @param right     The second view\n   * @return          bool - True if the types are the same\n   */\n  function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n    return left == right || (typeOf(left) == typeOf(right) && keccak(left) == keccak(right));\n  }\n\n  /**\n   * @notice          Compares type inequality.\n   * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n   * @param left      The first view\n   * @param right     The second view\n   * @return          bool - True if the types are not the same\n   */\n  function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n    return !equal(left, right);\n  }\n\n  /**\n   * @notice          Copy the view to a location, return an unsafe memory reference\n   * @dev             Super Dangerous direct memory access.\n   *\n   *                  This reference can be overwritten if anything else modifies memory (!!!).\n   *                  As such it MUST be consumed IMMEDIATELY.\n   *                  This function is private to prevent unsafe usage by callers.\n   * @param memView   The view\n   * @param _newLoc   The new location\n   * @return          written - the unsafe memory reference\n   */\n  function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n    if (isNull(memView)) revert TypedMemView__unsafeCopyTo_nullPointer();\n    if (isNotValid(memView)) revert TypedMemView__unsafeCopyTo_invalidPointer();\n\n    uint256 _len = len(memView);\n    uint256 _oldLoc = loc(memView);\n\n    uint256 ptr;\n    bool res;\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      ptr := mload(0x40)\n      // revert if we're writing in occupied memory\n      if gt(ptr, _newLoc) {\n        revert(0x60, 0x20) // empty revert message\n      }\n\n      // use the identity precompile to copy\n      // guaranteed not to fail, so pop the success\n      res := staticcall(gas(), 4, _oldLoc, _len, _newLoc, _len)\n    }\n    if (!res) revert TypedMemView__unsafeCopyTo_identityOOG();\n    written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n  }\n\n  /**\n   * @notice          Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to\n   *                  the new memory\n   * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n   * @param memView   The view\n   * @return          ret - The view pointing to the new memory\n   */\n  function clone(bytes29 memView) internal view returns (bytes memory ret) {\n    uint256 ptr;\n    uint256 _len = len(memView);\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      ptr := mload(0x40) // load unused memory pointer\n      ret := ptr\n    }\n    unchecked {\n      unsafeCopyTo(memView, ptr + 0x20);\n    }\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n      mstore(ptr, _len) // write len of new array (in bytes)\n    }\n  }\n\n  /**\n   * @notice          Join the views in memory, return an unsafe reference to the memory.\n   * @dev             Super Dangerous direct memory access.\n   *\n   *                  This reference can be overwritten if anything else modifies memory (!!!).\n   *                  As such it MUST be consumed IMMEDIATELY.\n   *                  This function is private to prevent unsafe usage by callers.\n   * @param memViews  The views\n   * @return          unsafeView - The conjoined view pointing to the new memory\n   */\n  function unsafeJoin(bytes29[] memory memViews, uint256 _location) private view returns (bytes29 unsafeView) {\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      let ptr := mload(0x40)\n      // revert if we're writing in occupied memory\n      if gt(ptr, _location) {\n        revert(0x60, 0x20) // empty revert message\n      }\n    }\n\n    uint256 _offset = 0;\n    uint256 _len = memViews.length;\n    for (uint256 i = 0; i < _len; ) {\n      bytes29 memView = memViews[i];\n      unchecked {\n        unsafeCopyTo(memView, _location + _offset);\n        _offset += len(memView);\n        ++i;\n      }\n    }\n    unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n  }\n\n  /**\n   * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n   * @param memViews  The views\n   * @return          bytes32 - The keccak256 digest\n   */\n  function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n    uint256 ptr;\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      ptr := mload(0x40) // load unused memory pointer\n    }\n    return keccak(unsafeJoin(memViews, ptr));\n  }\n\n  /**\n   * @notice          copies all views, joins them into a new bytearray.\n   * @param memViews  The views\n   * @return          ret - The new byte array\n   */\n  function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n    uint256 ptr;\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      ptr := mload(0x40) // load unused memory pointer\n    }\n\n    bytes29 _newView;\n    unchecked {\n      _newView = unsafeJoin(memViews, ptr + 0x20);\n    }\n    uint256 _written = len(_newView);\n    uint256 _footprint = footprint(_newView);\n\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      // store the legnth\n      mstore(ptr, _written)\n      // new pointer is old + 0x20 + the footprint of the body\n      mstore(0x40, add(add(ptr, _footprint), 0x20))\n      ret := ptr\n    }\n  }\n}\n"
    }
  }
}}