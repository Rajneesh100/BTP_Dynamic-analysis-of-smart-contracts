// SPDX-License-Identifier: MIT
/*
*    ===============================================================
*               launchpad.social.top : presaleFactory.sol
*                 Webiste: https://launchpad.social.top
*    ===============================================================
*/
pragma solidity ^0.8.17;library SafeMath{function tryAdd(uint256 a,uint256 b)internal pure returns(bool,uint256){unchecked{uint256 c=a+b;if(c<a)return(false,0);return(true,c);}}function trySub(uint256 a,uint256 b)internal pure returns(bool,uint256){unchecked{if(b>a)return(false,0);return(true,a - b);}}function tryMul(uint256 a,uint256 b)internal pure returns(bool,uint256){unchecked{if(a==0)return(true,0);uint256 c=a * b;if(c/a!=b)return(false,0);return(true,c);}}function tryDiv(uint256 a,uint256 b)internal pure returns(bool,uint256){unchecked{if(b==0)return(false,0);return(true,a/b);}}function tryMod(uint256 a,uint256 b)internal pure returns(bool,uint256){unchecked{if(b==0)return(false,0);return(true,a % b);}}function add(uint256 a,uint256 b)internal pure returns(uint256){return a+b;}function sub(uint256 a,uint256 b)internal pure returns(uint256){return a - b;}function mul(uint256 a,uint256 b)internal pure returns(uint256){return a * b;}function div(uint256 a,uint256 b)internal pure returns(uint256){return a/b;}function mod(uint256 a,uint256 b)internal pure returns(uint256){return a % b;}function sub(uint256 a,uint256 b,string memory errorMessage)internal pure returns(uint256){unchecked{require(b <=a,errorMessage);return a - b;}}function div(uint256 a,uint256 b,string memory errorMessage)internal pure returns(uint256){unchecked{require(b>0,errorMessage);return a/b;}}function mod(uint256 a,uint256 b,string memory errorMessage)internal pure returns(uint256){unchecked{require(b>0,errorMessage);return a % b;}}}interface IERC20{event Transfer(address indexed from,address indexed to,uint256 value);event Approval(address indexed owner,address indexed spender,uint256 value);function totalSupply()external view returns(uint256);function balanceOf(address account)external view returns(uint256);function transfer(address to,uint256 amount)external returns(bool);function allowance(address owner,address spender)external view returns(uint256);function approve(address spender,uint256 amount)external returns(bool);function transferFrom(address from,address to,uint256 amount)external returns(bool);}abstract contract Context{function _msgSender()internal view virtual returns(address){return msg.sender;}function _msgData()internal view virtual returns(bytes calldata){return msg.data;}}abstract contract Ownable is Context{address private _owner;event OwnershipTransferred(address indexed previousOwner,address indexed newOwner);constructor(){_transferOwnership(_msgSender());}modifier onlyOwner(){_checkOwner();_;}function owner()public view virtual returns(address){return _owner;}function _checkOwner()internal view virtual{require(owner()==_msgSender(),"Ownable:caller is not the owner");}function renounceOwnership()public virtual onlyOwner{_transferOwnership(address(0));}function transferOwnership(address newOwner)public virtual onlyOwner{require(newOwner!=address(0),"Ownable:new owner is the zero address");_transferOwnership(newOwner);}function _transferOwnership(address newOwner)internal virtual{address oldOwner=_owner;_owner=newOwner;emit OwnershipTransferred(oldOwner,newOwner);}}library Address{function isContract(address account)internal view returns(bool){return account.code.length>0;}function sendValue(address payable recipient,uint256 amount)internal{require(address(this).balance>=amount,"Address:insufficient balance");(bool success,)=recipient.call{value:amount}("");require(success,"Address:unable to send value,recipient may have reverted");}function functionCall(address target,bytes memory data)internal returns(bytes memory){return functionCallWithValue(target,data,0,"Address:low-level call failed");}function functionCall(address target,bytes memory data,string memory errorMessage)internal returns(bytes memory){return functionCallWithValue(target,data,0,errorMessage);}function functionCallWithValue(address target,bytes memory data,uint256 value)internal returns(bytes memory){return functionCallWithValue(target,data,value,"Address:low-level call with value failed");}function functionCallWithValue(address target,bytes memory data,uint256 value,string memory errorMessage)internal returns(bytes memory){require(address(this).balance>=value,"Address:insufficient balance for call");(bool success,bytes memory returndata)=target.call{value:value}(data);return verifyCallResultFromTarget(target,success,returndata,errorMessage);}function functionStaticCall(address target,bytes memory data)internal view returns(bytes memory){return functionStaticCall(target,data,"Address:low-level static call failed");}function functionStaticCall(address target,bytes memory data,string memory errorMessage)internal view returns(bytes memory){(bool success,bytes memory returndata)=target.staticcall(data);return verifyCallResultFromTarget(target,success,returndata,errorMessage);}function functionDelegateCall(address target,bytes memory data)internal returns(bytes memory){return functionDelegateCall(target,data,"Address:low-level delegate call failed");}function functionDelegateCall(address target,bytes memory data,string memory errorMessage)internal returns(bytes memory){(bool success,bytes memory returndata)=target.delegatecall(data);return verifyCallResultFromTarget(target,success,returndata,errorMessage);}function verifyCallResultFromTarget(address target,bool success,bytes memory returndata,string memory errorMessage)internal view returns(bytes memory){if(success){if(returndata.length==0){require(isContract(target),"Address:call to non-contract");}return returndata;}else{_revert(returndata,errorMessage);}}function verifyCallResult(bool success,bytes memory returndata,string memory errorMessage)internal pure returns(bytes memory){if(success){return returndata;}else{_revert(returndata,errorMessage);}}function _revert(bytes memory returndata,string memory errorMessage)private pure{if(returndata.length>0){assembly{let returndata_size :=mload(returndata)revert(add(32,returndata),returndata_size)}}else{revert(errorMessage);}}}interface IERC20Permit{function permit(address owner,address spender,uint256 value,uint256 deadline,uint8 v,bytes32 r,bytes32 s)external;function nonces(address owner)external view returns(uint256);function DOMAIN_SEPARATOR()external view returns(bytes32);}library SafeERC20{using Address for address;function safeTransfer(IERC20 token,address to,uint256 value)internal{_callOptionalReturn(token,abi.encodeWithSelector(token.transfer.selector,to,value));}function safeTransferFrom(IERC20 token,address from,address to,uint256 value)internal{_callOptionalReturn(token,abi.encodeWithSelector(token.transferFrom.selector,from,to,value));}function safeApprove(IERC20 token,address spender,uint256 value)internal{require((value==0)||(token.allowance(address(this),spender)==0),"SafeERC20:approve from non-zero to non-zero allowance");_callOptionalReturn(token,abi.encodeWithSelector(token.approve.selector,spender,value));}function safeIncreaseAllowance(IERC20 token,address spender,uint256 value)internal{uint256 oldAllowance=token.allowance(address(this),spender);_callOptionalReturn(token,abi.encodeWithSelector(token.approve.selector,spender,oldAllowance+value));}function safeDecreaseAllowance(IERC20 token,address spender,uint256 value)internal{unchecked{uint256 oldAllowance=token.allowance(address(this),spender);require(oldAllowance>=value,"SafeERC20:decreased allowance below zero");_callOptionalReturn(token,abi.encodeWithSelector(token.approve.selector,spender,oldAllowance - value));}}function forceApprove(IERC20 token,address spender,uint256 value)internal{bytes memory approvalCall=abi.encodeWithSelector(token.approve.selector,spender,value);if(!_callOptionalReturnBool(token,approvalCall)){_callOptionalReturn(token,abi.encodeWithSelector(token.approve.selector,spender,0));_callOptionalReturn(token,approvalCall);}}function safePermit(IERC20Permit token,address owner,address spender,uint256 value,uint256 deadline,uint8 v,bytes32 r,bytes32 s)internal{uint256 nonceBefore=token.nonces(owner);token.permit(owner,spender,value,deadline,v,r,s);uint256 nonceAfter=token.nonces(owner);require(nonceAfter==nonceBefore+1,"SafeERC20:permit did not succeed");}function _callOptionalReturn(IERC20 token,bytes memory data)private{bytes memory returndata=address(token).functionCall(data,"SafeERC20:low-level call failed");require(returndata.length==0 || abi.decode(returndata,(bool)),"SafeERC20:ERC20 operation did not succeed");}function _callOptionalReturnBool(IERC20 token,bytes memory data)private returns(bool){(bool success,bytes memory returndata)=address(token).call(data);return success &&(returndata.length==0 || abi.decode(returndata,(bool)))&& Address.isContract(address(token));}}interface IERC20Metadata is IERC20{function name()external view returns(string memory);function symbol()external view returns(string memory);function decimals()external view returns(uint8);}contract PreSale is Ownable{using SafeMath for uint256;using SafeERC20 for IERC20;using SafeERC20 for IERC20Metadata;uint public constant version=1;uint public constant finalizeServiceFee=5;uint public constant emergencyWithdrawalServiceFee=10;address serviceReceiver;uint256 public rate;address public saleToken;uint public saleTokenDec;uint256 public minBuyLimit;uint256 public maxBuyLimit;uint256 public preSaleStartTime;uint256 public preSaleEndTime;uint256 public totalTokensforSale;uint256 public totalTokensSold;address[] public tokenWL;mapping(address=> bool)public tokenWLEnabled;mapping(address=> uint256)public tokenPrices;address[] public contributors;mapping(address=> ContributorDetails)public contributorDetails;bool public isCancelled;bool public isFinalized;struct ContributorDetails{uint256 amount;bool isClaimed;bool isRefunded;bool isExists;mapping(address=> uint256)paidAmount;}modifier onlyContributor(){require(contributorDetails[msg.sender].amount>0,"PreSale:You have not bought any tokens");_;}modifier cancelled(){require(isCancelled,"PreSale:Sale is not cancelled");_;}modifier beforeSaleStart(){if(preSaleStartTime!=0){require(block.timestamp<preSaleStartTime,"PreSale:Sale has already started");}_;}modifier beforeSaleEnd(){require(block.timestamp<preSaleEndTime,"PreSale:Sale has already ended");_;}modifier afterSaleEnd(){require(block.timestamp>preSaleEndTime,"PreSale:Sale has not ended yet");_;}modifier saleIsLive(){require(block.timestamp>preSaleStartTime,"PreSale:Sale has not started");require(block.timestamp<preSaleEndTime,"PreSale:Sale has already ended");require(!isCancelled,"PreSale:Sale is cancelled");_;}modifier saleValid(uint256 _preSaleStartTime,uint256 _preSaleEndTime){require(block.timestamp<_preSaleStartTime,"PreSale:Starting time is less than current TimeStamp");require(_preSaleStartTime<_preSaleEndTime,"PreSale:Invalid PreSale Dates");_;}constructor(uint256 _rate,address _saleToken,uint256 _totalTokensforSale,uint256 _minBuyLimit,uint256 _maxBuyLimit,uint256 _preSaleStartTime,uint256 _preSaleEndTime,address[] memory _tokenWL,uint256[] memory _tokenPrices,address _serviceReceiver){serviceReceiver=_serviceReceiver;rate=_rate;saleToken=_saleToken;saleTokenDec=IERC20Metadata(saleToken).decimals();totalTokensforSale=_totalTokensforSale;minBuyLimit=_minBuyLimit;maxBuyLimit=_maxBuyLimit;preSaleStartTime=_preSaleStartTime;preSaleEndTime=_preSaleEndTime;for(uint i=0;i<_tokenWL.length;i++){tokenWL.push(_tokenWL[i]);tokenWLEnabled[_tokenWL[i]]=true;tokenPrices[_tokenWL[i]]=_tokenPrices[i];}}function getTotalContributors()external view returns(uint256){return contributors.length;}function setSalePeriodParams(uint256 _preSaleStartTime,uint256 _preSaleEndTime)external onlyOwner beforeSaleStart saleValid(_preSaleStartTime,_preSaleEndTime){preSaleStartTime=_preSaleStartTime;preSaleEndTime=_preSaleEndTime;}function cancel()external onlyOwner beforeSaleEnd{require(!isFinalized,"PreSale:Already finalized");require(!isCancelled,"PreSale:Sale is already cancelled");isCancelled=true;}function setMinMaxBuyLimit(uint256 _minBuyLimit,uint256 _maxBuyLimit)external onlyOwner{minBuyLimit=_minBuyLimit;maxBuyLimit=_maxBuyLimit;}function getTokenAmount(address token,uint256 amount)public view returns(uint256){uint256 amtOut;if(token!=address(0)){require(tokenWLEnabled[token]==true,"PreSale:Token not whitelisted");uint256 price=tokenPrices[token];amtOut=amount.mul(10 ** saleTokenDec).div(price);}else{amtOut=amount.mul(10 ** saleTokenDec).div(rate);}return amtOut;}function buyToken(address _token,uint256 _amount)external payable saleIsLive{uint256 saleTokenAmt;uint256 paidAmount;if(_token!=address(0)){saleTokenAmt=getTokenAmount(_token,_amount);paidAmount=_amount;}else{saleTokenAmt=getTokenAmount(address(0),msg.value);paidAmount=msg.value;}ContributorDetails storage contributor=contributorDetails[msg.sender];require(minBuyLimit==0 || saleTokenAmt>=minBuyLimit,"PreSale:Min buy limit not reached");require(maxBuyLimit==0 || contributor.amount+saleTokenAmt <=maxBuyLimit,"PreSale:Max buy limit reached");require((totalTokensSold+saleTokenAmt)<=totalTokensforSale,"PreSale:Total Token Sale Reached");if(_token!=address(0)){require(_amount>0,"PreSale:Cannot buy with zero amount");IERC20(_token).safeTransferFrom(msg.sender,address(this),_amount);contributor.paidAmount[_token]+=paidAmount;}else{require(msg.value>0,"PreSale:Cannot buy with zero amount");contributor.paidAmount[address(0)]+=paidAmount;}totalTokensSold+=saleTokenAmt;contributor.amount+=saleTokenAmt;if(!contributor.isExists){contributor.isExists=true;contributors.push(msg.sender);}}function claim()external afterSaleEnd onlyContributor{require(!isCancelled,"PreSale:Sale is cancelled");ContributorDetails storage contributor=contributorDetails[msg.sender];require(contributor.isClaimed==false,"PreSale:Already claimed");uint256 tokensforWithdraw=contributor.amount;IERC20(saleToken).safeTransfer(msg.sender,tokensforWithdraw);contributor.isClaimed=true;}function withdrawCurrency(uint256 _amount,address _to,uint _feePercent)private{if(_amount>0){uint256 fee=_amount.mul(_feePercent).div(100);payable(serviceReceiver).transfer(fee);payable(_to).transfer(_amount.sub(fee));}}function withdrawToken(address _token,uint256 _amount,address _to,uint _feePercent)private{if(_amount>0){uint256 fee=_amount.mul(_feePercent).div(100);IERC20(_token).safeTransfer(serviceReceiver,fee);IERC20(_token).safeTransfer(_to,_amount.sub(fee));}}function contributorEmergencyWithdrawal()external saleIsLive onlyContributor{ContributorDetails storage contributor=contributorDetails[msg.sender];uint256 totalPaidAmountEth=contributor.paidAmount[address(0)];withdrawCurrency(totalPaidAmountEth,msg.sender,emergencyWithdrawalServiceFee);contributor.paidAmount[address(0)]=0;for(uint i=0;i<tokenWL.length;i++){withdrawToken(tokenWL[i],contributor.paidAmount[tokenWL[i]],msg.sender,emergencyWithdrawalServiceFee);contributor.paidAmount[tokenWL[i]]=0;}totalTokensSold -=contributor.amount;contributor.amount=0;}function withdrawCancelledTokens()external onlyOwner cancelled{IERC20(saleToken).safeTransfer(msg.sender,IERC20(saleToken).balanceOf(address(this)));}function withdrawContribution()external cancelled{ContributorDetails storage contributor=contributorDetails[msg.sender];require(!contributor.isRefunded,"PreSale:Already refunded");uint256 paidAmountEth=contributor.paidAmount[address(0)];if(paidAmountEth>0){payable(msg.sender).transfer(paidAmountEth);}for(uint i=0;i<tokenWL.length;i++){uint256 paidAmountToken=contributor.paidAmount[tokenWL[i]];if(paidAmountToken>0){IERC20(tokenWL[i]).safeTransfer(msg.sender,paidAmountToken);}}contributor.isRefunded=true;}function finalize()external onlyOwner afterSaleEnd{require(!isCancelled,"PreSale:Sale is cancelled");require(!isFinalized,"PreSale:Already finalized");withdrawCurrency(address(this).balance,owner(),finalizeServiceFee);for(uint i=0;i<tokenWL.length;i++){withdrawToken(tokenWL[i],IERC20(tokenWL[i]).balanceOf(address(this)),owner(),finalizeServiceFee);}IERC20(saleToken).safeTransfer(owner(),IERC20(saleToken).balanceOf(address(this)).sub(totalTokensSold));isFinalized=true;}}contract PreSaleFactory is Ownable{using SafeMath for uint256;using SafeERC20 for IERC20;mapping(address=> address[])public userPreSales;address[] public preSales;address public serviceReceiver;uint256 public serviceFee;event PreSaleCreated(address preSaleAddress);constructor(address _serviceReceiver,uint256 _serviceFee){serviceReceiver=_serviceReceiver;serviceFee=_serviceFee;}function setServiceReceiver(address _serviceReceiver)external onlyOwner{serviceReceiver=_serviceReceiver;}function setServiceFee(uint256 _serviceFee)external onlyOwner{serviceFee=_serviceFee;}function createPreSale(uint256 _rate,address _saleToken,uint256 _totalTokensforSale,uint256 _minBuyLimit,uint256 _maxBuyLimit,uint256 _preSaleStartTime,uint256 _preSaleEndTime,address[] memory _tokenWL,uint256[] memory _tokenPrices)payable external{require(msg.value>=serviceFee,"Service fee not met!");require(_rate!=0,"Invalid Native Currency rate!");PreSale _preSale=new PreSale(_rate,_saleToken,_totalTokensforSale,_minBuyLimit,_maxBuyLimit,_preSaleStartTime,_preSaleEndTime,_tokenWL,_tokenPrices,serviceReceiver);IERC20 _token=IERC20(_saleToken);_token.safeTransferFrom(msg.sender,address(_preSale),_totalTokensforSale);_preSale.transferOwnership(address(msg.sender));preSales.push(address(_preSale));userPreSales[msg.sender].push(address(_preSale));emit PreSaleCreated(address(_preSale));payable(serviceReceiver).transfer(msg.value);}function withdraw(address token,uint256 amt)public onlyOwner{IERC20(token).safeTransfer(msg.sender,amt);}function withdrawAll(address token)public onlyOwner{uint256 amt=IERC20(token).balanceOf(address(this));withdraw(token,amt);}function withdrawCurrency(uint256 amt)public onlyOwner{payable(msg.sender).transfer(amt);}}