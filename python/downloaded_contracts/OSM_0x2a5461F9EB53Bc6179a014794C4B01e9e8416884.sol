{{
  "language": "Solidity",
  "sources": {
    "lib/geb-fsm/src/OSM.sol": {
      "content": "pragma solidity 0.6.7;\n\nimport \"geb-treasury-reimbursement/reimbursement/single/NoSetupNoAuthIncreasingTreasuryReimbursement.sol\";\n\nabstract contract DSValueLike {\n    function getResultWithValidity() virtual external view returns (uint256, bool);\n}\nabstract contract FSMWrapperLike {\n    function renumerateCaller(address) virtual external;\n}\n\ncontract OSM {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    /**\n     * @notice Add auth to an account\n     * @param account Account to add auth to\n     */\n    function addAuthorization(address account) virtual external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    /**\n     * @notice Remove auth from an account\n     * @param account Account to remove auth from\n     */\n    function removeAuthorization(address account) virtual external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    /**\n    * @notice Checks whether msg.sender can call an authed function\n    **/\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"OSM/account-not-authorized\");\n        _;\n    }\n\n    // --- Stop ---\n    uint256 public stopped;\n    modifier stoppable { require(stopped == 0, \"OSM/is-stopped\"); _; }\n\n    // --- Variables ---\n    address public priceSource;\n    uint16  constant ONE_HOUR = uint16(3600);\n    uint16  public updateDelay = ONE_HOUR;\n    uint64  public lastUpdateTime;\n\n    // --- Structs ---\n    struct Feed {\n        uint128 value;\n        uint128 isValid;\n    }\n\n    Feed currentFeed;\n    Feed nextFeed;\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event ModifyParameters(bytes32 parameter, uint256 val);\n    event ModifyParameters(bytes32 parameter, address val);\n    event Start();\n    event Stop();\n    event ChangePriceSource(address priceSource);\n    event ChangeDelay(uint16 delay);\n    event RestartValue();\n    event UpdateResult(uint256 newMedian, uint256 lastUpdateTime);\n\n    constructor (address priceSource_) public {\n        authorizedAccounts[msg.sender] = 1;\n        priceSource = priceSource_;\n        if (priceSource != address(0)) {\n          (uint256 priceFeedValue, bool hasValidValue) = getPriceSourceUpdate();\n          if (hasValidValue) {\n            nextFeed = Feed(uint128(uint(priceFeedValue)), 1);\n            currentFeed = nextFeed;\n            lastUpdateTime = latestUpdateTime(currentTime());\n            emit UpdateResult(uint(currentFeed.value), lastUpdateTime);\n          }\n        }\n        emit AddAuthorization(msg.sender);\n        emit ChangePriceSource(priceSource);\n    }\n\n    // --- Math ---\n    function addition(uint64 x, uint64 y) internal pure returns (uint64 z) {\n        z = x + y;\n        require(z >= x);\n    }\n\n    // --- Core Logic ---\n    /*\n    * @notify Stop the OSM\n    */\n    function stop() external isAuthorized {\n        stopped = 1;\n        emit Stop();\n    }\n    /*\n    * @notify Start the OSM\n    */\n    function start() external isAuthorized {\n        stopped = 0;\n        emit Start();\n    }\n\n    /*\n    * @notify Change the oracle from which the OSM reads\n    * @param priceSource_ The address of the oracle from which the OSM reads\n    */\n    function changePriceSource(address priceSource_) external isAuthorized {\n        priceSource = priceSource_;\n        emit ChangePriceSource(priceSource);\n    }\n\n    /*\n    * @notify Helper that returns the current block timestamp\n    */\n    function currentTime() internal view returns (uint) {\n        return block.timestamp;\n    }\n\n    /*\n    * @notify Return the latest update time\n    * @param timestamp Custom reference timestamp to determine the latest update time from\n    */\n    function latestUpdateTime(uint timestamp) internal view returns (uint64) {\n        require(updateDelay != 0, \"OSM/update-delay-is-zero\");\n        return uint64(timestamp - (timestamp % updateDelay));\n    }\n\n    /*\n    * @notify Change the delay between updates\n    * @param delay The new delay\n    */\n    function changeDelay(uint16 delay) external isAuthorized {\n        require(delay > 0, \"OSM/delay-is-zero\");\n        updateDelay = delay;\n        emit ChangeDelay(updateDelay);\n    }\n\n    /*\n    * @notify Restart/set to zero the feeds stored in the OSM\n    */\n    function restartValue() external isAuthorized {\n        currentFeed = nextFeed = Feed(0, 0);\n        stopped = 1;\n        emit RestartValue();\n    }\n\n    /*\n    * @notify View function that returns whether the delay between calls has been passed\n    */\n    function passedDelay() public view returns (bool ok) {\n        return currentTime() >= uint(addition(lastUpdateTime, uint64(updateDelay)));\n    }\n\n    /*\n    * @notify Update the price feeds inside the OSM\n    */\n    function updateResult() virtual external stoppable {\n        // Check if the delay passed\n        require(passedDelay(), \"OSM/not-passed\");\n        // Read the price from the median\n        (uint256 priceFeedValue, bool hasValidValue) = getPriceSourceUpdate();\n        // If the value is valid, update storage\n        if (hasValidValue) {\n            // Update state\n            currentFeed    = nextFeed;\n            nextFeed       = Feed(uint128(uint(priceFeedValue)), 1);\n            lastUpdateTime = latestUpdateTime(currentTime());\n            // Emit event\n            emit UpdateResult(uint(currentFeed.value), lastUpdateTime);\n        }\n    }\n\n    // --- Getters ---\n    /*\n    * @notify Internal helper that reads a price and its validity from the priceSource\n    */\n    function getPriceSourceUpdate() internal view returns (uint256, bool) {\n        try DSValueLike(priceSource).getResultWithValidity() returns (uint256 priceFeedValue, bool hasValidValue) {\n          return (priceFeedValue, hasValidValue);\n        }\n        catch(bytes memory) {\n          return (0, false);\n        }\n    }\n    /*\n    * @notify Return the current feed value and its validity\n    */\n    function getResultWithValidity() external view returns (uint256,bool) {\n        return (uint(currentFeed.value), currentFeed.isValid == 1);\n    }\n    /*\n    * @notify Return the next feed's value and its validity\n    */\n    function getNextResultWithValidity() external view returns (uint256,bool) {\n        return (nextFeed.value, nextFeed.isValid == 1);\n    }\n    /*\n    * @notify Return the current feed's value only if it's valid, otherwise revert\n    */\n    function read() external view returns (uint256) {\n        require(currentFeed.isValid == 1, \"OSM/no-current-value\");\n        return currentFeed.value;\n    }\n}\n\ncontract SelfFundedOSM is OSM, NoSetupNoAuthIncreasingTreasuryReimbursement {\n    constructor (address priceSource_) public OSM(priceSource_) {}\n\n    // --- Administration ---\n    /*\n    * @notify Modify a uint256 parameter\n    * @param parameter The parameter name\n    * @param val The new value for the parameter\n    */\n    function modifyParameters(bytes32 parameter, uint256 val) external isAuthorized {\n        if (parameter == \"baseUpdateCallerReward\") {\n          require(val < maxUpdateCallerReward, \"SelfFundedOSM/invalid-base-caller-reward\");\n          baseUpdateCallerReward = val;\n        }\n        else if (parameter == \"maxUpdateCallerReward\") {\n          require(val >= baseUpdateCallerReward, \"SelfFundedOSM/invalid-max-reward\");\n          maxUpdateCallerReward = val;\n        }\n        else if (parameter == \"perSecondCallerRewardIncrease\") {\n          require(val >= RAY, \"SelfFundedOSM/invalid-reward-increase\");\n          perSecondCallerRewardIncrease = val;\n        }\n        else if (parameter == \"maxRewardIncreaseDelay\") {\n          require(val > 0, \"SelfFundedOSM/invalid-max-increase-delay\");\n          maxRewardIncreaseDelay = val;\n        }\n        else revert(\"SelfFundedOSM/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, val);\n    }\n    /*\n    * @notify Modify an address parameter\n    * @param parameter The parameter name\n    * @param val The new value for the parameter\n    */\n    function modifyParameters(bytes32 parameter, address val) external isAuthorized {\n        if (parameter == \"treasury\") {\n          require(val != address(0), \"SelfFundedOSM/invalid-treasury\");\n          treasury = StabilityFeeTreasuryLike(val);\n        }\n        else revert(\"SelfFundedOSM/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, val);\n    }\n\n    /*\n    * @notify Update the price feeds inside the OSM\n    */\n    function updateResult() override external stoppable {\n        // Check if the delay passed\n        require(passedDelay(), \"SelfFundedOSM/not-passed\");\n        // Read the price from the median\n        (uint256 priceFeedValue, bool hasValidValue) = getPriceSourceUpdate();\n        // If the value is valid, update storage\n        if (hasValidValue) {\n            // Get the caller's reward\n            uint256 callerReward = getCallerReward(lastUpdateTime, updateDelay);\n            // Update state\n            currentFeed    = nextFeed;\n            nextFeed       = Feed(uint128(uint(priceFeedValue)), 1);\n            lastUpdateTime = latestUpdateTime(currentTime());\n            // Emit event\n            emit UpdateResult(uint(currentFeed.value), lastUpdateTime);\n            // Pay the caller\n            rewardCaller(msg.sender, callerReward);\n        }\n    }\n}\n\ncontract ExternallyFundedOSM is OSM {\n    // --- Variables ---\n    FSMWrapperLike public fsmWrapper;\n\n    // --- Evemts ---\n    event FailRenumerateCaller(address wrapper, address caller);\n\n    constructor (address priceSource_) public OSM(priceSource_) {}\n\n    // --- Administration ---\n    /*\n    * @notify Modify an address parameter\n    * @param parameter The parameter name\n    * @param val The new value for the parameter\n    */\n    function modifyParameters(bytes32 parameter, address val) external isAuthorized {\n        if (parameter == \"fsmWrapper\") {\n          require(val != address(0), \"ExternallyFundedOSM/invalid-fsm-wrapper\");\n          fsmWrapper = FSMWrapperLike(val);\n        }\n        else revert(\"ExternallyFundedOSM/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, val);\n    }\n\n    /*\n    * @notify Update the price feeds inside the OSM\n    */\n    function updateResult() override external stoppable {\n        // Check if the delay passed\n        require(passedDelay(), \"ExternallyFundedOSM/not-passed\");\n        // Check that the wrapper is set\n        require(address(fsmWrapper) != address(0), \"ExternallyFundedOSM/null-wrapper\");\n        // Read the price from the median\n        (uint256 priceFeedValue, bool hasValidValue) = getPriceSourceUpdate();\n        // If the value is valid, update storage\n        if (hasValidValue) {\n            // Update state\n            currentFeed    = nextFeed;\n            nextFeed       = Feed(uint128(uint(priceFeedValue)), 1);\n            lastUpdateTime = latestUpdateTime(currentTime());\n            // Emit event\n            emit UpdateResult(uint(currentFeed.value), lastUpdateTime);\n            // Pay the caller\n            try fsmWrapper.renumerateCaller(msg.sender) {}\n            catch(bytes memory revertReason) {\n              emit FailRenumerateCaller(address(fsmWrapper), msg.sender);\n            }\n        }\n    }\n}\n"
    },
    "lib/geb-fsm/lib/geb-treasury-reimbursement/src/reimbursement/single/NoSetupNoAuthIncreasingTreasuryReimbursement.sol": {
      "content": "pragma solidity 0.6.7;\r\n\r\nimport \"../../math/GebMath.sol\";\r\n\r\nabstract contract StabilityFeeTreasuryLike {\r\n    function getAllowance(address) virtual external view returns (uint, uint);\r\n    function systemCoin() virtual external view returns (address);\r\n    function pullFunds(address, address, uint) virtual external;\r\n}\r\n\r\ncontract NoSetupNoAuthIncreasingTreasuryReimbursement is GebMath {\r\n    // --- Variables ---\r\n    // Starting reward for the fee receiver/keeper\r\n    uint256 public baseUpdateCallerReward;          // [wad]\r\n    // Max possible reward for the fee receiver/keeper\r\n    uint256 public maxUpdateCallerReward;           // [wad]\r\n    // Max delay taken into consideration when calculating the adjusted reward\r\n    uint256 public maxRewardIncreaseDelay;          // [seconds]\r\n    // Rate applied to baseUpdateCallerReward every extra second passed beyond a certain point (e.g next time when a specific function needs to be called)\r\n    uint256 public perSecondCallerRewardIncrease;   // [ray]\r\n\r\n    // SF treasury\r\n    StabilityFeeTreasuryLike  public treasury;\r\n\r\n    // --- Events ---\r\n    event ModifyParameters(\r\n      bytes32 parameter,\r\n      address addr\r\n    );\r\n    event ModifyParameters(\r\n      bytes32 parameter,\r\n      uint256 val\r\n    );\r\n    event FailRewardCaller(bytes revertReason, address feeReceiver, uint256 amount);\r\n\r\n    constructor() public {\r\n        maxRewardIncreaseDelay = uint(-1);\r\n    }\r\n\r\n    // --- Boolean Logic ---\r\n    function either(bool x, bool y) internal pure returns (bool z) {\r\n        assembly{ z := or(x, y)}\r\n    }\r\n    function both(bool x, bool y) internal pure returns (bool z) {\r\n        assembly{ z := and(x, y)}\r\n    }\r\n\r\n    // --- Treasury ---\r\n    /**\r\n    * @notice This returns the stability fee treasury allowance for this contract by taking the minimum between the per block and the total allowances\r\n    **/\r\n    function treasuryAllowance() public view returns (uint256) {\r\n        (uint total, uint perBlock) = treasury.getAllowance(address(this));\r\n        return minimum(total, perBlock);\r\n    }\r\n    /*\r\n    * @notice Get the SF reward that can be sent to a function caller right now\r\n    * @param timeOfLastUpdate The last time when the function that the treasury pays for has been updated\r\n    * @param defaultDelayBetweenCalls Enforced delay between calls to the function for which the treasury reimburses callers\r\n    */\r\n    function getCallerReward(uint256 timeOfLastUpdate, uint256 defaultDelayBetweenCalls) public view returns (uint256) {\r\n        // If the rewards are null or if the time of the last update is in the future or present, return 0\r\n        bool nullRewards = (baseUpdateCallerReward == 0 && maxUpdateCallerReward == 0);\r\n        if (either(timeOfLastUpdate >= now, nullRewards)) return 0;\r\n\r\n        // If the time elapsed is smaller than defaultDelayBetweenCalls or if the base reward is zero, return 0\r\n        uint256 timeElapsed = (timeOfLastUpdate == 0) ? defaultDelayBetweenCalls : subtract(now, timeOfLastUpdate);\r\n        if (either(timeElapsed < defaultDelayBetweenCalls, baseUpdateCallerReward == 0)) {\r\n            return 0;\r\n        }\r\n\r\n        // If too much time elapsed, return the max reward\r\n        uint256 adjustedTime      = subtract(timeElapsed, defaultDelayBetweenCalls);\r\n        uint256 maxPossibleReward = minimum(maxUpdateCallerReward, treasuryAllowance() / RAY);\r\n        if (adjustedTime > maxRewardIncreaseDelay) {\r\n            return maxPossibleReward;\r\n        }\r\n\r\n        // Calculate the reward\r\n        uint256 calculatedReward = baseUpdateCallerReward;\r\n        if (adjustedTime > 0) {\r\n            calculatedReward = rmultiply(rpower(perSecondCallerRewardIncrease, adjustedTime, RAY), calculatedReward);\r\n        }\r\n\r\n        // If the reward is higher than max, set it to max\r\n        if (calculatedReward > maxPossibleReward) {\r\n            calculatedReward = maxPossibleReward;\r\n        }\r\n        return calculatedReward;\r\n    }\r\n    /**\r\n    * @notice Send a stability fee reward to an address\r\n    * @param proposedFeeReceiver The SF receiver\r\n    * @param reward The system coin amount to send\r\n    **/\r\n    function rewardCaller(address proposedFeeReceiver, uint256 reward) internal {\r\n        // If the receiver is the treasury itself or if the treasury is null or if the reward is zero, return\r\n        if (address(treasury) == proposedFeeReceiver) return;\r\n        if (either(address(treasury) == address(0), reward == 0)) return;\r\n\r\n        // Determine the actual receiver and send funds\r\n        address finalFeeReceiver = (proposedFeeReceiver == address(0)) ? msg.sender : proposedFeeReceiver;\r\n        try treasury.pullFunds(finalFeeReceiver, treasury.systemCoin(), reward) {}\r\n        catch(bytes memory revertReason) {\r\n            emit FailRewardCaller(revertReason, finalFeeReceiver, reward);\r\n        }\r\n    }\r\n}\r\n"
    },
    "lib/geb-fsm/lib/geb-treasury-reimbursement/src/math/GebMath.sol": {
      "content": "pragma solidity 0.6.7;\r\n\r\ncontract GebMath {\r\n    uint256 public constant RAY = 10 ** 27;\r\n    uint256 public constant WAD = 10 ** 18;\r\n\r\n    function ray(uint x) public pure returns (uint z) {\r\n        z = multiply(x, 10 ** 9);\r\n    }\r\n    function rad(uint x) public pure returns (uint z) {\r\n        z = multiply(x, 10 ** 27);\r\n    }\r\n    function minimum(uint x, uint y) public pure returns (uint z) {\r\n        z = (x <= y) ? x : y;\r\n    }\r\n    function addition(uint x, uint y) public pure returns (uint z) {\r\n        z = x + y;\r\n        require(z >= x, \"uint-uint-add-overflow\");\r\n    }\r\n    function subtract(uint x, uint y) public pure returns (uint z) {\r\n        z = x - y;\r\n        require(z <= x, \"uint-uint-sub-underflow\");\r\n    }\r\n    function multiply(uint x, uint y) public pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"uint-uint-mul-overflow\");\r\n    }\r\n    function rmultiply(uint x, uint y) public pure returns (uint z) {\r\n        z = multiply(x, y) / RAY;\r\n    }\r\n    function rdivide(uint x, uint y) public pure returns (uint z) {\r\n        z = multiply(x, RAY) / y;\r\n    }\r\n    function wdivide(uint x, uint y) public pure returns (uint z) {\r\n        z = multiply(x, WAD) / y;\r\n    }\r\n    function wmultiply(uint x, uint y) public pure returns (uint z) {\r\n        z = multiply(x, y) / WAD;\r\n    }\r\n    function rpower(uint x, uint n, uint base) public pure returns (uint z) {\r\n        assembly {\r\n            switch x case 0 {switch n case 0 {z := base} default {z := 0}}\r\n            default {\r\n                switch mod(n, 2) case 0 { z := base } default { z := x }\r\n                let half := div(base, 2)  // for rounding.\r\n                for { n := div(n, 2) } n { n := div(n,2) } {\r\n                    let xx := mul(x, x)\r\n                    if iszero(eq(div(xx, x), x)) { revert(0,0) }\r\n                    let xxRound := add(xx, half)\r\n                    if lt(xxRound, xx) { revert(0,0) }\r\n                    x := div(xxRound, base)\r\n                    if mod(n,2) {\r\n                        let zx := mul(z, x)\r\n                        if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\r\n                        let zxRound := add(zx, half)\r\n                        if lt(zxRound, zx) { revert(0,0) }\r\n                        z := div(zxRound, base)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "remappings": [
      "ds-auth/=lib/geb-fsm/lib/ds-stop/lib/ds-auth/src/",
      "ds-math/=lib/geb-fsm/lib/ds-token/lib/ds-math/src/",
      "ds-note/=lib/geb-fsm/lib/ds-stop/lib/ds-note/src/",
      "ds-stop/=lib/geb-fsm/lib/ds-stop/src/",
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "ds-thing/=lib/geb-fsm/lib/ds-value/lib/ds-thing/src/",
      "ds-token/=lib/geb-fsm/lib/ds-token/src/",
      "ds-value/=lib/geb-fsm/lib/ds-value/src/",
      "erc20/=lib/geb-fsm/lib/ds-token/lib/erc20/src/",
      "forge-std/=lib/forge-std/src/",
      "geb-fsm/=lib/geb-fsm/src/",
      "geb-treasury-reimbursement/=lib/geb-fsm/lib/geb-treasury-reimbursement/src/",
      "geb/=lib/geb/src/",
      "mgl-keeper-incentives/=lib/mgl-keeper-incentives/src/",
      "solmate/=lib/mgl-keeper-incentives/lib/solmate/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 20
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs"
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "evmVersion": "istanbul",
    "libraries": {}
  }
}}