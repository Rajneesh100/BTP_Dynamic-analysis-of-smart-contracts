{"IDelegationManagementContract.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\n/**\n * @dev Interface module which provides a basic access control mechanism of the NFT Delegation Smart Contract\n */\n\ninterface IDelegationManagementContract {\n    \n    /**\n     * @notice Returns an array of all delegation addresses (active AND inactive) assigned by a delegator for a specific use case on a specific NFT collection\n     */\n\n    function retrieveDelegationAddresses(address _delegatorAddress, address _collectionAddress, uint256 _useCase) external view returns (address[] memory);\n    \n    /**\n     * @notice Returns an array of all delegators (active AND inactive) that delegated to a delegationAddress for a specific use case on a specific NFT collection\n     */\n\n     function retrieveDelegators(address _delegationAddress, address _collectionAddress, uint256 _useCase) external view returns (address[] memory);\n\n    /**\n     * @notice Returns an array of all active delegators on a certain date for a specific use case on a specific NFT collection given a delegation Address\n    */\n\n     function retrieveActiveDelegators(address _delegationAddress, address _collectionAddress, uint256 _date, uint256 _useCase) external view returns (address[] memory);\n\n     /**\n     * @notice Returns the most recent delegation address delegated for a specific use case on a specific NFT collection\n     */\n\n    function retrieveMostRecentDelegation(address _delegatorAddress, address _collectionAddress, uint256 _useCase) external view returns (address);\n\n    /**\n     * @notice Returns the most recent delegator for a specific use case on a specific NFT collection given a delegation Address\n     */\n\n    function retrieveMostRecentDelegator(address _delegationAddress, address _collectionAddress, uint256 _useCase) external view returns (address);\n\n    /**\n     * @notice Returns the status of a delegation given the delegator address as well as the delegation address\n     */\n\n    function retrieveGlobalStatusOfDelegation(address _delegatorAddress, address _collectionAddress, address _delegationAddress, uint256 _useCase) external view returns (bool);\n\n    /**\n     * @notice Returns the status of a delegation given the delegator address, the collection address, the delegation address as well as a specific token id\n     */\n\n    function retrieveTokenStatus(address _delegatorAddress, address _collectionAddress, address _delegationAddress, uint256 _useCase, uint256 _tokenId) external view returns (bool);\n\n    /**\n     * @notice Checks if the delegation address performing actions is the most recent delegated by the specific delegator\n     */\n\n    function retrieveStatusOfMostRecentDelegation(address _delegatorAddress, address _collectionAddress, address _delegationAddress, uint256 _useCase) external view returns (bool);\n\n     /**\n     * @notice Checks if a delegator granted subdelegation status to an Address\n     */\n\n    function retrieveSubDelegationStatus(address _delegatorAddress, address _collectionAddress, address _delegationAddress) external view returns (bool);\n\n     /**\n     * @notice Checks the status of an active delegator for a delegation Address\n     */\n\n    function retrieveStatusOfActiveDelegator(address _delegatorAddress, address _collectionAddress, address _delegationAddress, uint256 _date, uint256 _useCase) external view returns (bool);\n\n    /**\n     * @notice This function checks the Consolidation status between 2 addresses\n     */\n\n    function checkConsolidationStatus(address _wallet1, address _wallet2, address _collectionAddress) external view returns (bool);\n\n}"},"IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}"},"IERC721.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\n\nimport \"./IERC165.sol\";\n\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``\u0027s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}"},"INextGenAdmins.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.19;\n\ninterface INextGenAdmins {\n\n    // retrieve global admin\n    function retrieveGlobalAdmin(address _address) external view returns(bool);\n\n    // retrieve function admin\n    function retrieveFunctionAdmin(address _address, bytes4 _selector) external view returns(bool);\n\n    // retrieve collection admin\n    function retrieveCollectionAdmin(address _address, uint256 _collectionID) external view returns(bool);\n\n    // retrieve if the contract is admin contract\n    function isAdminContract() external view returns (bool);\n\n    // retrieve owner\n    function owner() external view returns (address);\n\n}"},"INextGenCore.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.19;\n\ninterface INextGenCore {\n\n    function retrievewereDataAdded(uint256 _collectionID) external view returns(bool);\n\n    function viewTokensIndexMin(uint256 _collectionID) external view returns (uint256);\n\n    function viewTokensIndexMax(uint256 _collectionID) external view returns (uint256);\n\n    function viewCirSupply(uint256 _collectionID) external view returns (uint256);\n\n    function airDropTokens(uint256 mintIndex, address _recipient, string memory _tokenData, uint256 _saltfun_o, uint256 _collectionID) external;\n\n    function mint(uint256 mintIndex, address _mintingAddress , address _mintTo, string memory _tokenData, uint256 _saltfun_o, uint256 _collectionID, uint256 phase) external;\n\n    function collectionFreezeStatus(uint256 _collectionID) external view returns(bool);\n\n    function viewMaxAllowance(uint256 _collectionID) external view returns (uint256);\n\n    function retrieveTokensMintedALPerAddress(uint256 _collectionID, address _address) external view returns(uint256);\n\n    function retrieveTokensMintedPublicPerAddress(uint256 _collectionID, address _address) external view returns(uint256);\n\n    function viewColIDforTokenID(uint256 _tokenid) external view returns (uint256);\n\n    function burnToMint(uint256 mintIndex, uint256 _burnCollectionID, uint256 _tokenId, uint256 _mintCollectionID, uint256 _saltfun_o, address burner) external;\n\n    function retrieveArtistAddress(uint256 _collectionID) external view returns(address);\n\n    function setTokenHash(uint256 _collectionID, uint256 _mintIndex, bytes32 _hash) external;\n\n    function retrieveTokenHash(uint256 _tokenid) external view returns(bytes32);\n\n}"},"MerkleProof.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.18;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin\u0027s JavaScript library generates merkle trees that are safe\n * against this attack out of the box.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     *\n     * _Available since v4.7._\n     */\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs \u0026 pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i \u003c proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     *\n     * _Available since v4.7._\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i \u003c proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\u0027s \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i \u003c totalHashes; i++) {\n            bytes32 a = leafPos \u003c leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos \u003c leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes \u003e 0) {\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen \u003e 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\u0027s \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i \u003c totalHashes; i++) {\n            bytes32 a = leafPos \u003c leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos \u003c leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes \u003e 0) {\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen \u003e 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a \u003c b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}"},"MinterContract.sol":{"content":"// SPDX-License-Identifier: MIT\n\n/**\n *\n *  @title: NextGen 6529 - Minter Contract\n *  @date: 20-December-2023\n *  @version: 1.10\n *  @author: 6529 team\n */\n\npragma solidity ^0.8.19;\n\nimport \"./INextGenCore.sol\";\nimport \"./IDelegationManagementContract.sol\";\nimport \"./MerkleProof.sol\";\nimport \"./INextGenAdmins.sol\";\nimport \"./IERC721.sol\";\n\ncontract NextGenMinterContract {\n\n    // total funds collected during minting per collection\n    mapping (uint256 =\u003e uint256) public collectionTotalAmount;\n\n    // timestamp of last mint for used in sales model 3\n    mapping (uint256 =\u003e uint) public lastMintDate;\n\n    // tokens airdropped per collection\n    mapping (uint256 =\u003e uint256) public excludeTokensCounter;\n\n    // burn or swap address during burnOrSwap functionality\n    mapping (bytes32 =\u003e address) public burnOrSwapAddress;\n\n    // token ids set during burnOrSwap functionality\n    mapping (bytes32 =\u003e uint256[2]) private burnOrSwapIds;\n\n    // burnToMint initialization --\u003e burn a token on a NextGen collection and mint a token on a new NextGen collection\n    mapping (uint256 =\u003e mapping (uint256 =\u003e bool)) public burnToMintCollections;\n\n    // burnOrSwap initialization --\u003e burn a token on an external ERC721 collection and mint a token on a NextGen collection\n    mapping (bytes32 =\u003e mapping (uint256 =\u003e bool)) public burnExternalToMintCollections;\n\n    // checks if minting costs for a collectionwere set\n    mapping (uint256 =\u003e bool) private setMintingCosts;\n\n    // struct that holds minting costs and phases\n    struct collectionPhasesDataStructure {\n        uint allowlistStartTime;\n        uint allowlistEndTime;\n        uint publicStartTime;\n        uint publicEndTime;\n        bytes32 merkleRoot;\n        uint256 collectionMintCost;\n        uint256 collectionEndMintCost;\n        uint256 timePeriod;\n        uint256 rate;\n        uint8 salesOption;\n        address delAddress;\n    }\n\n    // mapping of collectionPhasesData struct\n    mapping (uint256 =\u003e collectionPhasesDataStructure) private collectionPhases;\n\n    // struct that holds primary royalties\n    struct royaltiesPrimarySplits {\n        uint256 artistPercentage;\n        uint256 teamPercentage;\n    }\n\n    // mapping of royaltiesPrimarySplits struct\n    mapping (uint256 =\u003e royaltiesPrimarySplits) private collectionRoyaltiesPrimarySplits;\n\n    // struct that holds addresses and percentages for primary splits\n    struct collectionPrimaryAddresses {\n        address primaryAdd1;\n        address primaryAdd2;\n        address primaryAdd3;\n        uint256 add1Percentage;\n        uint256 add2Percentage;\n        uint256 add3Percentage;\n        bool setStatus;\n        bool approvedStatus;\n    }\n\n    // mapping of collectionPrimaryAndSecondaryAddresses struct\n    mapping (uint256 =\u003e collectionPrimaryAddresses) private collectionArtistPrimaryAddresses;\n\n    // struct that holds secondary royalties\n    struct royaltiesSecondarySplits {\n        uint256 artistPercentage;\n        uint256 teamPercentage;\n    }\n\n    // mapping of royaltiesSecondarySplits struct\n\n    mapping (uint256 =\u003e royaltiesSecondarySplits) private collectionRoyaltiesSecondarySplits;\n\n    // struct that holds addresses and percentages for secondary splits\n    struct collectionSecondaryAddresses {\n        address secondaryAdd1;\n        address secondaryAdd2;\n        address secondaryAdd3;\n        uint256 add1Percentage;\n        uint256 add2Percentage;\n        uint256 add3Percentage;\n        bool setStatus;\n        bool approvedStatus;\n    }\n\n    // mapping of collectionSecondaryAddresses struct\n    mapping (uint256 =\u003e collectionSecondaryAddresses) private collectionArtistSecondaryAddresses;\n\n    // mapping that holds the auction end time when a token is sent to auction\n    mapping (uint256 =\u003e uint) private mintToAuctionData;\n\n    // mapping that holds the auction status when a token is sent to auction\n    mapping (uint256 =\u003e bool) private mintToAuctionStatus;\n\n    //external contracts declaration\n    INextGenCore public gencore;\n    IDelegationManagementContract public dmc;\n    INextGenAdmins private adminsContract;\n\n    // events\n    event Withdraw(address indexed _add, bool status, uint256 indexed funds);\n\n    // constructor\n    constructor (address _gencore, address _del, address _adminsContract) {\n        gencore = INextGenCore(_gencore);\n        dmc = IDelegationManagementContract(_del);\n        adminsContract = INextGenAdmins(_adminsContract);\n    }\n\n    // certain functions can only be called by an admin or the artist\n\n    modifier ArtistOrAdminRequired(uint256 _collectionID, bytes4 _selector) {\n      require(msg.sender == gencore.retrieveArtistAddress(_collectionID) || adminsContract.retrieveFunctionAdmin(msg.sender, _selector) == true || adminsContract.retrieveGlobalAdmin(msg.sender) == true, \"Not allowed\");\n      _;\n    }\n\n    // certain functions can only be called by a global or function admin\n\n    modifier FunctionAdminRequired(bytes4 _selector) {\n      require(adminsContract.retrieveFunctionAdmin(msg.sender, _selector) == true || adminsContract.retrieveGlobalAdmin(msg.sender) == true , \"Not allowed\");\n      _;\n    }\n\n    // certain functions can only be called by a collection, global or function admin\n\n    modifier CollectionAdminRequired(uint256 _collectionID, bytes4 _selector) {\n      require(adminsContract.retrieveCollectionAdmin(msg.sender,_collectionID) == true || adminsContract.retrieveFunctionAdmin(msg.sender, _selector) == true || adminsContract.retrieveGlobalAdmin(msg.sender) == true, \"Not allowed\");\n      _;\n    }\n\n    // function to add a collection\u0027s minting costs\n\n    function setCollectionCosts(uint256 _collectionID, uint256 _collectionMintCost, uint256 _collectionEndMintCost, uint256 _rate, uint256 _timePeriod, uint8 _salesOption, address _delAddress) public CollectionAdminRequired(_collectionID, this.setCollectionCosts.selector) {\n        require(gencore.retrievewereDataAdded(_collectionID) == true, \"Add data\");\n        collectionPhases[_collectionID].collectionMintCost = _collectionMintCost;\n        collectionPhases[_collectionID].collectionEndMintCost = _collectionEndMintCost;\n        collectionPhases[_collectionID].rate = _rate;\n        collectionPhases[_collectionID].timePeriod = _timePeriod;\n        collectionPhases[_collectionID].salesOption = _salesOption;\n        collectionPhases[_collectionID].delAddress = _delAddress;\n        setMintingCosts[_collectionID] = true;\n    }\n\n    // function to add a collection\u0027s minting phases and merkleroot\n\n    function setCollectionPhases(uint256 _collectionID, uint _allowlistStartTime, uint _allowlistEndTime, uint _publicStartTime, uint _publicEndTime, bytes32 _merkleRoot) public CollectionAdminRequired(_collectionID, this.setCollectionPhases.selector) {\n        require(setMintingCosts[_collectionID] == true, \"Set Costs\");\n        collectionPhases[_collectionID].allowlistStartTime = _allowlistStartTime;\n        collectionPhases[_collectionID].allowlistEndTime = _allowlistEndTime;\n        collectionPhases[_collectionID].merkleRoot = _merkleRoot;\n        collectionPhases[_collectionID].publicStartTime = _publicStartTime;\n        collectionPhases[_collectionID].publicEndTime = _publicEndTime;\n    }\n\n    // airdrop function\n    \n    function airDropTokens(address[] memory _recipients, string[] memory _tokenData, uint256[] memory _saltfun_o, uint256 _collectionID, uint256[] memory _numberOfTokens) public FunctionAdminRequired(this.airDropTokens.selector) {\n        require(gencore.retrievewereDataAdded(_collectionID) == true, \"Add data\");\n        uint256 collectionTokenMintIndex;\n        for (uint256 y=0; y\u003c _recipients.length; y++) {\n            collectionTokenMintIndex = gencore.viewTokensIndexMin(_collectionID) + gencore.viewCirSupply(_collectionID) + _numberOfTokens[y] - 1;\n            require(collectionTokenMintIndex \u003c= gencore.viewTokensIndexMax(_collectionID), \"No supply\");\n            for(uint256 i = 0; i \u003c _numberOfTokens[y]; i++) {\n                uint256 mintIndex = gencore.viewTokensIndexMin(_collectionID) + gencore.viewCirSupply(_collectionID);\n                gencore.airDropTokens(mintIndex, _recipients[y], _tokenData[y], _saltfun_o[y], _collectionID);\n            }\n        }\n    }\n\n    // mint function for allowlist or public minting\n\n    function mint(uint256 _collectionID, uint256 _numberOfTokens, uint256 _maxAllowance, string memory _tokenData, address _mintTo, bytes32[] calldata merkleProof, address _delegator, uint256 _saltfun_o) public payable {\n        require(setMintingCosts[_collectionID] == true \u0026\u0026 _numberOfTokens \u003e 0, \"err\");\n        uint256 col = _collectionID;\n        address mintingAddress;\n        uint256 phase;\n        string memory tokData = _tokenData;\n        if (block.timestamp \u003e= collectionPhases[col].allowlistStartTime \u0026\u0026 block.timestamp \u003c collectionPhases[col].allowlistEndTime) {\n            phase = 1;\n            bytes32 node;\n            if (_delegator != 0x0000000000000000000000000000000000000000) {\n                bool isAllowedToMint;\n                isAllowedToMint = dmc.retrieveGlobalStatusOfDelegation(_delegator, 0x8888888888888888888888888888888888888888, msg.sender, 1) || dmc.retrieveGlobalStatusOfDelegation(_delegator, 0x8888888888888888888888888888888888888888, msg.sender, 2);\n                if (isAllowedToMint == false) {\n                isAllowedToMint = dmc.retrieveGlobalStatusOfDelegation(_delegator, collectionPhases[col].delAddress, msg.sender, 1) || dmc.retrieveGlobalStatusOfDelegation(_delegator, collectionPhases[col].delAddress, msg.sender, 2);    \n                }\n                require(isAllowedToMint == true, \"No delegation\");\n                node = keccak256(bytes.concat(keccak256((abi.encodePacked(_delegator, _maxAllowance, tokData)))));\n                require(_maxAllowance \u003e= gencore.retrieveTokensMintedALPerAddress(col, _delegator) + _numberOfTokens, \"AL limit\");\n                mintingAddress = _delegator;\n            } else {\n                node = keccak256(bytes.concat(keccak256((abi.encodePacked(msg.sender, _maxAllowance, tokData)))));\n                require(_maxAllowance \u003e= gencore.retrieveTokensMintedALPerAddress(col, msg.sender) + _numberOfTokens, \"AL limit\");\n                mintingAddress = msg.sender;\n            }\n            require(MerkleProof.verifyCalldata(merkleProof, collectionPhases[col].merkleRoot, node), \u0027invalid proof\u0027);\n        } else if (block.timestamp \u003e= collectionPhases[col].publicStartTime \u0026\u0026 block.timestamp \u003c= collectionPhases[col].publicEndTime) {\n            phase = 2;\n            require(_numberOfTokens \u003c= gencore.viewMaxAllowance(col), \"Change no of tokens\");\n            require(gencore.retrieveTokensMintedPublicPerAddress(col, msg.sender) + _numberOfTokens \u003c= gencore.viewMaxAllowance(col), \"Max\");\n            mintingAddress = msg.sender;\n            tokData = \u0027\"public\"\u0027;\n        } else {\n            revert(\"No minting\");\n        }\n        uint256 collectionTokenMintIndex;\n        collectionTokenMintIndex = gencore.viewTokensIndexMin(col) + gencore.viewCirSupply(col) + _numberOfTokens - 1;\n        require(collectionTokenMintIndex \u003c= gencore.viewTokensIndexMax(col), \"No supply\");\n        require(msg.value \u003e= (getPrice(col) * _numberOfTokens), \"Wrong ETH\");\n        // refund excess\n        {\n            uint256 excess = calculateExcess(msg.value, getPrice(col) * _numberOfTokens);\n            collectionTotalAmount[col] = collectionTotalAmount[col] + msg.value - excess;\n        }\n        // check mechanism for sale option 3\n        if (collectionPhases[col].salesOption == 3) {\n            uint timeOfLastMint;\n            if (lastMintDate[col] == 0) {\n                // for only public minting set the allowliststarttime as publicstarttime\n                timeOfLastMint = collectionPhases[col].allowlistStartTime - collectionPhases[col].timePeriod;\n            } else {\n                timeOfLastMint =  lastMintDate[col];\n            }\n            // calculate periods and check if a period has passed in order to allow minting\n            uint tDiff = (block.timestamp - timeOfLastMint) / collectionPhases[col].timePeriod;\n            // users are able to mint after a period passes\n            // unminted tokens from previous periods are transferred for minting into new periods\n            // 1 mint at a time period\n            require(tDiff\u003e=1 \u0026\u0026 _numberOfTokens == 1, \"1 mint/period\");\n            // exclude tokens ex. airdrop tokens so they do not affect lastMintDate\n            lastMintDate[col] = collectionPhases[col].allowlistStartTime + (collectionPhases[col].timePeriod * (gencore.viewCirSupply(col) - excludeTokensCounter[col]));\n        }\n        // mint tokens\n        for(uint256 i = 0; i \u003c _numberOfTokens; i++) {\n            uint256 mintIndex = gencore.viewTokensIndexMin(col) + gencore.viewCirSupply(col);\n            gencore.mint(mintIndex, mintingAddress, _mintTo, tokData, _saltfun_o, col, phase);\n        }\n    }\n\n    // burn to mint function (does not require contract approval)\n\n    function burnToMint(uint256 _burnCollectionID, uint256 _tokenId, uint256 _mintCollectionID, uint256 _saltfun_o) public payable {\n        require(setMintingCosts[_mintCollectionID] == true \u0026\u0026 burnToMintCollections[_burnCollectionID][_mintCollectionID] == true, \"init err\");\n        require(block.timestamp \u003e= collectionPhases[_mintCollectionID].publicStartTime \u0026\u0026 block.timestamp \u003c= collectionPhases[_mintCollectionID].publicEndTime,\"No minting\");\n        require ((_tokenId \u003e= gencore.viewTokensIndexMin(_burnCollectionID)) \u0026\u0026 (_tokenId \u003c= gencore.viewTokensIndexMax(_burnCollectionID)), \"col/token id error\");\n        uint256 collectionTokenMintIndex;\n        collectionTokenMintIndex = gencore.viewTokensIndexMin(_mintCollectionID) + gencore.viewCirSupply(_mintCollectionID);\n        require(collectionTokenMintIndex \u003c= gencore.viewTokensIndexMax(_mintCollectionID), \"No supply\");\n        require(msg.value \u003e= getPrice(_mintCollectionID), \"Wrong ETH\");\n        // refund excess\n        {\n            uint256 excess = calculateExcess(msg.value, getPrice(_mintCollectionID));\n            collectionTotalAmount[_mintCollectionID] = collectionTotalAmount[_mintCollectionID] + msg.value - excess;\n        }\n        uint256 mintIndex = gencore.viewTokensIndexMin(_mintCollectionID) + gencore.viewCirSupply(_mintCollectionID);\n        // burn and mint token\n        address burner = msg.sender;\n        gencore.burnToMint(mintIndex, _burnCollectionID, _tokenId, _mintCollectionID, _saltfun_o, burner);\n    }\n\n    // mint and auction\n    \n    function mintAndAuction(address _recipient, string memory _tokenData, uint256 _saltfun_o, uint256 _collectionID, uint _auctionEndTime) public FunctionAdminRequired(this.mintAndAuction.selector) {\n        require(gencore.retrievewereDataAdded(_collectionID) == true, \"Add data\");\n        uint256 collectionTokenMintIndex;\n        collectionTokenMintIndex = gencore.viewTokensIndexMin(_collectionID) + gencore.viewCirSupply(_collectionID);\n        require(collectionTokenMintIndex \u003c= gencore.viewTokensIndexMax(_collectionID), \"No supply\");\n        uint256 mintIndex = gencore.viewTokensIndexMin(_collectionID) + gencore.viewCirSupply(_collectionID);\n        uint timeOfLastMint;\n        // 1 token per period can be minted and send to auction\n        // time period can be set for any sales model\n        if (lastMintDate[_collectionID] == 0) {\n        // for public sale set the allowliststarttime the same time as publicstarttime\n            timeOfLastMint = collectionPhases[_collectionID].allowlistStartTime - collectionPhases[_collectionID].timePeriod;\n        } else {\n            timeOfLastMint =  lastMintDate[_collectionID];\n        }\n        // calculate periods and check if a period has passed in order to allow minting\n        uint tDiff = (block.timestamp - timeOfLastMint) / collectionPhases[_collectionID].timePeriod;\n        // admins are able to mint after a period passes\n        require(tDiff\u003e=1, \"1 mint/period\");\n        lastMintDate[_collectionID] = collectionPhases[_collectionID].allowlistStartTime + (collectionPhases[_collectionID].timePeriod * ((gencore.viewCirSupply(_collectionID) - excludeTokensCounter[_collectionID])));\n        require(_auctionEndTime \u003e= block.timestamp + 600); // 10mins min auction\n        mintToAuctionData[mintIndex] = _auctionEndTime;\n        mintToAuctionStatus[mintIndex] = true;\n        // token is airdropped to the _recipient address\n        gencore.airDropTokens(mintIndex, _recipient, _tokenData, _saltfun_o, _collectionID);\n    }\n\n    // function to exclude a specific no of tokens during sales model 3 or reset lastMintDate\n\n    function excludeTokensOrResetLD(uint256 _option, uint256 _collectionID, uint256 _excludeCounter) public FunctionAdminRequired(this.excludeTokensOrResetLD.selector) { \n        if (_option == 1) {\n            excludeTokensCounter[_collectionID] = _excludeCounter;\n        } else {\n            lastMintDate[_collectionID] = 0;\n        }  \n    }\n\n    // function to refund any excess amount\n\n    function calculateExcess(uint256 _value, uint256 _price) internal returns(uint256) {\n        uint256 excess;\n        excess = _value - _price;\n        (bool success1, ) = payable(msg.sender).call{value: excess}(\"\");\n        require(success1, \"ETH failed\");\n        return(excess);\n    }\n\n    // function to initialize burn to mint for NextGen collections\n\n    function initializeBurn(uint256 _burnCollectionID, uint256 _mintCollectionID, bool _status) public FunctionAdminRequired(this.initializeBurn.selector) { \n        require((gencore.retrievewereDataAdded(_burnCollectionID) == true) \u0026\u0026 (gencore.retrievewereDataAdded(_mintCollectionID) == true), \"No data\");\n        burnToMintCollections[_burnCollectionID][_mintCollectionID] = _status;\n    }\n\n    // function to initialize external burn or swap to mint\n\n    function initializeExternalBurnOrSwap(address _erc721Collection, uint256 _burnCollectionID, uint256 _mintCollectionID, uint256 _tokmin, uint256 _tokmax, address _burnOrSwapAddress, bool _status) public FunctionAdminRequired(this.initializeExternalBurnOrSwap.selector) { \n        bytes32 externalCol = keccak256(abi.encodePacked(_erc721Collection,_burnCollectionID));\n        require((gencore.retrievewereDataAdded(_mintCollectionID) == true), \"No data\");\n        burnExternalToMintCollections[externalCol][_mintCollectionID] = _status;\n        burnOrSwapAddress[externalCol] = _burnOrSwapAddress;\n        burnOrSwapIds[externalCol][0] = _tokmin;\n        burnOrSwapIds[externalCol][1] = _tokmax;\n    }\n\n    // burn or swap to mint (requires contract approval)\n\n    function burnOrSwapExternalToMint(address _erc721Collection, uint256 _burnCollectionID, uint256 _tokenId, uint256 _mintCollectionID, string memory _tokenData, bytes32[] calldata merkleProof, uint256 _saltfun_o) public payable {\n        bytes32 externalCol = keccak256(abi.encodePacked(_erc721Collection,_burnCollectionID));\n        require(setMintingCosts[_mintCollectionID] == true \u0026\u0026 burnExternalToMintCollections[externalCol][_mintCollectionID] == true, \"init err\");\n        address ownerOfToken = IERC721(_erc721Collection).ownerOf(_tokenId);\n        if (msg.sender != ownerOfToken) {\n            bool isAllowedToMint;\n            isAllowedToMint = dmc.retrieveGlobalStatusOfDelegation(ownerOfToken, 0x8888888888888888888888888888888888888888, msg.sender, 1) || dmc.retrieveGlobalStatusOfDelegation(ownerOfToken, 0x8888888888888888888888888888888888888888, msg.sender, 2);\n            if (isAllowedToMint == false) {\n            isAllowedToMint = dmc.retrieveGlobalStatusOfDelegation(ownerOfToken, _erc721Collection, msg.sender, 1) || dmc.retrieveGlobalStatusOfDelegation(ownerOfToken, _erc721Collection, msg.sender, 2);    \n            }\n            require(isAllowedToMint == true, \"No delegation\");\n        }\n        require(_tokenId \u003e= burnOrSwapIds[externalCol][0] \u0026\u0026 _tokenId \u003c= burnOrSwapIds[externalCol][1], \"Token id does not match\");\n        IERC721(_erc721Collection).safeTransferFrom(ownerOfToken, burnOrSwapAddress[externalCol], _tokenId);\n        uint256 col = _mintCollectionID;\n        address mintingAddress;\n        uint256 phase;\n        string memory tokData = _tokenData;\n        if (block.timestamp \u003e= collectionPhases[col].allowlistStartTime \u0026\u0026 block.timestamp \u003c collectionPhases[col].allowlistEndTime) {\n            phase = 1;\n            bytes32 node;\n            node = keccak256(bytes.concat(keccak256((abi.encodePacked(_tokenId, tokData)))));\n            mintingAddress = ownerOfToken;\n            require(MerkleProof.verifyCalldata(merkleProof, collectionPhases[col].merkleRoot, node), \u0027invalid proof\u0027);            \n        } else if (block.timestamp \u003e= collectionPhases[col].publicStartTime \u0026\u0026 block.timestamp \u003c= collectionPhases[col].publicEndTime) {\n            phase = 2;\n            mintingAddress = ownerOfToken;\n            tokData = \u0027\"public\"\u0027;\n        } else {\n            revert(\"No minting\");\n        }\n        uint256 collectionTokenMintIndex;\n        collectionTokenMintIndex = gencore.viewTokensIndexMin(col) + gencore.viewCirSupply(col);\n        require(collectionTokenMintIndex \u003c= gencore.viewTokensIndexMax(col), \"No supply\");\n        require(msg.value \u003e= getPrice(col), \"Wrong ETH\");\n        // refund excess\n        {\n            uint256 excess = calculateExcess(msg.value, getPrice(col));\n            collectionTotalAmount[col] = collectionTotalAmount[col] + msg.value - excess;\n        }\n        uint256 mintIndex = gencore.viewTokensIndexMin(col) + gencore.viewCirSupply(col);\n        gencore.mint(mintIndex, mintingAddress, ownerOfToken, tokData, _saltfun_o, col, phase);\n    }\n\n    // function to set primary splits\n\n    function setPrimaryAndSecondarySplits(uint256 _collectionID, uint256 _artistPrSplit, uint256 _teamPrSplit, uint256 _artistSecSplit, uint256 _teamSecSplit) public FunctionAdminRequired(this.setPrimaryAndSecondarySplits.selector) {\n        require(_artistPrSplit + _teamPrSplit == 100, \"splits need to be 100%\");\n        require(_artistSecSplit + _teamSecSplit == 100, \"splits need to be 100%\");\n        collectionRoyaltiesPrimarySplits[_collectionID].artistPercentage = _artistPrSplit;\n        collectionRoyaltiesPrimarySplits[_collectionID].teamPercentage = _teamPrSplit;\n        collectionRoyaltiesSecondarySplits[_collectionID].artistPercentage = _artistSecSplit;\n        collectionRoyaltiesSecondarySplits[_collectionID].teamPercentage = _teamSecSplit;\n    }\n\n    // function to propose primary addresses and percentages for each address\n\n    function proposePrimaryAddressesAndPercentages(uint256 _collectionID, address _primaryAdd1, address _primaryAdd2, address _primaryAdd3, uint256 _add1Percentage, uint256 _add2Percentage, uint256 _add3Percentage) public ArtistOrAdminRequired(_collectionID, this.proposePrimaryAddressesAndPercentages.selector) {\n        require (collectionArtistPrimaryAddresses[_collectionID].approvedStatus == false, \"Already approved\");\n        require (_add1Percentage + _add2Percentage + _add3Percentage == collectionRoyaltiesPrimarySplits[_collectionID].artistPercentage, \"Check %\");\n        collectionArtistPrimaryAddresses[_collectionID].primaryAdd1 = _primaryAdd1;\n        collectionArtistPrimaryAddresses[_collectionID].primaryAdd2 = _primaryAdd2;\n        collectionArtistPrimaryAddresses[_collectionID].primaryAdd3 = _primaryAdd3;\n        collectionArtistPrimaryAddresses[_collectionID].add1Percentage = _add1Percentage;\n        collectionArtistPrimaryAddresses[_collectionID].add2Percentage = _add2Percentage;\n        collectionArtistPrimaryAddresses[_collectionID].add3Percentage = _add3Percentage;\n        collectionArtistPrimaryAddresses[_collectionID].setStatus = true;\n        collectionArtistPrimaryAddresses[_collectionID].approvedStatus = false;\n    }\n\n    // function to propose secondary addresses and percentages for each address\n\n    function proposeSecondaryAddressesAndPercentages(uint256 _collectionID, address _secondaryAdd1, address _secondaryAdd2, address _secondaryAdd3, uint256 _add1Percentage, uint256 _add2Percentage, uint256 _add3Percentage) public ArtistOrAdminRequired(_collectionID, this.proposeSecondaryAddressesAndPercentages.selector) {\n        require (collectionArtistSecondaryAddresses[_collectionID].approvedStatus == false, \"Already approved\");\n        require (_add1Percentage + _add2Percentage + _add3Percentage == collectionRoyaltiesSecondarySplits[_collectionID].artistPercentage, \"Check %\");\n        collectionArtistSecondaryAddresses[_collectionID].secondaryAdd1 = _secondaryAdd1;\n        collectionArtistSecondaryAddresses[_collectionID].secondaryAdd2 = _secondaryAdd2;\n        collectionArtistSecondaryAddresses[_collectionID].secondaryAdd3 = _secondaryAdd3;\n        collectionArtistSecondaryAddresses[_collectionID].add1Percentage = _add1Percentage;\n        collectionArtistSecondaryAddresses[_collectionID].add2Percentage = _add2Percentage;\n        collectionArtistSecondaryAddresses[_collectionID].add3Percentage = _add3Percentage;\n        collectionArtistSecondaryAddresses[_collectionID].setStatus = true;\n        collectionArtistSecondaryAddresses[_collectionID].approvedStatus = false;\n    }\n\n    // function to accept primary addresses and percentages\n\n    function acceptAddressesAndPercentages(uint256 _collectionID, bool _statusPrimary, bool _statusSecondary) public FunctionAdminRequired(this.acceptAddressesAndPercentages.selector) {\n        require(collectionArtistPrimaryAddresses[_collectionID].setStatus == true \u0026\u0026 collectionArtistSecondaryAddresses[_collectionID].setStatus == true, \"Propose Addresses\");\n        collectionArtistPrimaryAddresses[_collectionID].approvedStatus = _statusPrimary;\n        collectionArtistSecondaryAddresses[_collectionID].approvedStatus = _statusSecondary;\n        if (_statusPrimary == false) {\n            collectionArtistPrimaryAddresses[_collectionID].setStatus = false;\n        } else if (_statusSecondary == false) {\n            collectionArtistSecondaryAddresses[_collectionID].setStatus = false;\n        }\n    }\n\n    // function to transfer funds to the artist and team\n\n    function payArtist(uint256 _collectionID, address _team1, address _team2, uint256 _teamperc1, uint256 _teamperc2) public FunctionAdminRequired(this.payArtist.selector) {\n        require(collectionArtistPrimaryAddresses[_collectionID].approvedStatus == true, \"Accept Royalties\");\n        require(collectionTotalAmount[_collectionID] \u003e 0, \"Collection Balance must be grater than 0\");\n        require(collectionRoyaltiesPrimarySplits[_collectionID].artistPercentage + _teamperc1 + _teamperc2 == 100, \"Change percentages\");\n        uint256 royalties = collectionTotalAmount[_collectionID];\n        collectionTotalAmount[_collectionID] = 0;\n        address tm1 = _team1;\n        address tm2 = _team2;\n        uint256 colId = _collectionID;\n        uint256 artistRoyalties1;\n        uint256 artistRoyalties2;\n        uint256 artistRoyalties3;\n        uint256 teamRoyalties1;\n        uint256 teamRoyalties2;\n        artistRoyalties1 = royalties * collectionArtistPrimaryAddresses[colId].add1Percentage / 100;\n        artistRoyalties2 = royalties * collectionArtistPrimaryAddresses[colId].add2Percentage / 100;\n        artistRoyalties3 = royalties * collectionArtistPrimaryAddresses[colId].add3Percentage / 100;\n        teamRoyalties1 = royalties * _teamperc1 / 100;\n        teamRoyalties2 = royalties * _teamperc2 / 100;\n        (bool success1, ) = payable(collectionArtistPrimaryAddresses[colId].primaryAdd1).call{value: artistRoyalties1}(\"\");\n        (bool success2, ) = payable(collectionArtistPrimaryAddresses[colId].primaryAdd2).call{value: artistRoyalties2}(\"\");\n        (bool success3, ) = payable(collectionArtistPrimaryAddresses[colId].primaryAdd3).call{value: artistRoyalties3}(\"\");\n        (bool success4, ) = payable(tm1).call{value: teamRoyalties1}(\"\");\n        (bool success5, ) = payable(tm2).call{value: teamRoyalties2}(\"\");\n        require(success1, \"ETH failed\");\n        require(success2, \"ETH failed\");\n        require(success3, \"ETH failed\");\n        require(success4, \"ETH failed\");\n        require(success5, \"ETH failed\");\n    }\n\n    // function to update core contract\n\n    function updateCoreContract(address _gencore) public FunctionAdminRequired(this.updateCoreContract.selector) { \n        gencore = INextGenCore(_gencore);\n    }\n\n    // function to update admin contract\n\n    function updateAdminContract(address _newadminsContract) public FunctionAdminRequired(this.updateAdminContract.selector) {\n        require(INextGenAdmins(_newadminsContract).isAdminContract() == true, \"Contract is not Admin\");\n        adminsContract = INextGenAdmins(_newadminsContract);\n    }\n\n    // function to withdraw any balance from the smart contract\n\n    function emergencyWithdraw() public FunctionAdminRequired(this.emergencyWithdraw.selector) {\n        uint balance = address(this).balance;\n        address admin = adminsContract.owner();\n        (bool success, ) = payable(admin).call{value: balance}(\"\");\n        require(success, \"ETH failed\");\n        emit Withdraw(msg.sender, success, balance);\n    }\n\n    // function to retrieve primary splits between artist and team\n\n    function retrievePrimarySplits(uint256 _collectionID) public view returns(uint256, uint256){\n        return (collectionRoyaltiesPrimarySplits[_collectionID].artistPercentage, collectionRoyaltiesPrimarySplits[_collectionID].teamPercentage);\n    }\n\n    // function to retrieve primary addresses and percentages\n\n    function retrievePrimaryAddressesAndPercentages(uint256 _collectionID) public view returns(address, address, address, uint256, uint256, uint256, bool){\n        return (collectionArtistPrimaryAddresses[_collectionID].primaryAdd1, collectionArtistPrimaryAddresses[_collectionID].primaryAdd2, collectionArtistPrimaryAddresses[_collectionID].primaryAdd3, collectionArtistPrimaryAddresses[_collectionID].add1Percentage, collectionArtistPrimaryAddresses[_collectionID].add2Percentage, collectionArtistPrimaryAddresses[_collectionID].add3Percentage, collectionArtistPrimaryAddresses[_collectionID].approvedStatus);\n    }\n\n    // function to retrieve secondary splits between artist and team\n\n    function retrieveSecondarySplits(uint256 _collectionID) public view returns(uint256, uint256){\n        return (collectionRoyaltiesSecondarySplits[_collectionID].artistPercentage, collectionRoyaltiesSecondarySplits[_collectionID].teamPercentage);\n    }\n\n    // function to retrieve secondary addresses and percentages\n\n    function retrieveSecondaryAddressesAndPercentages(uint256 _collectionID) public view returns(address, address, address, uint256, uint256, uint256, bool){\n        return (collectionArtistSecondaryAddresses[_collectionID].secondaryAdd1, collectionArtistSecondaryAddresses[_collectionID].secondaryAdd2, collectionArtistSecondaryAddresses[_collectionID].secondaryAdd3, collectionArtistSecondaryAddresses[_collectionID].add1Percentage, collectionArtistSecondaryAddresses[_collectionID].add2Percentage, collectionArtistSecondaryAddresses[_collectionID].add3Percentage, collectionArtistSecondaryAddresses[_collectionID].approvedStatus);\n    }\n\n    // function to retrieve the phases and merkle root of a collection\n\n    function retrieveCollectionPhases(uint256 _collectionID) public view returns(uint, uint, bytes32, uint, uint){\n        return (collectionPhases[_collectionID].allowlistStartTime, collectionPhases[_collectionID].allowlistEndTime, collectionPhases[_collectionID].merkleRoot, collectionPhases[_collectionID].publicStartTime, collectionPhases[_collectionID].publicEndTime);\n    }\n\n    // function to retrieve the minting details of a collection\n\n    function retrieveCollectionMintingDetails(uint256 _collectionID) public view returns(uint256, uint256, uint256, uint256, uint8, address){\n        return (collectionPhases[_collectionID].collectionMintCost, collectionPhases[_collectionID].collectionEndMintCost, collectionPhases[_collectionID].rate, collectionPhases[_collectionID].timePeriod, collectionPhases[_collectionID].salesOption, collectionPhases[_collectionID].delAddress);\n    }\n\n    // retrieve minter contract status\n\n    function isMinterContract() external view returns (bool) {\n        return true;\n    }\n\n    // retrieve minting end time\n\n    function getEndTime(uint256 _collectionID) external view returns (uint) {\n        return collectionPhases[_collectionID].publicEndTime;\n    }\n\n    // retrieve auction end time\n\n    function getAuctionEndTime(uint256 _tokenId) external view returns (uint) {\n        return mintToAuctionData[_tokenId];\n    }\n\n    // retrieve auction status\n\n    function getAuctionStatus(uint256 _tokenId) external view  returns (bool) {\n        return mintToAuctionStatus[_tokenId];\n    }\n\n    // retrieve the minting price of collection\n\n    function getPrice(uint256 _collectionId) public view returns (uint256) {\n        uint tDiff;\n        if (collectionPhases[_collectionId].salesOption == 3) {\n            // periodic sale model\n            // if rate \u003e 0 minting price increases by rate (percentage) during each mint\n            if (collectionPhases[_collectionId].rate \u003e 0) {\n                return collectionPhases[_collectionId].collectionMintCost + ((collectionPhases[_collectionId].collectionMintCost * collectionPhases[_collectionId].rate / 100) * (gencore.viewCirSupply(_collectionId) - excludeTokensCounter[_collectionId]));\n            } else {\n                return collectionPhases[_collectionId].collectionMintCost;\n            }\n        } else if (collectionPhases[_collectionId].salesOption == 2 \u0026\u0026 block.timestamp \u003e= collectionPhases[_collectionId].allowlistStartTime \u0026\u0026 block.timestamp \u003c= collectionPhases[_collectionId].publicEndTime){\n            // decreases during a time period\n            // if only public minting set allowlistStartTime = publicStartTime\n            // if rate = 0 exponential descending model, otherwise, linear descending model\n            // if rate is set the linear decrase each period per rate\n            tDiff = (block.timestamp - collectionPhases[_collectionId].allowlistStartTime) / collectionPhases[_collectionId].timePeriod;\n            uint256 price;\n            uint256 decreaserate;\n            if (collectionPhases[_collectionId].rate == 0) {\n                price = collectionPhases[_collectionId].collectionMintCost / (tDiff + 1);\n                decreaserate = ((price - (collectionPhases[_collectionId].collectionMintCost / (tDiff + 2))) / collectionPhases[_collectionId].timePeriod) * ((block.timestamp - (tDiff * collectionPhases[_collectionId].timePeriod) - collectionPhases[_collectionId].allowlistStartTime));\n            } else {\n                if (((collectionPhases[_collectionId].collectionMintCost - collectionPhases[_collectionId].collectionEndMintCost) / (collectionPhases[_collectionId].rate)) \u003e= tDiff) {\n                    price = collectionPhases[_collectionId].collectionMintCost - (tDiff * collectionPhases[_collectionId].rate);\n                } else {\n                    price = collectionPhases[_collectionId].collectionEndMintCost;\n                }\n            }\n            if (price - decreaserate \u003e collectionPhases[_collectionId].collectionEndMintCost) {\n                return price - decreaserate; \n            } else {\n                return collectionPhases[_collectionId].collectionEndMintCost;\n            }\n        } else {\n            // fixed price model\n            return collectionPhases[_collectionId].collectionMintCost;\n        }\n    }\n\n}"}}