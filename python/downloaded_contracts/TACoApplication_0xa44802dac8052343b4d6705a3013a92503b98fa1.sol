{"Address.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There\u0027s no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity\u0027s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn\u0027t, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"},"ContextUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"},"IApplication.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n\n// ██████████████     ▐████▌     ██████████████\n// ██████████████     ▐████▌     ██████████████\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n// ██████████████     ▐████▌     ██████████████\n// ██████████████     ▐████▌     ██████████████\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n\npragma solidity ^0.8.9;\n\n/// @title  Application interface for Threshold Network applications\n/// @notice Generic interface for an application. Application is an external\n///         smart contract or a set of smart contracts utilizing functionalities\n///         offered by Threshold Network. Applications authorized for the given\n///         staking provider are eligible to slash the stake delegated to that\n///         staking provider.\ninterface IApplication {\n    /// @dev Event emitted by `withdrawRewards` function.\n    event RewardsWithdrawn(address indexed stakingProvider, uint96 amount);\n\n    /// @notice Withdraws application rewards for the given staking provider.\n    ///         Rewards are withdrawn to the staking provider\u0027s beneficiary\n    ///         address set in the staking contract.\n    /// @dev Emits `RewardsWithdrawn` event.\n    function withdrawRewards(address stakingProvider) external;\n\n    /// @notice Used by T staking contract to inform the application that the\n    ///         authorized amount for the given staking provider increased.\n    ///         The application may do any necessary housekeeping. The\n    ///         application must revert the transaction in case the\n    ///         authorization is below the minimum required.\n    function authorizationIncreased(\n        address stakingProvider,\n        uint96 fromAmount,\n        uint96 toAmount\n    ) external;\n\n    /// @notice Used by T staking contract to inform the application that the\n    ///         authorization decrease for the given staking provider has been\n    ///         requested. The application should mark the authorization as\n    ///         pending decrease and respond to the staking contract with\n    ///         `approveAuthorizationDecrease` at its discretion. It may\n    ///         happen right away but it also may happen several months later.\n    ///         If there is already a pending authorization decrease request\n    ///         for the application, and the application does not agree for\n    ///         overwriting it, the function should revert.\n    function authorizationDecreaseRequested(\n        address stakingProvider,\n        uint96 fromAmount,\n        uint96 toAmount\n    ) external;\n\n    /// @notice Used by T staking contract to inform the application the\n    ///         authorization has been decreased for the given staking provider\n    ///         involuntarily, as a result of slashing. Lets the application to\n    ///         do any housekeeping neccessary. Called with 250k gas limit and\n    ///         does not revert the transaction if\n    ///         `involuntaryAuthorizationDecrease` call failed.\n    function involuntaryAuthorizationDecrease(\n        address stakingProvider,\n        uint96 fromAmount,\n        uint96 toAmount\n    ) external;\n\n    /// @notice Returns the amount of application rewards available for\n    ///         withdrawal for the given staking provider.\n    function availableRewards(address stakingProvider)\n        external\n        view\n        returns (uint96);\n\n    /// @notice The minimum authorization amount required for the staking\n    ///         provider so that they can participate in the application.\n    function minimumAuthorization() external view returns (uint96);\n}\n"},"IApplicationWithDecreaseDelay.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n\n// ██████████████     ▐████▌     ██████████████\n// ██████████████     ▐████▌     ██████████████\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n// ██████████████     ▐████▌     ██████████████\n// ██████████████     ▐████▌     ██████████████\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n\npragma solidity ^0.8.9;\n\nimport \"IApplication.sol\";\n\n/// @title  Interface for Threshold Network applications with delay after decrease request\ninterface IApplicationWithDecreaseDelay is IApplication {\n    /// @notice Returns authorization-related parameters of the application.\n    /// @dev The minimum authorization is also returned by `minimumAuthorization()`\n    ///      function, as a requirement of `IApplication` interface.\n    /// @return _minimumAuthorization The minimum authorization amount required\n    ///         so that operator can participate in the application.\n    /// @return authorizationDecreaseDelay Delay in seconds that needs to pass\n    ///         between the time authorization decrease is requested and the\n    ///         time that request gets approved. Protects against free-riders\n    ///         earning rewards and not being active in the network.\n    /// @return authorizationDecreaseChangePeriod Authorization decrease change\n    ///        period in seconds. It is the time, before authorization decrease\n    ///        delay end, during which the pending authorization decrease\n    ///        request can be overwritten.\n    ///        If set to 0, pending authorization decrease request can not be\n    ///        overwritten until the entire `authorizationDecreaseDelay` ends.\n    ///        If set to value equal `authorizationDecreaseDelay`, request can\n    ///        always be overwritten.\n    function authorizationParameters()\n        external\n        view\n        returns (\n            uint96 _minimumAuthorization,\n            uint64 authorizationDecreaseDelay,\n            uint64 authorizationDecreaseChangePeriod\n        );\n\n    /// @notice Returns the amount of stake that is pending authorization\n    ///         decrease for the given staking provider. If no authorization\n    ///         decrease has been requested, returns zero.\n    function pendingAuthorizationDecrease(address _stakingProvider) external view returns (uint96);\n\n    /// @notice Returns the remaining time in seconds that needs to pass before\n    ///         the requested authorization decrease can be approved.\n    function remainingAuthorizationDecreaseDelay(\n        address stakingProvider\n    ) external view returns (uint64);\n\n    /// @notice Approves the previously registered authorization decrease\n    ///         request. Reverts if authorization decrease delay has not passed\n    ///         yet or if the authorization decrease was not requested for the\n    ///         given staking provider.\n    function approveAuthorizationDecrease(address stakingProvider) external;\n}\n"},"IApplicationWithOperator.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n\n// ██████████████     ▐████▌     ██████████████\n// ██████████████     ▐████▌     ██████████████\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n// ██████████████     ▐████▌     ██████████████\n// ██████████████     ▐████▌     ██████████████\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n\npragma solidity ^0.8.9;\n\nimport \"IApplication.sol\";\n\n/// @title  Interface for Threshold Network applications with operator role\ninterface IApplicationWithOperator is IApplication {\n    /// @notice Returns operator registered for the given staking provider.\n    function stakingProviderToOperator(address stakingProvider) external view returns (address);\n\n    /// @notice Returns staking provider of the given operator.\n    function operatorToStakingProvider(address operator) external view returns (address);\n\n    /// @notice Used by staking provider to set operator address that will\n    ///         operate a node. The operator addressmust be unique.\n    ///         Reverts if the operator is already set for the staking provider\n    ///         or if the operator address is already in use.\n    /// @dev    Depending on application the given staking provider can set operator\n    ///         address only one or multiple times. Besides that application can decide\n    ///         if function reverts if there is a pending authorization decrease for\n    ///         the staking provider.\n    function registerOperator(address operator) external;\n\n    // TODO consider that?\n    // /// @notice Used by additional role (owner for example) to set operator address that will\n    // ///         operate a node for the specified staking provider.\n    // function registerOperator(address stakingProvider, address operator) external;\n}\n"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"IERC20Permit.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account\u0027s ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn\u0027t\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don\u0027t rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``\u0027s tokens,\n     * given ``owner``\u0027s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``\u0027s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``\u0027s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"},"Initializable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it\u0027s common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It\u0027s implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) \u0026 ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 \u0026\u0026 isTopLevelCall;\n        bool construction = initialized == 1 \u0026\u0026 address(this).code.length == 0;\n\n        if (!initialSetup \u0026\u0026 !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn\u0027t been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized \u003e= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"},"IStaking.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n\n// ██████████████     ▐████▌     ██████████████\n// ██████████████     ▐████▌     ██████████████\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n// ██████████████     ▐████▌     ██████████████\n// ██████████████     ▐████▌     ██████████████\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n\npragma solidity ^0.8.9;\n\n/// @title Interface of Threshold Network staking contract\n/// @notice The staking contract enables T owners to have their wallets offline\n///         and their stake managed by staking providers on their behalf.\n///         The staking contract does not define operator role. The operator\n///         responsible for running off-chain client software is appointed by\n///         the staking provider in the particular application utilizing the\n///         staking contract. All off-chain client software should be able\n///         to run without exposing operator\u0027s or staking provider’s private\n///         key and should not require any owner’s keys at all. The stake\n///         delegation optimizes the network throughput without compromising the\n///         security of the owners’ stake.\ninterface IStaking {\n    enum StakeType {\n        NU,\n        KEEP,\n        T\n    }\n\n    //\n    //\n    // Delegating a stake\n    //\n    //\n\n    /// @notice Creates a delegation with `msg.sender` owner with the given\n    ///         staking provider, beneficiary, and authorizer. Transfers the\n    ///         given amount of T to the staking contract.\n    /// @dev The owner of the delegation needs to have the amount approved to\n    ///      transfer to the staking contract.\n    function stake(\n        address stakingProvider,\n        address payable beneficiary,\n        address authorizer,\n        uint96 amount\n    ) external;\n\n    /// @notice Allows the Governance to set the minimum required stake amount.\n    ///         This amount is required to protect against griefing the staking\n    ///         contract and individual applications are allowed to require\n    ///         higher minimum stakes if necessary.\n    function setMinimumStakeAmount(uint96 amount) external;\n\n    //\n    //\n    // Authorizing an application\n    //\n    //\n\n    /// @notice Allows the Governance to approve the particular application\n    ///         before individual stake authorizers are able to authorize it.\n    function approveApplication(address application) external;\n\n    /// @notice Increases the authorization of the given staking provider for\n    ///         the given application by the given amount. Can only be called by\n    ///         the authorizer for that staking provider.\n    /// @dev Calls `authorizationIncreased(address stakingProvider, uint256 amount)`\n    ///      on the given application to notify the application about\n    ///      authorization change. See `IApplication`.\n    function increaseAuthorization(\n        address stakingProvider,\n        address application,\n        uint96 amount\n    ) external;\n\n    /// @notice Requests decrease of the authorization for the given staking\n    ///         provider on the given application by the provided amount.\n    ///         It may not change the authorized amount immediatelly. When\n    ///         it happens depends on the application. Can only be called by the\n    ///         given staking provider’s authorizer. Overwrites pending\n    ///         authorization decrease for the given staking provider and\n    ///         application if the application agrees for that. If the\n    ///         application does not agree for overwriting, the function\n    ///         reverts.\n    /// @dev Calls `authorizationDecreaseRequested(address stakingProvider, uint256 amount)`\n    ///      on the given application. See `IApplication`.\n    function requestAuthorizationDecrease(\n        address stakingProvider,\n        address application,\n        uint96 amount\n    ) external;\n\n    /// @notice Requests decrease of all authorizations for the given staking\n    ///         provider on all applications by all authorized amount.\n    ///         It may not change the authorized amount immediatelly. When\n    ///         it happens depends on the application. Can only be called by the\n    ///         given staking provider’s authorizer. Overwrites pending\n    ///         authorization decrease for the given staking provider and\n    ///         application.\n    /// @dev Calls `authorizationDecreaseRequested(address stakingProvider, uint256 amount)`\n    ///      for each authorized application. See `IApplication`.\n    function requestAuthorizationDecrease(address stakingProvider) external;\n\n    /// @notice Called by the application at its discretion to approve the\n    ///         previously requested authorization decrease request. Can only be\n    ///         called by the application that was previously requested to\n    ///         decrease the authorization for that staking provider.\n    ///         Returns resulting authorized amount for the application.\n    function approveAuthorizationDecrease(address stakingProvider)\n        external\n        returns (uint96);\n\n    /// @notice Decreases the authorization for the given `stakingProvider` on\n    ///         the given disabled `application`, for all authorized amount.\n    ///         Can be called by anyone.\n    function forceDecreaseAuthorization(\n        address stakingProvider,\n        address application\n    ) external;\n\n    /// @notice Pauses the given application’s eligibility to slash stakes.\n    ///         Besides that stakers can\u0027t change authorization to the application.\n    ///         Can be called only by the Panic Button of the particular\n    ///         application. The paused application can not slash stakes until\n    ///         it is approved again by the Governance using `approveApplication`\n    ///         function. Should be used only in case of an emergency.\n    function pauseApplication(address application) external;\n\n    /// @notice Disables the given application. The disabled application can\u0027t\n    ///         slash stakers. Also stakers can\u0027t increase authorization to that\n    ///         application but can decrease without waiting by calling\n    ///         `requestAuthorizationDecrease` at any moment. Can be called only\n    ///         by the governance. The disabled application can\u0027t be approved\n    ///         again. Should be used only in case of an emergency.\n    function disableApplication(address application) external;\n\n    /// @notice Sets the Panic Button role for the given application to the\n    ///         provided address. Can only be called by the Governance. If the\n    ///         Panic Button for the given application should be disabled, the\n    ///         role address should be set to 0x0 address.\n    function setPanicButton(address application, address panicButton) external;\n\n    /// @notice Sets the maximum number of applications one staking provider can\n    ///         have authorized. Used to protect against DoSing slashing queue.\n    ///         Can only be called by the Governance.\n    function setAuthorizationCeiling(uint256 ceiling) external;\n\n    //\n    //\n    // Stake top-up\n    //\n    //\n\n    /// @notice Increases the amount of the stake for the given staking provider.\n    ///         If `autoIncrease` flag is true then the amount will be added for\n    ///         all authorized applications.\n    /// @dev The sender of this transaction needs to have the amount approved to\n    ///      transfer to the staking contract.\n    function topUp(address stakingProvider, uint96 amount) external;\n\n    /// @notice Toggle `autoIncrease` flag. If true then the complete amount\n    ///         in top-up will be added to already authorized applications.\n    function toggleAutoAuthorizationIncrease(address stakingProvider) external;\n\n    //\n    //\n    // Undelegating a stake (unstaking)\n    //\n    //\n\n    /// @notice Reduces the liquid T stake amount by the provided amount and\n    ///         withdraws T to the owner. Reverts if there is at least one\n    ///         authorization higher than the sum of the legacy stake and\n    ///         remaining liquid T stake or if the unstake amount is higher than\n    ///         the liquid T stake amount. Can be called only by the delegation\n    ///         owner or the staking provider.\n    function unstakeT(address stakingProvider, uint96 amount) external;\n\n    /// @notice Sets the legacy KEEP staking contract active stake amount cached\n    ///         in T staking contract to 0. Reverts if the amount of liquid T\n    ///         staked in T staking contract is lower than the highest\n    ///         application authorization. This function allows to unstake from\n    ///         KEEP staking contract and still being able to operate in T\n    ///         network and earning rewards based on the liquid T staked. Can be\n    ///         called only by the delegation owner or the staking provider.\n    function unstakeKeep(address stakingProvider) external;\n\n    /// @notice Sets to 0 the amount of T that is cached from the legacy\n    ///         NU staking contract. Reverts if there is at least one\n    ///         authorization higher than the sum of remaining legacy NU stake\n    ///         and native T stake for that staking provider or if the unstaked\n    ///         amount is higher than the cached legacy stake amount. If succeeded,\n    ///         the legacy NU stake can be partially or fully undelegated on\n    ///         the legacy NU staking contract. This function allows to unstake\n    ///         from NU staking contract while still being able to operate in\n    ///         T network and earning rewards based on the native T staked.\n    ///         Can be called only by the stake owner or the staking provider.\n    function unstakeNu(address stakingProvider) external;\n\n    /// @notice Sets cached legacy stake amount to 0, sets the liquid T stake\n    ///         amount to 0 and withdraws all liquid T from the stake to the\n    ///         owner. Reverts if there is at least one non-zero authorization.\n    ///         Can be called only by the delegation owner or the staking\n    ///         provider.\n    function unstakeAll(address stakingProvider) external;\n\n    //\n    //\n    // Keeping information in sync\n    //\n    //\n\n    /// @notice Sets reward in T tokens for notification of misbehaviour\n    ///         of one staking provider. Can only be called by the governance.\n    function setNotificationReward(uint96 reward) external;\n\n    /// @notice Transfer some amount of T tokens as reward for notifications\n    ///         of misbehaviour\n    function pushNotificationReward(uint96 reward) external;\n\n    /// @notice Withdraw some amount of T tokens from notifiers treasury.\n    ///         Can only be called by the governance.\n    function withdrawNotificationReward(address recipient, uint96 amount)\n        external;\n\n    /// @notice Adds staking providers to the slashing queue along with the\n    ///         amount that should be slashed from each one of them. Can only be\n    ///         called by application authorized for all staking providers in\n    ///         the array.\n    function slash(uint96 amount, address[] memory stakingProviders) external;\n\n    /// @notice Adds staking providers to the slashing queue along with the\n    ///         amount. The notifier will receive reward per each staking\n    ///         provider from notifiers treasury. Can only be called by\n    ///         application authorized for all staking providers in the array.\n    function seize(\n        uint96 amount,\n        uint256 rewardMultipier,\n        address notifier,\n        address[] memory stakingProviders\n    ) external;\n\n    /// @notice Takes the given number of queued slashing operations and\n    ///         processes them. Receives 5% of the slashed amount.\n    ///         Executes `involuntaryAllocationDecrease` function on each\n    ///         affected application.\n    function processSlashing(uint256 count) external;\n\n    //\n    //\n    // Auxiliary functions\n    //\n    //\n\n    /// @notice Returns the authorized stake amount of the staking provider for\n    ///         the application.\n    function authorizedStake(address stakingProvider, address application)\n        external\n        view\n        returns (uint96);\n\n    /// @notice Returns staked amount of T, Keep and Nu for the specified\n    ///         staking provider.\n    /// @dev    All values are in T denomination\n    function stakes(address stakingProvider)\n        external\n        view\n        returns (\n            uint96 tStake,\n            uint96 keepInTStake,\n            uint96 nuInTStake\n        );\n\n    /// @notice Returns start staking timestamp.\n    /// @dev    This value is set at most once.\n    function getStartStakingTimestamp(address stakingProvider)\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns auto-increase flag.\n    function getAutoIncreaseFlag(address stakingProvider)\n        external\n        view\n        returns (bool);\n\n    /// @notice Returns staked amount of NU for the specified staking provider.\n    function stakedNu(address stakingProvider) external view returns (uint256);\n\n    /// @notice Gets the stake owner, the beneficiary and the authorizer\n    ///         for the specified staking provider address.\n    /// @return owner Stake owner address.\n    /// @return beneficiary Beneficiary address.\n    /// @return authorizer Authorizer address.\n    function rolesOf(address stakingProvider)\n        external\n        view\n        returns (\n            address owner,\n            address payable beneficiary,\n            address authorizer\n        );\n\n    /// @notice Returns length of application array\n    function getApplicationsLength() external view returns (uint256);\n\n    /// @notice Returns length of slashing queue\n    function getSlashingQueueLength() external view returns (uint256);\n\n    /// @notice Returns minimum possible stake for T, KEEP or NU in T\n    ///         denomination.\n    /// @dev For example, suppose the given staking provider has 10 T, 20 T worth\n    ///      of KEEP, and 30 T worth of NU all staked, and the maximum\n    ///      application authorization is 40 T, then `getMinStaked` for\n    ///      that staking provider returns:\n    ///          * 0 T if KEEP stake type specified i.e.\n    ///            min = 40 T max - (10 T) = 30 T\n    ///          * 10 T if NU stake type specified i.e.\n    ///            min = 40 T max - (10 T) = 30 T\n    ///          * 0 T if T stake type specified i.e.\n    ///            min = 40 T max = 40 T\n    ///      In other words, the minimum stake amount for the specified\n    ///      stake type is the minimum amount of stake of the given type\n    ///      needed to satisfy the maximum application authorization given\n    ///      the staked amounts of the T stake types for that staking provider.\n    function getMinStaked(address stakingProvider, StakeType stakeTypes)\n        external\n        view\n        returns (uint96);\n\n    /// @notice Returns available amount to authorize for the specified application\n    function getAvailableToAuthorize(\n        address stakingProvider,\n        address application\n    ) external view returns (uint96);\n}\n"},"ITACoChildToRoot.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.0;\n\n/**\n * @title ITACoChildToRoot\n * @notice Interface for x-chain interactions from coordinator to application\n */\ninterface ITACoChildToRoot {\n    /**\n     * @notice Signals that an operator address is confirmed\n     * @param stakingProvider Staking provider address\n     * @param operator Operator address\n     */\n    event OperatorConfirmed(address indexed stakingProvider, address indexed operator);\n\n    function confirmOperatorAddress(address operator) external;\n}\n"},"ITACoRootToChild.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.0;\n\n/**\n * @title ITACoRootToChild\n * @notice Interface for x-chain interactions from application to coordinator\n */\ninterface ITACoRootToChild {\n    event OperatorUpdated(address indexed stakingProvider, address indexed operator);\n    event AuthorizationUpdated(address indexed stakingProvider, uint96 amount);\n\n    function updateOperator(address stakingProvider, address operator) external;\n\n    function updateAuthorization(address stakingProvider, uint96 amount) external;\n}\n"},"Math.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c \u003c a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b \u003e a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n            // benefit is lost if \u0027b\u0027 is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003e b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a \u0026 b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator \u003c= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always \u003e= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator \u0026 (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\u0027s lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\u0027t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) \u0026\u0026 mulmod(x, y, denominator) \u003e 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.\u0027s \"Hacker\u0027s Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) \u003c= a \u003c 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) \u003c= a \u003c 2**(log2(a) + 1)`\n        // → `sqrt(2**k) \u003c= sqrt(a) \u003c sqrt(2**(k+1))`\n        // → `2**(k/2) \u003c= sqrt(a) \u003c 2**((k+1)/2) \u003c= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 \u003c\u003c (log2(a) \u003e\u003e 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\u0027s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 result * result \u003c a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 128;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 64;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 32;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 16;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                value \u003e\u003e= 8;\n                result += 8;\n            }\n            if (value \u003e\u003e 4 \u003e 0) {\n                value \u003e\u003e= 4;\n                result += 4;\n            }\n            if (value \u003e\u003e 2 \u003e 0) {\n                value \u003e\u003e= 2;\n                result += 2;\n            }\n            if (value \u003e\u003e 1 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value \u003e= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value \u003e= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value \u003e= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value \u003e= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value \u003e= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value \u003e= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 10 ** result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 16;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 8;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 4;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 2;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c (result \u003c\u003c 3) \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"},"OwnableUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ContextUpgradeable} from \"ContextUpgradeable.sol\";\nimport {Initializable} from \"Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Ownable\")) - 1)) \u0026 ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"},"SafeCast.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity\u0027s uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn\u0027t fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn\u0027t fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn\u0027t fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn\u0027t fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity\u0027s `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value \u003e type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity\u0027s `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value \u003e type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity\u0027s `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value \u003e type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity\u0027s `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value \u003e type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity\u0027s `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value \u003e type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity\u0027s `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value \u003e type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity\u0027s `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value \u003e type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity\u0027s `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value \u003e type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity\u0027s `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value \u003e type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity\u0027s `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value \u003e type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity\u0027s `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value \u003e type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity\u0027s `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value \u003e type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity\u0027s `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value \u003e type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity\u0027s `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value \u003e type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity\u0027s `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value \u003e type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity\u0027s `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value \u003e type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity\u0027s `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value \u003e type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity\u0027s `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value \u003e type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity\u0027s `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value \u003e type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity\u0027s `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value \u003e type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity\u0027s `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value \u003e type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity\u0027s `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value \u003e type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity\u0027s `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity\u0027s `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value \u003e type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity\u0027s `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value \u003e type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity\u0027s `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value \u003e type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity\u0027s `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity\u0027s `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value \u003e type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity\u0027s `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value \u003e type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity\u0027s `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value \u003e type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity\u0027s `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value \u003e type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value \u003c 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity\u0027s `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity\u0027s `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity\u0027s `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity\u0027s `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity\u0027s `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity\u0027s `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity\u0027s `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity\u0027s `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity\u0027s `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity\u0027s `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity\u0027s `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity\u0027s `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity\u0027s `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity\u0027s `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity\u0027s `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity\u0027s `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity\u0027s `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity\u0027s `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity\u0027s `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity\u0027s `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity\u0027s `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity\u0027s `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity\u0027s `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity\u0027s `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity\u0027s `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity\u0027s `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity\u0027s `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity\u0027s `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity\u0027s `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity\u0027s `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity\u0027s `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value \u003e uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n"},"SafeERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"IERC20.sol\";\nimport {IERC20Permit} from \"IERC20Permit.sol\";\nimport {Address} from \"Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract\u0027s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract\u0027s allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance \u003c requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\u0027s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\u0027s return data size checking mechanism, since\n        // we\u0027re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 \u0026\u0026 !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\u0027s return data size checking mechanism, since\n        // we\u0027re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success \u0026\u0026 (returndata.length == 0 || abi.decode(returndata, (bool))) \u0026\u0026 address(token).code.length \u003e 0;\n    }\n}\n"},"TACoApplication.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.0;\n\nimport \"Math.sol\";\nimport \"SafeCast.sol\";\nimport \"SafeERC20.sol\";\nimport \"IERC20.sol\";\nimport \"OwnableUpgradeable.sol\";\nimport \"IApplicationWithOperator.sol\";\nimport \"IApplicationWithDecreaseDelay.sol\";\nimport \"IStaking.sol\";\nimport \"ITACoRootToChild.sol\";\nimport \"ITACoChildToRoot.sol\";\n\n/**\n * @title TACo Application\n * @notice Contract distributes rewards for participating in app and slashes for violating rules\n */\ncontract TACoApplication is\n    IApplicationWithDecreaseDelay,\n    IApplicationWithOperator,\n    ITACoChildToRoot,\n    OwnableUpgradeable\n{\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n\n    /**\n     * @notice Signals that distributor role was set\n     * @param distributor Address of reward distributor\n     */\n    event RewardDistributorSet(address indexed distributor);\n\n    /**\n     * @notice Signals that reward was added\n     * @param reward Amount of reward\n     */\n    event RewardAdded(uint256 reward);\n\n    /**\n     * @notice Signals that the beneficiary related to the staking provider received reward\n     * @param stakingProvider Staking provider address\n     * @param beneficiary Beneficiary address\n     * @param reward Amount of reward\n     */\n    event RewardPaid(address indexed stakingProvider, address indexed beneficiary, uint256 reward);\n\n    /**\n     * @notice Signals that authorization was increased for the staking provider\n     * @param stakingProvider Staking provider address\n     * @param fromAmount Previous amount of increased authorization\n     * @param toAmount New amount of increased authorization\n     */\n    event AuthorizationIncreased(\n        address indexed stakingProvider,\n        uint96 fromAmount,\n        uint96 toAmount\n    );\n\n    /**\n     * @notice Signals that authorization was decreased involuntary\n     * @param stakingProvider Staking provider address\n     * @param fromAmount Previous amount of authorized tokens\n     * @param toAmount Amount of authorized tokens to decrease\n     */\n    event AuthorizationInvoluntaryDecreased(\n        address indexed stakingProvider,\n        uint96 fromAmount,\n        uint96 toAmount\n    );\n\n    /**\n     * @notice Signals that authorization decrease was requested for the staking provider\n     * @param stakingProvider Staking provider address\n     * @param fromAmount Current amount of authorized tokens\n     * @param toAmount Amount of authorization to decrease\n     */\n    event AuthorizationDecreaseRequested(\n        address indexed stakingProvider,\n        uint96 fromAmount,\n        uint96 toAmount\n    );\n\n    /**\n     * @notice Signals that authorization decrease was approved for the staking provider\n     * @param stakingProvider Staking provider address\n     * @param fromAmount Previous amount of authorized tokens\n     * @param toAmount Decreased amount of authorized tokens\n     */\n    event AuthorizationDecreaseApproved(\n        address indexed stakingProvider,\n        uint96 fromAmount,\n        uint96 toAmount\n    );\n\n    /**\n     * @notice Signals that authorization was resynchronized\n     * @param stakingProvider Staking provider address\n     * @param fromAmount Previous amount of authorized tokens\n     * @param toAmount Resynchronized amount of authorized tokens\n     */\n    event AuthorizationReSynchronized(\n        address indexed stakingProvider,\n        uint96 fromAmount,\n        uint96 toAmount\n    );\n\n    /**\n     * @notice Signals that the staking provider was slashed\n     * @param stakingProvider Staking provider address\n     * @param penalty Slashing penalty\n     * @param investigator Investigator address\n     * @param reward Value of reward provided to investigator (in units of T)\n     */\n    event Slashed(\n        address indexed stakingProvider,\n        uint256 penalty,\n        address indexed investigator,\n        uint256 reward\n    );\n\n    /**\n     * @notice Signals that an operator was bonded to the staking provider\n     * @param stakingProvider Staking provider address\n     * @param operator Operator address\n     * @param previousOperator Previous operator address\n     * @param startTimestamp Timestamp bonding occurred\n     */\n    event OperatorBonded(\n        address indexed stakingProvider,\n        address indexed operator,\n        address indexed previousOperator,\n        uint256 startTimestamp\n    );\n\n    /**\n     * @notice Signals that a staking provider made a commitment\n     * @param stakingProvider Staking provider address\n     * @param endCommitment End of commitment\n     */\n    event CommitmentMade(address indexed stakingProvider, uint256 endCommitment);\n\n    struct StakingProviderInfo {\n        address operator;\n        bool operatorConfirmed;\n        uint64 operatorStartTimestamp;\n        uint96 authorized;\n        uint96 deauthorizing; // TODO real usage only in getActiveStakingProviders, maybe remove?\n        uint64 endDeauthorization;\n        uint96 tReward;\n        uint160 rewardPerTokenPaid;\n        uint64 endCommitment;\n    }\n\n    uint256 public constant REWARD_PER_TOKEN_MULTIPLIER = 10 ** 3;\n    uint256 internal constant FLOATING_POINT_DIVISOR = REWARD_PER_TOKEN_MULTIPLIER * 10 ** 18;\n\n    uint96 public immutable minimumAuthorization;\n    uint256 public immutable minOperatorSeconds;\n    uint256 public immutable rewardDuration;\n    uint256 public immutable deauthorizationDuration;\n\n    uint64 public immutable commitmentDurationOption1;\n    uint64 public immutable commitmentDurationOption2;\n    uint64 public immutable commitmentDurationOption3;\n    uint64 public immutable commitmentDurationOption4;\n    uint64 public immutable commitmentDeadline;\n\n    IStaking public immutable tStaking;\n    IERC20 public immutable token;\n\n    ITACoRootToChild public childApplication;\n    address public adjudicator;\n\n    mapping(address =\u003e StakingProviderInfo) public stakingProviderInfo;\n    address[] public stakingProviders;\n    mapping(address =\u003e address) internal _stakingProviderFromOperator;\n\n    address public rewardDistributor;\n    uint256 public periodFinish;\n    uint256 public rewardRateDecimals;\n    uint256 public lastUpdateTime;\n    uint160 public rewardPerTokenStored;\n    uint96 public authorizedOverall;\n\n    /**\n     * @notice Constructor sets address of token contract and parameters for staking\n     * @param _token T token contract\n     * @param _tStaking T token staking contract\n     * @param _minimumAuthorization Amount of minimum allowable authorization\n     * @param _minOperatorSeconds Min amount of seconds while an operator can\u0027t be changed\n     * @param _rewardDuration Duration of one reward cycle in seconds\n     * @param _deauthorizationDuration Duration of decreasing authorization in seconds\n     * @param _commitmentDurationOptions Options for commitment duration\n     * @param _commitmentDeadline Last date to make a commitment\n     */\n    constructor(\n        IERC20 _token,\n        IStaking _tStaking,\n        uint96 _minimumAuthorization,\n        uint256 _minOperatorSeconds,\n        uint256 _rewardDuration,\n        uint256 _deauthorizationDuration,\n        uint64[] memory _commitmentDurationOptions,\n        uint64 _commitmentDeadline\n    ) {\n        uint256 totalSupply = _token.totalSupply();\n        require(\n            _rewardDuration != 0 \u0026\u0026\n                _tStaking.authorizedStake(address(this), address(this)) == 0 \u0026\u0026\n                totalSupply \u003e 0 \u0026\u0026\n                _commitmentDurationOptions.length \u003e= 1 \u0026\u0026\n                _commitmentDurationOptions.length \u003c= 4,\n            \"Wrong input parameters\"\n        );\n        // This require is only to check potential overflow for 10% reward\n        require(\n            (totalSupply / 10) * FLOATING_POINT_DIVISOR \u003c= type(uint160).max \u0026\u0026\n                _minimumAuthorization \u003e= 10 ** 18 \u0026\u0026\n                _rewardDuration \u003e= 1 days,\n            \"Potential overflow\"\n        );\n        rewardDuration = _rewardDuration;\n        deauthorizationDuration = _deauthorizationDuration;\n        minimumAuthorization = _minimumAuthorization;\n        token = _token;\n        tStaking = _tStaking;\n        minOperatorSeconds = _minOperatorSeconds;\n        commitmentDurationOption1 = _commitmentDurationOptions[0];\n        commitmentDurationOption2 = _commitmentDurationOptions.length \u003e= 2\n            ? _commitmentDurationOptions[1]\n            : 0;\n        commitmentDurationOption3 = _commitmentDurationOptions.length \u003e= 3\n            ? _commitmentDurationOptions[2]\n            : 0;\n        commitmentDurationOption4 = _commitmentDurationOptions.length \u003e= 4\n            ? _commitmentDurationOptions[3]\n            : 0;\n        commitmentDeadline = _commitmentDeadline;\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Update reward for the specified staking provider\n     */\n    modifier updateReward(address _stakingProvider) {\n        updateRewardInternal(_stakingProvider);\n        _;\n    }\n\n    /**\n     * @dev Checks caller is T staking contract\n     */\n    modifier onlyStakingContract() {\n        require(msg.sender == address(tStaking), \"Caller must be the T staking contract\");\n        _;\n    }\n\n    /**\n     * @dev Checks caller is a staking provider or stake owner\n     */\n    modifier onlyOwnerOrStakingProvider(address _stakingProvider) {\n        require(isAuthorized(_stakingProvider), \"Not owner or provider\");\n        if (_stakingProvider != msg.sender) {\n            (address owner, , ) = tStaking.rolesOf(_stakingProvider);\n            require(owner == msg.sender, \"Not owner or provider\");\n        }\n        _;\n    }\n\n    /**\n     * @notice Initialize function for using with OpenZeppelin proxy\n     */\n    function initialize() external initializer {\n        __Ownable_init(msg.sender);\n    }\n\n    /**\n     * @notice Set contract for multi-chain interactions\n     */\n    function setChildApplication(ITACoRootToChild _childApplication) external onlyOwner {\n        require(address(childApplication) == address(0), \"Child application is already set\");\n        require(address(_childApplication).code.length \u003e 0, \"Child app must be contract\");\n        childApplication = _childApplication;\n    }\n\n    /**\n     * @notice Set adjudicator contract. If zero then slashing is disabled\n     */\n    function setAdjudicator(address _adjudicator) external onlyOwner {\n        require(\n            address(_adjudicator) != address(adjudicator),\n            \"New address must not be equal to the current one\"\n        );\n        adjudicator = _adjudicator;\n    }\n\n    /**\n     *  @notice Returns authorization-related parameters of the application.\n     *  @dev The minimum authorization is also returned by `minimumAuthorization()`\n     *       function, as a requirement of `IApplication` interface.\n     *  @return _minimumAuthorization The minimum authorization amount required\n     *          so that operator can participate in the application.\n     *  @return authorizationDecreaseDelay Delay in seconds that needs to pass\n     *          between the time authorization decrease is requested and the\n     *          time that request gets approved. Protects against free-riders\n     *          earning rewards and not being active in the network.\n     *  @return authorizationDecreaseChangePeriod Authorization decrease change\n     *         period in seconds. It is the time, before authorization decrease\n     *         delay end, during which the pending authorization decrease\n     *         request can be overwritten.\n     *         If set to 0, pending authorization decrease request can not be\n     *         overwritten until the entire `authorizationDecreaseDelay` ends.\n     *         If set to value equal `authorizationDecreaseDelay`, request can\n     *         always be overwritten.\n     */\n    function authorizationParameters()\n        external\n        view\n        override\n        returns (\n            uint96 _minimumAuthorization,\n            uint64 authorizationDecreaseDelay,\n            uint64 authorizationDecreaseChangePeriod\n        )\n    {\n        return (\n            minimumAuthorization,\n            uint64(deauthorizationDuration),\n            uint64(deauthorizationDuration)\n        );\n    }\n\n    //------------------------Reward------------------------------\n\n    /**\n     * @notice Set reward distributor address\n     */\n    function setRewardDistributor(address _rewardDistributor) external onlyOwner {\n        rewardDistributor = _rewardDistributor;\n        emit RewardDistributorSet(_rewardDistributor);\n    }\n\n    /**\n     * @notice Update reward for the specified staking provider\n     * @param _stakingProvider Staking provider address\n     */\n    function updateRewardInternal(address _stakingProvider) internal {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (_stakingProvider != address(0)) {\n            StakingProviderInfo storage info = stakingProviderInfo[_stakingProvider];\n            info.tReward = availableRewards(_stakingProvider);\n            info.rewardPerTokenPaid = rewardPerTokenStored;\n        }\n    }\n\n    /**\n     * @notice Returns last time when reward was applicable\n     */\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return Math.min(block.timestamp, periodFinish);\n    }\n\n    /**\n     * @notice Returns current value of reward per token * multiplier\n     */\n    function rewardPerToken() public view returns (uint160) {\n        if (authorizedOverall == 0) {\n            return rewardPerTokenStored;\n        }\n        uint256 result = rewardPerTokenStored +\n            ((lastTimeRewardApplicable() - lastUpdateTime) * rewardRateDecimals) /\n            authorizedOverall;\n        return result.toUint160();\n    }\n\n    /**\n     * @notice Returns amount of reward in T units for the staking provider\n     * @param _stakingProvider Staking provider address\n     */\n    function availableRewards(address _stakingProvider) public view returns (uint96) {\n        StakingProviderInfo storage info = stakingProviderInfo[_stakingProvider];\n        if (!info.operatorConfirmed) {\n            return info.tReward;\n        }\n        uint256 result = (uint256(info.authorized) * (rewardPerToken() - info.rewardPerTokenPaid)) /\n            FLOATING_POINT_DIVISOR +\n            info.tReward;\n        return result.toUint96();\n    }\n\n    /**\n     * @notice Transfer reward for the next period. Can be called only by distributor\n     * @param _reward Amount of reward\n     */\n    function pushReward(uint96 _reward) external updateReward(address(0)) {\n        require(msg.sender == rewardDistributor, \"Only distributor can push rewards\");\n        require(_reward \u003e 0, \"Reward must be specified\");\n        require(authorizedOverall \u003e 0, \"No active staking providers\");\n        if (block.timestamp \u003e= periodFinish) {\n            rewardRateDecimals = (uint256(_reward) * FLOATING_POINT_DIVISOR) / rewardDuration;\n        } else {\n            uint256 remaining = periodFinish - block.timestamp;\n            uint256 leftover = remaining * rewardRateDecimals;\n            rewardRateDecimals =\n                (uint256(_reward) * FLOATING_POINT_DIVISOR + leftover) /\n                rewardDuration;\n        }\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp + rewardDuration;\n        emit RewardAdded(_reward);\n        token.safeTransferFrom(msg.sender, address(this), _reward);\n    }\n\n    /**\n     * @notice Withdraw available amount of T reward to beneficiary. Can be called only by beneficiary\n     * @param _stakingProvider Staking provider address\n     */\n    function withdrawRewards(address _stakingProvider) external updateReward(_stakingProvider) {\n        address beneficiary = getBeneficiary(_stakingProvider);\n        require(msg.sender == beneficiary, \"Caller must be beneficiary\");\n\n        StakingProviderInfo storage info = stakingProviderInfo[_stakingProvider];\n        uint96 value = info.tReward;\n        require(value \u003e 0, \"No reward to withdraw\");\n        info.tReward = 0;\n        emit RewardPaid(_stakingProvider, beneficiary, value);\n        token.safeTransfer(beneficiary, value);\n    }\n\n    //------------------------Authorization------------------------------\n    /**\n     * @notice Recalculate `authorizedOverall` if desync happened\n     */\n    function resynchronizeAuthorizedOverall(\n        StakingProviderInfo storage _info,\n        uint96 _properAmount\n    ) internal {\n        if (_info.authorized != _properAmount) {\n            authorizedOverall -= _info.authorized - _properAmount;\n        }\n    }\n\n    /**\n     * @notice Recalculate reward and save increased authorization. Can be called only by staking contract\n     * @param _stakingProvider Address of staking provider\n     * @param _fromAmount Amount of previously authorized tokens to TACo application by staking provider\n     * @param _toAmount Amount of authorized tokens to TACo application by staking provider\n     */\n    function authorizationIncreased(\n        address _stakingProvider,\n        uint96 _fromAmount,\n        uint96 _toAmount\n    ) external override onlyStakingContract updateReward(_stakingProvider) {\n        require(\n            _stakingProvider != address(0) \u0026\u0026 _toAmount \u003e 0,\n            \"Input parameters must be specified\"\n        );\n        require(_toAmount \u003e= minimumAuthorization, \"Authorization must be greater than minimum\");\n\n        StakingProviderInfo storage info = stakingProviderInfo[_stakingProvider];\n        require(\n            _stakingProviderFromOperator[_stakingProvider] == address(0) ||\n                _stakingProviderFromOperator[_stakingProvider] == _stakingProvider,\n            \"A provider can\u0027t be an operator for another provider\"\n        );\n\n        if (info.operatorConfirmed) {\n            resynchronizeAuthorizedOverall(info, _fromAmount);\n            authorizedOverall += _toAmount - _fromAmount;\n        }\n\n        info.authorized = _toAmount;\n        emit AuthorizationIncreased(_stakingProvider, _fromAmount, _toAmount);\n        _updateAuthorization(_stakingProvider, info);\n    }\n\n    /**\n     * @notice Immediately decrease authorization. Can be called only by staking contract\n     * @param _stakingProvider Address of staking provider\n     * @param _fromAmount Previous amount of authorized tokens\n     * @param _toAmount Amount of authorized tokens to decrease\n     */\n    function involuntaryAuthorizationDecrease(\n        address _stakingProvider,\n        uint96 _fromAmount,\n        uint96 _toAmount\n    ) external override onlyStakingContract updateReward(_stakingProvider) {\n        StakingProviderInfo storage info = stakingProviderInfo[_stakingProvider];\n        if (info.operatorConfirmed) {\n            resynchronizeAuthorizedOverall(info, _fromAmount);\n            authorizedOverall -= _fromAmount - _toAmount;\n        }\n\n        info.authorized = _toAmount;\n        if (info.authorized \u003c info.deauthorizing) {\n            info.deauthorizing = info.authorized;\n        }\n        emit AuthorizationInvoluntaryDecreased(_stakingProvider, _fromAmount, _toAmount);\n\n        if (info.authorized == 0) {\n            _releaseOperator(_stakingProvider);\n        }\n        _updateAuthorization(_stakingProvider, info);\n    }\n\n    /**\n     * @notice Register request of decreasing authorization. Can be called only by staking contract\n     * @param _stakingProvider Address of staking provider\n     * @param _fromAmount Current amount of authorized tokens\n     * @param _toAmount Amount of authorized tokens to decrease\n     */\n    function authorizationDecreaseRequested(\n        address _stakingProvider,\n        uint96 _fromAmount,\n        uint96 _toAmount\n    ) external override onlyStakingContract updateReward(_stakingProvider) {\n        StakingProviderInfo storage info = stakingProviderInfo[_stakingProvider];\n        require(_toAmount \u003c= info.authorized, \"Amount to decrease greater than authorized\");\n        require(\n            _toAmount == 0 || _toAmount \u003e= minimumAuthorization,\n            \"Resulting authorization will be less than minimum\"\n        );\n        require(\n            info.endCommitment \u003c= block.timestamp,\n            \"Can\u0027t request deauthorization before end of commitment\"\n        );\n        if (info.operatorConfirmed) {\n            resynchronizeAuthorizedOverall(info, _fromAmount);\n        }\n\n        info.authorized = _fromAmount;\n        info.deauthorizing = _fromAmount - _toAmount;\n        info.endDeauthorization = uint64(block.timestamp + deauthorizationDuration);\n        emit AuthorizationDecreaseRequested(_stakingProvider, _fromAmount, _toAmount);\n        _updateAuthorization(_stakingProvider, info);\n    }\n\n    /**\n     * @notice Approve request of decreasing authorization. Can be called by anyone\n     * @param _stakingProvider Address of staking provider\n     */\n    function approveAuthorizationDecrease(\n        address _stakingProvider\n    ) external updateReward(_stakingProvider) {\n        StakingProviderInfo storage info = stakingProviderInfo[_stakingProvider];\n        require(info.deauthorizing \u003e 0, \"There is no deauthorizing in process\");\n        require(\n            info.endDeauthorization \u003c= block.timestamp,\n            \"Authorization decrease has not finished yet\"\n        );\n\n        uint96 toAmount = tStaking.approveAuthorizationDecrease(_stakingProvider);\n\n        if (info.operatorConfirmed) {\n            authorizedOverall -= info.authorized - toAmount;\n        }\n\n        emit AuthorizationDecreaseApproved(_stakingProvider, info.authorized, toAmount);\n        info.authorized = toAmount;\n        info.deauthorizing = 0;\n        info.endDeauthorization = 0;\n\n        if (info.authorized == 0) {\n            _releaseOperator(_stakingProvider);\n        }\n        _updateAuthorization(_stakingProvider, info);\n    }\n\n    /**\n     * @notice Read authorization from staking contract and store it. Can be called by anyone\n     * @param _stakingProvider Address of staking provider\n     */\n    function resynchronizeAuthorization(\n        address _stakingProvider\n    ) external updateReward(_stakingProvider) {\n        StakingProviderInfo storage info = stakingProviderInfo[_stakingProvider];\n        uint96 newAuthorized = tStaking.authorizedStake(_stakingProvider, address(this));\n        require(info.authorized \u003e newAuthorized, \"Nothing to synchronize\");\n\n        if (info.operatorConfirmed) {\n            authorizedOverall -= info.authorized - newAuthorized;\n        }\n        emit AuthorizationReSynchronized(_stakingProvider, info.authorized, newAuthorized);\n\n        info.authorized = newAuthorized;\n        if (info.authorized \u003c info.deauthorizing) {\n            info.deauthorizing = info.authorized;\n        }\n\n        if (info.authorized == 0) {\n            _releaseOperator(_stakingProvider);\n        }\n        _updateAuthorization(_stakingProvider, info);\n    }\n\n    /**\n     * @notice Make a commitment to not request authorization decrease for specified duration\n     * @param _stakingProvider Staking provider address\n     * @param _commitmentDuration Duration of commitment\n     */\n    function makeCommitment(\n        address _stakingProvider,\n        uint64 _commitmentDuration\n    ) external onlyOwnerOrStakingProvider(_stakingProvider) {\n        require(block.timestamp \u003c commitmentDeadline, \"Commitment window closed\");\n        require(\n            _commitmentDuration \u003e 0 \u0026\u0026\n                (_commitmentDuration == commitmentDurationOption1 ||\n                    _commitmentDuration == commitmentDurationOption2 ||\n                    _commitmentDuration == commitmentDurationOption3 ||\n                    _commitmentDuration == commitmentDurationOption4),\n            \"Commitment duration must be equal to one of options\"\n        );\n        StakingProviderInfo storage info = stakingProviderInfo[_stakingProvider];\n        require(info.endDeauthorization == 0, \"Commitment can\u0027t be made during deauthorization\");\n        require(info.endCommitment == 0, \"Commitment already made\");\n        info.endCommitment = uint64(block.timestamp) + _commitmentDuration;\n        emit CommitmentMade(_stakingProvider, info.endCommitment);\n    }\n\n    //-------------------------Main-------------------------\n    /**\n     * @notice Returns staking provider for specified operator\n     */\n    function operatorToStakingProvider(address _operator) external view returns (address) {\n        return _stakingProviderFromOperator[_operator];\n    }\n\n    /**\n     * @notice Returns operator for specified staking provider\n     */\n    function stakingProviderToOperator(address _stakingProvider) external view returns (address) {\n        return stakingProviderInfo[_stakingProvider].operator;\n    }\n\n    /**\n     * @notice Get all tokens delegated to the staking provider\n     */\n    function authorizedStake(address _stakingProvider) external view returns (uint96) {\n        return stakingProviderInfo[_stakingProvider].authorized;\n    }\n\n    /**\n     * @notice Get all tokens delegated to the staking provider\n     */\n    function getEligibleAmount(StakingProviderInfo storage _info) internal view returns (uint96) {\n        return _info.authorized - _info.deauthorizing;\n    }\n\n    /**\n     * @notice Returns the amount of stake that is pending authorization\n     *         decrease for the given staking provider. If no authorization\n     *         decrease has been requested, returns zero.\n     */\n    function pendingAuthorizationDecrease(\n        address _stakingProvider\n    ) external view override returns (uint96) {\n        return stakingProviderInfo[_stakingProvider].deauthorizing;\n    }\n\n    /**\n     * @notice Returns the remaining time in seconds that needs to pass before\n     *         the requested authorization decrease can be approved.\n     */\n    function remainingAuthorizationDecreaseDelay(\n        address _stakingProvider\n    ) external view override returns (uint64) {\n        uint256 endDeauthorization = stakingProviderInfo[_stakingProvider].endDeauthorization;\n        if (endDeauthorization \u003c= block.timestamp) {\n            return 0;\n        }\n        return uint64(endDeauthorization - block.timestamp);\n    }\n\n    /**\n     * @notice Get the value of authorized tokens for active providers as well as providers and their authorized tokens\n     * @param _startIndex Start index for looking in providers array\n     * @param _maxStakingProviders Max providers for looking, if set 0 then all will be used\n     * @return allAuthorizedTokens Sum of authorized tokens for active providers\n     * @return activeStakingProviders Array of providers and their authorized tokens.\n     * Providers addresses stored together with amounts as bytes32\n     * @dev Note that activeStakingProviders is an array of bytes32, but you want addresses and amounts.\n     * Careful when used directly!\n     */\n    function getActiveStakingProviders(\n        uint256 _startIndex,\n        uint256 _maxStakingProviders\n    ) external view returns (uint256 allAuthorizedTokens, bytes32[] memory activeStakingProviders) {\n        uint256 endIndex = stakingProviders.length;\n        require(_startIndex \u003c endIndex, \"Wrong start index\");\n        if (_maxStakingProviders != 0 \u0026\u0026 _startIndex + _maxStakingProviders \u003c endIndex) {\n            endIndex = _startIndex + _maxStakingProviders;\n        }\n        activeStakingProviders = new bytes32[](endIndex - _startIndex);\n        allAuthorizedTokens = 0;\n\n        uint256 resultIndex = 0;\n        for (uint256 i = _startIndex; i \u003c endIndex; i++) {\n            address stakingProvider = stakingProviders[i];\n            StakingProviderInfo storage info = stakingProviderInfo[stakingProvider];\n            uint256 eligibleAmount = getEligibleAmount(info);\n            if (eligibleAmount \u003c minimumAuthorization || !info.operatorConfirmed) {\n                continue;\n            }\n            // bytes20 -\u003e bytes32 adds padding after address: \u003caddress\u003e\u003c12 zeros\u003e\n            // uint96 -\u003e uint256 adds padding before uint96: \u003c20 zeros\u003e\u003camount\u003e\n            activeStakingProviders[resultIndex++] =\n                bytes32(bytes20(stakingProvider)) |\n                bytes32(uint256(eligibleAmount));\n            allAuthorizedTokens += eligibleAmount;\n        }\n        assembly {\n            mstore(activeStakingProviders, resultIndex)\n        }\n    }\n\n    /**\n     * @notice Returns beneficiary related to the staking provider\n     */\n    function getBeneficiary(\n        address _stakingProvider\n    ) public view returns (address payable beneficiary) {\n        (, beneficiary, ) = tStaking.rolesOf(_stakingProvider);\n    }\n\n    /**\n     * @notice Returns true if staking provider has authorized stake to this application\n     */\n    function isAuthorized(address _stakingProvider) public view returns (bool) {\n        return stakingProviderInfo[_stakingProvider].authorized \u003e 0;\n    }\n\n    /**\n     * @notice Returns true if operator has confirmed address\n     */\n    // TODO maybe _stakingProvider instead of _operator as input?\n    function isOperatorConfirmed(address _operator) public view returns (bool) {\n        address stakingProvider = _stakingProviderFromOperator[_operator];\n        StakingProviderInfo storage info = stakingProviderInfo[stakingProvider];\n        return info.operatorConfirmed;\n    }\n\n    /**\n     * @notice Return the length of the array of staking providers\n     */\n    function getStakingProvidersLength() external view returns (uint256) {\n        return stakingProviders.length;\n    }\n\n    /**\n     *  @notice Used by staking provider to set operator address that will\n     *          operate a node. The operator address must be unique.\n     *          Reverts if the operator is already set for the staking provider\n     *          or if the operator address is already in use.\n     */\n    function registerOperator(address _operator) external override {\n        bondOperator(msg.sender, _operator);\n    }\n\n    /**\n     * @notice Bond operator\n     * @param _stakingProvider Staking provider address\n     * @param _operator Operator address. Must be an EOA, not a contract address\n     */\n    function bondOperator(\n        address _stakingProvider,\n        address _operator\n    ) public onlyOwnerOrStakingProvider(_stakingProvider) updateReward(_stakingProvider) {\n        StakingProviderInfo storage info = stakingProviderInfo[_stakingProvider];\n        address previousOperator = info.operator;\n        require(\n            _operator != previousOperator,\n            \"Specified operator is already bonded with this provider\"\n        );\n        // If this staker had a operator ...\n        if (previousOperator != address(0)) {\n            require(\n                !info.operatorConfirmed ||\n                    block.timestamp \u003e= uint256(info.operatorStartTimestamp) + minOperatorSeconds,\n                \"Not enough time passed to change operator\"\n            );\n            // Remove the old relation \"operator-\u003estakingProvider\"\n            _stakingProviderFromOperator[previousOperator] = address(0);\n        }\n\n        if (_operator != address(0)) {\n            require(\n                _stakingProviderFromOperator[_operator] == address(0),\n                \"Specified operator is already in use\"\n            );\n            require(\n                _operator == _stakingProvider || getBeneficiary(_operator) == address(0),\n                \"Specified operator is a provider\"\n            );\n            // Set new operator-\u003estakingProvider relation\n            _stakingProviderFromOperator[_operator] = _stakingProvider;\n        }\n\n        if (info.operatorStartTimestamp == 0) {\n            stakingProviders.push(_stakingProvider);\n        }\n\n        if (info.operatorConfirmed) {\n            authorizedOverall -= info.authorized;\n        }\n\n        // Bond new operator (or unbond if _operator == address(0))\n        info.operator = _operator;\n        info.operatorStartTimestamp = uint64(block.timestamp);\n        emit OperatorBonded(_stakingProvider, _operator, previousOperator, block.timestamp);\n\n        info.operatorConfirmed = false;\n        childApplication.updateOperator(_stakingProvider, _operator);\n    }\n\n    /**\n     * @notice Make a confirmation by operator\n     */\n    function confirmOperatorAddress(address _operator) external override {\n        require(\n            msg.sender == address(childApplication),\n            \"Only child application allowed to confirm operator\"\n        );\n        address stakingProvider = _stakingProviderFromOperator[_operator];\n        // TODO only in case of desync, maybe just exit?\n        // require(stakingProvider != address(0), \"Operator has no bond with staking provider\");\n        if (stakingProvider == address(0)) {\n            return;\n        }\n\n        StakingProviderInfo storage info = stakingProviderInfo[stakingProvider];\n        if (!info.operatorConfirmed) {\n            updateRewardInternal(stakingProvider);\n            info.operatorConfirmed = true;\n            authorizedOverall += info.authorized;\n            emit OperatorConfirmed(stakingProvider, _operator);\n        }\n    }\n\n    //-------------------------XChain-------------------------\n\n    /**\n     * @notice Resets operator confirmation\n     */\n    function _releaseOperator(address _stakingProvider) internal {\n        StakingProviderInfo storage info = stakingProviderInfo[_stakingProvider];\n        _stakingProviderFromOperator[info.operator] = address(0);\n        info.operator = address(0);\n        info.operatorConfirmed = false;\n        info.endDeauthorization = 0;\n        info.endCommitment = 0;\n        childApplication.updateOperator(_stakingProvider, address(0));\n    }\n\n    /**\n     * @notice Send updated authorized amount to xchain contract\n     */\n    function _updateAuthorization(\n        address _stakingProvider,\n        StakingProviderInfo storage _info\n    ) internal {\n        // TODO send both authorized and eligible amounts in case of slashing from child app\n        uint96 eligibleAmount = getEligibleAmount(_info);\n        childApplication.updateAuthorization(_stakingProvider, eligibleAmount);\n    }\n\n    //-------------------------Slashing-------------------------\n    /**\n     * @notice Slash the provider\u0027s stake and reward the investigator\n     * @param _stakingProvider Staking provider address\n     * @param _penalty Penalty\n     * @param _investigator Investigator\n     */\n    function slash(address _stakingProvider, uint96 _penalty, address _investigator) external {\n        require(msg.sender == adjudicator, \"Only adjudicator allowed to slash\");\n        address[] memory stakingProviderWrapper = new address[](1);\n        stakingProviderWrapper[0] = _stakingProvider;\n        tStaking.seize(_penalty, 100, _investigator, stakingProviderWrapper);\n    }\n}\n"}}