{"IDelegationManagementContract.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.18;\r\n\r\n/**\r\n * @dev Interface module which provides a basic access control mechanism of the NFT Delegation Smart Contract\r\n */\r\n\r\ninterface IDelegationManagementContract {\r\n    \r\n    /**\r\n     * @notice Returns an array of all delegation addresses (active AND inactive) assigned by a delegator for a specific use case on a specific NFT collection\r\n     */\r\n\r\n    function retrieveDelegationAddresses(address _delegatorAddress, address _collectionAddress, uint256 _useCase) external view returns (address[] memory);\r\n    \r\n    /**\r\n     * @notice Returns an array of all delegators (active AND inactive) that delegated to a delegationAddress for a specific use case on a specific NFT collection\r\n     */\r\n\r\n     function retrieveDelegators(address _delegationAddress, address _collectionAddress, uint256 _useCase) external view returns (address[] memory);\r\n\r\n    /**\r\n     * @notice Returns an array of all active delegators on a certain date for a specific use case on a specific NFT collection given a delegation Address\r\n    */\r\n\r\n     function retrieveActiveDelegators(address _delegationAddress, address _collectionAddress, uint256 _date, uint256 _useCase) external view returns (address[] memory);\r\n\r\n     /**\r\n     * @notice Returns the most recent delegation address delegated for a specific use case on a specific NFT collection\r\n     */\r\n\r\n    function retrieveMostRecentDelegation(address _delegatorAddress, address _collectionAddress, uint256 _useCase) external view returns (address);\r\n\r\n    /**\r\n     * @notice Returns the most recent delegator for a specific use case on a specific NFT collection given a delegation Address\r\n     */\r\n\r\n    function retrieveMostRecentDelegator(address _delegationAddress, address _collectionAddress, uint256 _useCase) external view returns (address);\r\n\r\n    /**\r\n     * @notice Returns the status of a delegation given the delegator address as well as the delegation address\r\n     */\r\n\r\n    function retrieveGlobalStatusOfDelegation(address _delegatorAddress, address _collectionAddress, address _delegationAddress, uint256 _useCase) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Returns the status of a delegation given the delegator address, the collection address, the delegation address as well as a specific token id\r\n     */\r\n\r\n    function retrieveTokenStatus(address _delegatorAddress, address _collectionAddress, address _delegationAddress, uint256 _useCase, uint256 _tokenId) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Checks if the delegation address performing actions is the most recent delegated by the specific delegator\r\n     */\r\n\r\n    function retrieveStatusOfMostRecentDelegation(address _delegatorAddress, address _collectionAddress, address _delegationAddress, uint256 _useCase) external view returns (bool);\r\n\r\n     /**\r\n     * @notice Checks if a delegator granted subdelegation status to an Address\r\n     */\r\n\r\n    function retrieveSubDelegationStatus(address _delegatorAddress, address _collectionAddress, address _delegationAddress) external view returns (bool);\r\n\r\n     /**\r\n     * @notice Checks the status of an active delegator for a delegation Address\r\n     */\r\n\r\n    function retrieveStatusOfActiveDelegator(address _delegatorAddress, address _collectionAddress, address _delegationAddress, uint256 _date, uint256 _useCase) external view returns (bool);\r\n\r\n    /**\r\n     * @notice This function checks the Consolidation status between 2 addresses\r\n     */\r\n\r\n    function checkConsolidationStatus(address _wallet1, address _wallet2, address _collectionAddress) external view returns (bool);\r\n\r\n}"},"IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}"},"IERC721.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\n\r\nimport \"./IERC165.sol\";\r\n\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``\u0027s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\r\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\r\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n}"},"INextGenAdmins.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.19;\r\n\r\ninterface INextGenAdmins {\r\n\r\n    // retrieve global admin\r\n    function retrieveGlobalAdmin(address _address) external view returns(bool);\r\n\r\n    // retrieve function admin\r\n    function retrieveFunctionAdmin(address _address, bytes4 _selector) external view returns(bool);\r\n\r\n    // retrieve collection admin\r\n    function retrieveCollectionAdmin(address _address, uint256 _collectionID) external view returns(bool);\r\n\r\n    // retrieve if the contract is admin contract\r\n    function isAdminContract() external view returns (bool);\r\n\r\n    // retrieve owner\r\n    function owner() external view returns (address);\r\n\r\n}"},"INextGenCore.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.19;\r\n\r\ninterface INextGenCore {\r\n\r\n    function retrievewereDataAdded(uint256 _collectionID) external view returns(bool);\r\n\r\n    function viewTokensIndexMin(uint256 _collectionID) external view returns (uint256);\r\n\r\n    function viewTokensIndexMax(uint256 _collectionID) external view returns (uint256);\r\n\r\n    function viewCirSupply(uint256 _collectionID) external view returns (uint256);\r\n\r\n    function airDropTokens(uint256 mintIndex, address _recipient, string memory _tokenData, uint256 _saltfun_o, uint256 _collectionID) external;\r\n\r\n    function mint(uint256 mintIndex, address _mintingAddress , address _mintTo, string memory _tokenData, uint256 _saltfun_o, uint256 _collectionID, uint256 phase) external;\r\n\r\n    function collectionFreezeStatus(uint256 _collectionID) external view returns(bool);\r\n\r\n    function viewMaxAllowance(uint256 _collectionID) external view returns (uint256);\r\n\r\n    function retrieveTokensMintedALPerAddress(uint256 _collectionID, address _address) external view returns(uint256);\r\n\r\n    function retrieveTokensMintedPublicPerAddress(uint256 _collectionID, address _address) external view returns(uint256);\r\n\r\n    function viewColIDforTokenID(uint256 _tokenid) external view returns (uint256);\r\n\r\n    function burnToMint(uint256 mintIndex, uint256 _burnCollectionID, uint256 _tokenId, uint256 _mintCollectionID, uint256 _saltfun_o, address burner) external;\r\n\r\n    function retrieveArtistAddress(uint256 _collectionID) external view returns(address);\r\n\r\n    function setTokenHash(uint256 _collectionID, uint256 _mintIndex, bytes32 _hash) external;\r\n\r\n    function retrieveTokenHash(uint256 _tokenid) external view returns(bytes32);\r\n\r\n}"},"MerkleProof.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/MerkleProof.sol)\r\n\r\npragma solidity ^0.8.18;\r\n\r\n/**\r\n * @dev These functions deal with verification of Merkle Tree proofs.\r\n *\r\n * The tree and the proofs can be generated using our\r\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\r\n * You will find a quickstart guide in the readme.\r\n *\r\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\r\n * hashing, or use a hash function other than keccak256 for hashing leaves.\r\n * This is because the concatenation of a sorted pair of internal nodes in\r\n * the merkle tree could be reinterpreted as a leaf value.\r\n * OpenZeppelin\u0027s JavaScript library generates merkle trees that are safe\r\n * against this attack out of the box.\r\n */\r\nlibrary MerkleProof {\r\n    /**\r\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\r\n     * defined by `root`. For this, a `proof` must be provided, containing\r\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\r\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\r\n     */\r\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\r\n        return processProof(proof, leaf) == root;\r\n    }\r\n\r\n    /**\r\n     * @dev Calldata version of {verify}\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\r\n        return processProofCalldata(proof, leaf) == root;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\r\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\r\n     * hash matches the root of the tree. When processing the proof, the pairs\r\n     * of leafs \u0026 pre-images are assumed to be sorted.\r\n     *\r\n     * _Available since v4.4._\r\n     */\r\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\r\n        bytes32 computedHash = leaf;\r\n        for (uint256 i = 0; i \u003c proof.length; i++) {\r\n            computedHash = _hashPair(computedHash, proof[i]);\r\n        }\r\n        return computedHash;\r\n    }\r\n\r\n    /**\r\n     * @dev Calldata version of {processProof}\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\r\n        bytes32 computedHash = leaf;\r\n        for (uint256 i = 0; i \u003c proof.length; i++) {\r\n            computedHash = _hashPair(computedHash, proof[i]);\r\n        }\r\n        return computedHash;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\r\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\r\n     *\r\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function multiProofVerify(\r\n        bytes32[] memory proof,\r\n        bool[] memory proofFlags,\r\n        bytes32 root,\r\n        bytes32[] memory leaves\r\n    ) internal pure returns (bool) {\r\n        return processMultiProof(proof, proofFlags, leaves) == root;\r\n    }\r\n\r\n    /**\r\n     * @dev Calldata version of {multiProofVerify}\r\n     *\r\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function multiProofVerifyCalldata(\r\n        bytes32[] calldata proof,\r\n        bool[] calldata proofFlags,\r\n        bytes32 root,\r\n        bytes32[] memory leaves\r\n    ) internal pure returns (bool) {\r\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\r\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\r\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\r\n     * respectively.\r\n     *\r\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\r\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\r\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function processMultiProof(\r\n        bytes32[] memory proof,\r\n        bool[] memory proofFlags,\r\n        bytes32[] memory leaves\r\n    ) internal pure returns (bytes32 merkleRoot) {\r\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\r\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\r\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\r\n        // the merkle tree.\r\n        uint256 leavesLen = leaves.length;\r\n        uint256 totalHashes = proofFlags.length;\r\n\r\n        // Check proof validity.\r\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\r\n\r\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\r\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\u0027s \"pop\".\r\n        bytes32[] memory hashes = new bytes32[](totalHashes);\r\n        uint256 leafPos = 0;\r\n        uint256 hashPos = 0;\r\n        uint256 proofPos = 0;\r\n        // At each step, we compute the next hash using two values:\r\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\r\n        //   get the next hash.\r\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\r\n        //   `proof` array.\r\n        for (uint256 i = 0; i \u003c totalHashes; i++) {\r\n            bytes32 a = leafPos \u003c leavesLen ? leaves[leafPos++] : hashes[hashPos++];\r\n            bytes32 b = proofFlags[i]\r\n                ? (leafPos \u003c leavesLen ? leaves[leafPos++] : hashes[hashPos++])\r\n                : proof[proofPos++];\r\n            hashes[i] = _hashPair(a, b);\r\n        }\r\n\r\n        if (totalHashes \u003e 0) {\r\n            unchecked {\r\n                return hashes[totalHashes - 1];\r\n            }\r\n        } else if (leavesLen \u003e 0) {\r\n            return leaves[0];\r\n        } else {\r\n            return proof[0];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Calldata version of {processMultiProof}.\r\n     *\r\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function processMultiProofCalldata(\r\n        bytes32[] calldata proof,\r\n        bool[] calldata proofFlags,\r\n        bytes32[] memory leaves\r\n    ) internal pure returns (bytes32 merkleRoot) {\r\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\r\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\r\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\r\n        // the merkle tree.\r\n        uint256 leavesLen = leaves.length;\r\n        uint256 totalHashes = proofFlags.length;\r\n\r\n        // Check proof validity.\r\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\r\n\r\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\r\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\u0027s \"pop\".\r\n        bytes32[] memory hashes = new bytes32[](totalHashes);\r\n        uint256 leafPos = 0;\r\n        uint256 hashPos = 0;\r\n        uint256 proofPos = 0;\r\n        // At each step, we compute the next hash using two values:\r\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\r\n        //   get the next hash.\r\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\r\n        //   `proof` array.\r\n        for (uint256 i = 0; i \u003c totalHashes; i++) {\r\n            bytes32 a = leafPos \u003c leavesLen ? leaves[leafPos++] : hashes[hashPos++];\r\n            bytes32 b = proofFlags[i]\r\n                ? (leafPos \u003c leavesLen ? leaves[leafPos++] : hashes[hashPos++])\r\n                : proof[proofPos++];\r\n            hashes[i] = _hashPair(a, b);\r\n        }\r\n\r\n        if (totalHashes \u003e 0) {\r\n            unchecked {\r\n                return hashes[totalHashes - 1];\r\n            }\r\n        } else if (leavesLen \u003e 0) {\r\n            return leaves[0];\r\n        } else {\r\n            return proof[0];\r\n        }\r\n    }\r\n\r\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\r\n        return a \u003c b ? _efficientHash(a, b) : _efficientHash(b, a);\r\n    }\r\n\r\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x00, a)\r\n            mstore(0x20, b)\r\n            value := keccak256(0x00, 0x40)\r\n        }\r\n    }\r\n}"},"MinterContract.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\n/**\r\n *\r\n *  @title: NextGen 6529 - Minter Contract\r\n *  @date: 20-December-2023\r\n *  @version: 1.10\r\n *  @author: 6529 team\r\n */\r\n\r\npragma solidity ^0.8.19;\r\n\r\nimport \"./INextGenCore.sol\";\r\nimport \"./IDelegationManagementContract.sol\";\r\nimport \"./MerkleProof.sol\";\r\nimport \"./INextGenAdmins.sol\";\r\nimport \"./IERC721.sol\";\r\n\r\ncontract NextGenMinterContract {\r\n\r\n    // total funds collected during minting per collection\r\n    mapping (uint256 =\u003e uint256) public collectionTotalAmount;\r\n\r\n    // timestamp of last mint for used in sales model 3\r\n    mapping (uint256 =\u003e uint) public lastMintDate;\r\n\r\n    // tokens airdropped per collection\r\n    mapping (uint256 =\u003e uint256) public excludeTokensCounter;\r\n\r\n    // burn or swap address during burnOrSwap functionality\r\n    mapping (bytes32 =\u003e address) public burnOrSwapAddress;\r\n\r\n    // token ids set during burnOrSwap functionality\r\n    mapping (bytes32 =\u003e uint256[2]) private burnOrSwapIds;\r\n\r\n    // burnToMint initialization --\u003e burn a token on a NextGen collection and mint a token on a new NextGen collection\r\n    mapping (uint256 =\u003e mapping (uint256 =\u003e bool)) public burnToMintCollections;\r\n\r\n    // burnOrSwap initialization --\u003e burn a token on an external ERC721 collection and mint a token on a NextGen collection\r\n    mapping (bytes32 =\u003e mapping (uint256 =\u003e bool)) public burnExternalToMintCollections;\r\n\r\n    // checks if minting costs for a collectionwere set\r\n    mapping (uint256 =\u003e bool) private setMintingCosts;\r\n\r\n    // struct that holds minting costs and phases\r\n    struct collectionPhasesDataStructure {\r\n        uint allowlistStartTime;\r\n        uint allowlistEndTime;\r\n        uint publicStartTime;\r\n        uint publicEndTime;\r\n        bytes32 merkleRoot;\r\n        uint256 collectionMintCost;\r\n        uint256 collectionEndMintCost;\r\n        uint256 timePeriod;\r\n        uint256 rate;\r\n        uint8 salesOption;\r\n        address delAddress;\r\n    }\r\n\r\n    // mapping of collectionPhasesData struct\r\n    mapping (uint256 =\u003e collectionPhasesDataStructure) private collectionPhases;\r\n\r\n    // struct that holds primary royalties\r\n    struct royaltiesPrimarySplits {\r\n        uint256 artistPercentage;\r\n        uint256 teamPercentage;\r\n    }\r\n\r\n    // mapping of royaltiesPrimarySplits struct\r\n    mapping (uint256 =\u003e royaltiesPrimarySplits) private collectionRoyaltiesPrimarySplits;\r\n\r\n    // struct that holds addresses and percentages for primary splits\r\n    struct collectionPrimaryAddresses {\r\n        address primaryAdd1;\r\n        address primaryAdd2;\r\n        address primaryAdd3;\r\n        uint256 add1Percentage;\r\n        uint256 add2Percentage;\r\n        uint256 add3Percentage;\r\n        bool setStatus;\r\n        bool approvedStatus;\r\n    }\r\n\r\n    // mapping of collectionPrimaryAndSecondaryAddresses struct\r\n    mapping (uint256 =\u003e collectionPrimaryAddresses) private collectionArtistPrimaryAddresses;\r\n\r\n    // struct that holds secondary royalties\r\n    struct royaltiesSecondarySplits {\r\n        uint256 artistPercentage;\r\n        uint256 teamPercentage;\r\n    }\r\n\r\n    // mapping of royaltiesSecondarySplits struct\r\n\r\n    mapping (uint256 =\u003e royaltiesSecondarySplits) private collectionRoyaltiesSecondarySplits;\r\n\r\n    // struct that holds addresses and percentages for secondary splits\r\n    struct collectionSecondaryAddresses {\r\n        address secondaryAdd1;\r\n        address secondaryAdd2;\r\n        address secondaryAdd3;\r\n        uint256 add1Percentage;\r\n        uint256 add2Percentage;\r\n        uint256 add3Percentage;\r\n        bool setStatus;\r\n        bool approvedStatus;\r\n    }\r\n\r\n    // mapping of collectionSecondaryAddresses struct\r\n    mapping (uint256 =\u003e collectionSecondaryAddresses) private collectionArtistSecondaryAddresses;\r\n\r\n    // mapping that holds the auction end time when a token is sent to auction\r\n    mapping (uint256 =\u003e uint) private mintToAuctionData;\r\n\r\n    // mapping that holds the auction status when a token is sent to auction\r\n    mapping (uint256 =\u003e bool) private mintToAuctionStatus;\r\n\r\n    //external contracts declaration\r\n    INextGenCore public gencore;\r\n    IDelegationManagementContract public dmc;\r\n    INextGenAdmins private adminsContract;\r\n\r\n    // events\r\n    event Withdraw(address indexed _add, bool status, uint256 indexed funds);\r\n\r\n    // constructor\r\n    constructor (address _gencore, address _del, address _adminsContract) {\r\n        gencore = INextGenCore(_gencore);\r\n        dmc = IDelegationManagementContract(_del);\r\n        adminsContract = INextGenAdmins(_adminsContract);\r\n    }\r\n\r\n    // certain functions can only be called by an admin or the artist\r\n\r\n    modifier ArtistOrAdminRequired(uint256 _collectionID, bytes4 _selector) {\r\n      require(msg.sender == gencore.retrieveArtistAddress(_collectionID) || adminsContract.retrieveFunctionAdmin(msg.sender, _selector) == true || adminsContract.retrieveGlobalAdmin(msg.sender) == true, \"Not allowed\");\r\n      _;\r\n    }\r\n\r\n    // certain functions can only be called by a global or function admin\r\n\r\n    modifier FunctionAdminRequired(bytes4 _selector) {\r\n      require(adminsContract.retrieveFunctionAdmin(msg.sender, _selector) == true || adminsContract.retrieveGlobalAdmin(msg.sender) == true , \"Not allowed\");\r\n      _;\r\n    }\r\n\r\n    // certain functions can only be called by a collection, global or function admin\r\n\r\n    modifier CollectionAdminRequired(uint256 _collectionID, bytes4 _selector) {\r\n      require(adminsContract.retrieveCollectionAdmin(msg.sender,_collectionID) == true || adminsContract.retrieveFunctionAdmin(msg.sender, _selector) == true || adminsContract.retrieveGlobalAdmin(msg.sender) == true, \"Not allowed\");\r\n      _;\r\n    }\r\n\r\n    // function to add a collection\u0027s minting costs\r\n\r\n    function setCollectionCosts(uint256 _collectionID, uint256 _collectionMintCost, uint256 _collectionEndMintCost, uint256 _rate, uint256 _timePeriod, uint8 _salesOption, address _delAddress) public CollectionAdminRequired(_collectionID, this.setCollectionCosts.selector) {\r\n        require(gencore.retrievewereDataAdded(_collectionID) == true, \"Add data\");\r\n        collectionPhases[_collectionID].collectionMintCost = _collectionMintCost;\r\n        collectionPhases[_collectionID].collectionEndMintCost = _collectionEndMintCost;\r\n        collectionPhases[_collectionID].rate = _rate;\r\n        collectionPhases[_collectionID].timePeriod = _timePeriod;\r\n        collectionPhases[_collectionID].salesOption = _salesOption;\r\n        collectionPhases[_collectionID].delAddress = _delAddress;\r\n        setMintingCosts[_collectionID] = true;\r\n    }\r\n\r\n    // function to add a collection\u0027s minting phases and merkleroot\r\n\r\n    function setCollectionPhases(uint256 _collectionID, uint _allowlistStartTime, uint _allowlistEndTime, uint _publicStartTime, uint _publicEndTime, bytes32 _merkleRoot) public CollectionAdminRequired(_collectionID, this.setCollectionPhases.selector) {\r\n        require(setMintingCosts[_collectionID] == true, \"Set Costs\");\r\n        collectionPhases[_collectionID].allowlistStartTime = _allowlistStartTime;\r\n        collectionPhases[_collectionID].allowlistEndTime = _allowlistEndTime;\r\n        collectionPhases[_collectionID].merkleRoot = _merkleRoot;\r\n        collectionPhases[_collectionID].publicStartTime = _publicStartTime;\r\n        collectionPhases[_collectionID].publicEndTime = _publicEndTime;\r\n    }\r\n\r\n    // airdrop function\r\n    \r\n    function airDropTokens(address[] memory _recipients, string[] memory _tokenData, uint256[] memory _saltfun_o, uint256 _collectionID, uint256[] memory _numberOfTokens) public FunctionAdminRequired(this.airDropTokens.selector) {\r\n        require(gencore.retrievewereDataAdded(_collectionID) == true, \"Add data\");\r\n        uint256 collectionTokenMintIndex;\r\n        for (uint256 y=0; y\u003c _recipients.length; y++) {\r\n            collectionTokenMintIndex = gencore.viewTokensIndexMin(_collectionID) + gencore.viewCirSupply(_collectionID) + _numberOfTokens[y] - 1;\r\n            require(collectionTokenMintIndex \u003c= gencore.viewTokensIndexMax(_collectionID), \"No supply\");\r\n            for(uint256 i = 0; i \u003c _numberOfTokens[y]; i++) {\r\n                uint256 mintIndex = gencore.viewTokensIndexMin(_collectionID) + gencore.viewCirSupply(_collectionID);\r\n                gencore.airDropTokens(mintIndex, _recipients[y], _tokenData[y], _saltfun_o[y], _collectionID);\r\n            }\r\n        }\r\n    }\r\n\r\n    // mint function for allowlist or public minting\r\n\r\n    function mint(uint256 _collectionID, uint256 _numberOfTokens, uint256 _maxAllowance, string memory _tokenData, address _mintTo, bytes32[] calldata merkleProof, address _delegator, uint256 _saltfun_o) public payable {\r\n        require(setMintingCosts[_collectionID] == true \u0026\u0026 _numberOfTokens \u003e 0, \"err\");\r\n        uint256 col = _collectionID;\r\n        address mintingAddress;\r\n        uint256 phase;\r\n        string memory tokData = _tokenData;\r\n        if (block.timestamp \u003e= collectionPhases[col].allowlistStartTime \u0026\u0026 block.timestamp \u003c collectionPhases[col].allowlistEndTime) {\r\n            phase = 1;\r\n            bytes32 node;\r\n            if (_delegator != 0x0000000000000000000000000000000000000000) {\r\n                bool isAllowedToMint;\r\n                isAllowedToMint = dmc.retrieveGlobalStatusOfDelegation(_delegator, 0x8888888888888888888888888888888888888888, msg.sender, 1) || dmc.retrieveGlobalStatusOfDelegation(_delegator, 0x8888888888888888888888888888888888888888, msg.sender, 2);\r\n                if (isAllowedToMint == false) {\r\n                isAllowedToMint = dmc.retrieveGlobalStatusOfDelegation(_delegator, collectionPhases[col].delAddress, msg.sender, 1) || dmc.retrieveGlobalStatusOfDelegation(_delegator, collectionPhases[col].delAddress, msg.sender, 2);    \r\n                }\r\n                require(isAllowedToMint == true, \"No delegation\");\r\n                node = keccak256(bytes.concat(keccak256((abi.encodePacked(_delegator, _maxAllowance, tokData)))));\r\n                require(_maxAllowance \u003e= gencore.retrieveTokensMintedALPerAddress(col, _delegator) + _numberOfTokens, \"AL limit\");\r\n                mintingAddress = _delegator;\r\n            } else {\r\n                node = keccak256(bytes.concat(keccak256((abi.encodePacked(msg.sender, _maxAllowance, tokData)))));\r\n                require(_maxAllowance \u003e= gencore.retrieveTokensMintedALPerAddress(col, msg.sender) + _numberOfTokens, \"AL limit\");\r\n                mintingAddress = msg.sender;\r\n            }\r\n            require(MerkleProof.verifyCalldata(merkleProof, collectionPhases[col].merkleRoot, node), \u0027invalid proof\u0027);\r\n        } else if (block.timestamp \u003e= collectionPhases[col].publicStartTime \u0026\u0026 block.timestamp \u003c= collectionPhases[col].publicEndTime) {\r\n            phase = 2;\r\n            require(_numberOfTokens \u003c= gencore.viewMaxAllowance(col), \"Change no of tokens\");\r\n            require(gencore.retrieveTokensMintedPublicPerAddress(col, msg.sender) + _numberOfTokens \u003c= gencore.viewMaxAllowance(col), \"Max\");\r\n            mintingAddress = msg.sender;\r\n            tokData = \u0027\"public\"\u0027;\r\n        } else {\r\n            revert(\"No minting\");\r\n        }\r\n        uint256 collectionTokenMintIndex;\r\n        collectionTokenMintIndex = gencore.viewTokensIndexMin(col) + gencore.viewCirSupply(col) + _numberOfTokens - 1;\r\n        require(collectionTokenMintIndex \u003c= gencore.viewTokensIndexMax(col), \"No supply\");\r\n        require(msg.value \u003e= (getPrice(col) * _numberOfTokens), \"Wrong ETH\");\r\n        // refund excess\r\n        {\r\n            uint256 excess = calculateExcess(msg.value, getPrice(col) * _numberOfTokens);\r\n            collectionTotalAmount[col] = collectionTotalAmount[col] + msg.value - excess;\r\n        }\r\n        // check mechanism for sale option 3\r\n        if (collectionPhases[col].salesOption == 3) {\r\n            uint timeOfLastMint;\r\n            if (lastMintDate[col] == 0) {\r\n                // for only public minting set the allowliststarttime as publicstarttime\r\n                timeOfLastMint = collectionPhases[col].allowlistStartTime - collectionPhases[col].timePeriod;\r\n            } else {\r\n                timeOfLastMint =  lastMintDate[col];\r\n            }\r\n            // calculate periods and check if a period has passed in order to allow minting\r\n            uint tDiff = (block.timestamp - timeOfLastMint) / collectionPhases[col].timePeriod;\r\n            // users are able to mint after a period passes\r\n            // unminted tokens from previous periods are transferred for minting into new periods\r\n            // 1 mint at a time period\r\n            require(tDiff\u003e=1 \u0026\u0026 _numberOfTokens == 1, \"1 mint/period\");\r\n            // exclude tokens ex. airdrop tokens so they do not affect lastMintDate\r\n            lastMintDate[col] = collectionPhases[col].allowlistStartTime + (collectionPhases[col].timePeriod * (gencore.viewCirSupply(col) - excludeTokensCounter[col]));\r\n        }\r\n        // mint tokens\r\n        for(uint256 i = 0; i \u003c _numberOfTokens; i++) {\r\n            uint256 mintIndex = gencore.viewTokensIndexMin(col) + gencore.viewCirSupply(col);\r\n            gencore.mint(mintIndex, mintingAddress, _mintTo, tokData, _saltfun_o, col, phase);\r\n        }\r\n    }\r\n\r\n    // burn to mint function (does not require contract approval)\r\n\r\n    function burnToMint(uint256 _burnCollectionID, uint256 _tokenId, uint256 _mintCollectionID, uint256 _saltfun_o) public payable {\r\n        require(setMintingCosts[_mintCollectionID] == true \u0026\u0026 burnToMintCollections[_burnCollectionID][_mintCollectionID] == true, \"init err\");\r\n        require(block.timestamp \u003e= collectionPhases[_mintCollectionID].publicStartTime \u0026\u0026 block.timestamp \u003c= collectionPhases[_mintCollectionID].publicEndTime,\"No minting\");\r\n        require ((_tokenId \u003e= gencore.viewTokensIndexMin(_burnCollectionID)) \u0026\u0026 (_tokenId \u003c= gencore.viewTokensIndexMax(_burnCollectionID)), \"col/token id error\");\r\n        uint256 collectionTokenMintIndex;\r\n        collectionTokenMintIndex = gencore.viewTokensIndexMin(_mintCollectionID) + gencore.viewCirSupply(_mintCollectionID);\r\n        require(collectionTokenMintIndex \u003c= gencore.viewTokensIndexMax(_mintCollectionID), \"No supply\");\r\n        require(msg.value \u003e= getPrice(_mintCollectionID), \"Wrong ETH\");\r\n        // refund excess\r\n        {\r\n            uint256 excess = calculateExcess(msg.value, getPrice(_mintCollectionID));\r\n            collectionTotalAmount[_mintCollectionID] = collectionTotalAmount[_mintCollectionID] + msg.value - excess;\r\n        }\r\n        uint256 mintIndex = gencore.viewTokensIndexMin(_mintCollectionID) + gencore.viewCirSupply(_mintCollectionID);\r\n        // burn and mint token\r\n        address burner = msg.sender;\r\n        gencore.burnToMint(mintIndex, _burnCollectionID, _tokenId, _mintCollectionID, _saltfun_o, burner);\r\n    }\r\n\r\n    // mint and auction\r\n    \r\n    function mintAndAuction(address _recipient, string memory _tokenData, uint256 _saltfun_o, uint256 _collectionID, uint _auctionEndTime) public FunctionAdminRequired(this.mintAndAuction.selector) {\r\n        require(gencore.retrievewereDataAdded(_collectionID) == true, \"Add data\");\r\n        uint256 collectionTokenMintIndex;\r\n        collectionTokenMintIndex = gencore.viewTokensIndexMin(_collectionID) + gencore.viewCirSupply(_collectionID);\r\n        require(collectionTokenMintIndex \u003c= gencore.viewTokensIndexMax(_collectionID), \"No supply\");\r\n        uint256 mintIndex = gencore.viewTokensIndexMin(_collectionID) + gencore.viewCirSupply(_collectionID);\r\n        uint timeOfLastMint;\r\n        // 1 token per period can be minted and send to auction\r\n        // time period can be set for any sales model\r\n        if (lastMintDate[_collectionID] == 0) {\r\n        // for public sale set the allowliststarttime the same time as publicstarttime\r\n            timeOfLastMint = collectionPhases[_collectionID].allowlistStartTime - collectionPhases[_collectionID].timePeriod;\r\n        } else {\r\n            timeOfLastMint =  lastMintDate[_collectionID];\r\n        }\r\n        // calculate periods and check if a period has passed in order to allow minting\r\n        uint tDiff = (block.timestamp - timeOfLastMint) / collectionPhases[_collectionID].timePeriod;\r\n        // admins are able to mint after a period passes\r\n        require(tDiff\u003e=1, \"1 mint/period\");\r\n        lastMintDate[_collectionID] = collectionPhases[_collectionID].allowlistStartTime + (collectionPhases[_collectionID].timePeriod * ((gencore.viewCirSupply(_collectionID) - excludeTokensCounter[_collectionID])));\r\n        require(_auctionEndTime \u003e= block.timestamp + 600); // 10mins min auction\r\n        mintToAuctionData[mintIndex] = _auctionEndTime;\r\n        mintToAuctionStatus[mintIndex] = true;\r\n        // token is airdropped to the _recipient address\r\n        gencore.airDropTokens(mintIndex, _recipient, _tokenData, _saltfun_o, _collectionID);\r\n    }\r\n\r\n    // function to exclude a specific no of tokens during sales model 3 or reset lastMintDate\r\n\r\n    function excludeTokensOrResetLD(uint256 _option, uint256 _collectionID, uint256 _excludeCounter) public FunctionAdminRequired(this.excludeTokensOrResetLD.selector) { \r\n        if (_option == 1) {\r\n            excludeTokensCounter[_collectionID] = _excludeCounter;\r\n        } else {\r\n            lastMintDate[_collectionID] = 0;\r\n        }  \r\n    }\r\n\r\n    // function to refund any excess amount\r\n\r\n    function calculateExcess(uint256 _value, uint256 _price) internal returns(uint256) {\r\n        uint256 excess;\r\n        excess = _value - _price;\r\n        (bool success1, ) = payable(msg.sender).call{value: excess}(\"\");\r\n        require(success1, \"ETH failed\");\r\n        return(excess);\r\n    }\r\n\r\n    // function to initialize burn to mint for NextGen collections\r\n\r\n    function initializeBurn(uint256 _burnCollectionID, uint256 _mintCollectionID, bool _status) public FunctionAdminRequired(this.initializeBurn.selector) { \r\n        require((gencore.retrievewereDataAdded(_burnCollectionID) == true) \u0026\u0026 (gencore.retrievewereDataAdded(_mintCollectionID) == true), \"No data\");\r\n        burnToMintCollections[_burnCollectionID][_mintCollectionID] = _status;\r\n    }\r\n\r\n    // function to initialize external burn or swap to mint\r\n\r\n    function initializeExternalBurnOrSwap(address _erc721Collection, uint256 _burnCollectionID, uint256 _mintCollectionID, uint256 _tokmin, uint256 _tokmax, address _burnOrSwapAddress, bool _status) public FunctionAdminRequired(this.initializeExternalBurnOrSwap.selector) { \r\n        bytes32 externalCol = keccak256(abi.encodePacked(_erc721Collection,_burnCollectionID));\r\n        require((gencore.retrievewereDataAdded(_mintCollectionID) == true), \"No data\");\r\n        burnExternalToMintCollections[externalCol][_mintCollectionID] = _status;\r\n        burnOrSwapAddress[externalCol] = _burnOrSwapAddress;\r\n        burnOrSwapIds[externalCol][0] = _tokmin;\r\n        burnOrSwapIds[externalCol][1] = _tokmax;\r\n    }\r\n\r\n    // burn or swap to mint (requires contract approval)\r\n\r\n    function burnOrSwapExternalToMint(address _erc721Collection, uint256 _burnCollectionID, uint256 _tokenId, uint256 _mintCollectionID, string memory _tokenData, bytes32[] calldata merkleProof, uint256 _saltfun_o) public payable {\r\n        bytes32 externalCol = keccak256(abi.encodePacked(_erc721Collection,_burnCollectionID));\r\n        require(setMintingCosts[_mintCollectionID] == true \u0026\u0026 burnExternalToMintCollections[externalCol][_mintCollectionID] == true, \"init err\");\r\n        address ownerOfToken = IERC721(_erc721Collection).ownerOf(_tokenId);\r\n        if (msg.sender != ownerOfToken) {\r\n            bool isAllowedToMint;\r\n            isAllowedToMint = dmc.retrieveGlobalStatusOfDelegation(ownerOfToken, 0x8888888888888888888888888888888888888888, msg.sender, 1) || dmc.retrieveGlobalStatusOfDelegation(ownerOfToken, 0x8888888888888888888888888888888888888888, msg.sender, 2);\r\n            if (isAllowedToMint == false) {\r\n            isAllowedToMint = dmc.retrieveGlobalStatusOfDelegation(ownerOfToken, _erc721Collection, msg.sender, 1) || dmc.retrieveGlobalStatusOfDelegation(ownerOfToken, _erc721Collection, msg.sender, 2);    \r\n            }\r\n            require(isAllowedToMint == true, \"No delegation\");\r\n        }\r\n        require(_tokenId \u003e= burnOrSwapIds[externalCol][0] \u0026\u0026 _tokenId \u003c= burnOrSwapIds[externalCol][1], \"Token id does not match\");\r\n        IERC721(_erc721Collection).safeTransferFrom(ownerOfToken, burnOrSwapAddress[externalCol], _tokenId);\r\n        uint256 col = _mintCollectionID;\r\n        address mintingAddress;\r\n        uint256 phase;\r\n        string memory tokData = _tokenData;\r\n        if (block.timestamp \u003e= collectionPhases[col].allowlistStartTime \u0026\u0026 block.timestamp \u003c collectionPhases[col].allowlistEndTime) {\r\n            phase = 1;\r\n            bytes32 node;\r\n            node = keccak256(bytes.concat(keccak256((abi.encodePacked(_tokenId, tokData)))));\r\n            mintingAddress = ownerOfToken;\r\n            require(MerkleProof.verifyCalldata(merkleProof, collectionPhases[col].merkleRoot, node), \u0027invalid proof\u0027);            \r\n        } else if (block.timestamp \u003e= collectionPhases[col].publicStartTime \u0026\u0026 block.timestamp \u003c= collectionPhases[col].publicEndTime) {\r\n            phase = 2;\r\n            mintingAddress = ownerOfToken;\r\n            tokData = \u0027\"public\"\u0027;\r\n        } else {\r\n            revert(\"No minting\");\r\n        }\r\n        uint256 collectionTokenMintIndex;\r\n        collectionTokenMintIndex = gencore.viewTokensIndexMin(col) + gencore.viewCirSupply(col);\r\n        require(collectionTokenMintIndex \u003c= gencore.viewTokensIndexMax(col), \"No supply\");\r\n        require(msg.value \u003e= getPrice(col), \"Wrong ETH\");\r\n        // refund excess\r\n        {\r\n            uint256 excess = calculateExcess(msg.value, getPrice(col));\r\n            collectionTotalAmount[col] = collectionTotalAmount[col] + msg.value - excess;\r\n        }\r\n        uint256 mintIndex = gencore.viewTokensIndexMin(col) + gencore.viewCirSupply(col);\r\n        gencore.mint(mintIndex, mintingAddress, ownerOfToken, tokData, _saltfun_o, col, phase);\r\n    }\r\n\r\n    // function to set primary splits\r\n\r\n    function setPrimaryAndSecondarySplits(uint256 _collectionID, uint256 _artistPrSplit, uint256 _teamPrSplit, uint256 _artistSecSplit, uint256 _teamSecSplit) public FunctionAdminRequired(this.setPrimaryAndSecondarySplits.selector) {\r\n        require(_artistPrSplit + _teamPrSplit == 100, \"splits need to be 100%\");\r\n        require(_artistSecSplit + _teamSecSplit == 100, \"splits need to be 100%\");\r\n        collectionRoyaltiesPrimarySplits[_collectionID].artistPercentage = _artistPrSplit;\r\n        collectionRoyaltiesPrimarySplits[_collectionID].teamPercentage = _teamPrSplit;\r\n        collectionRoyaltiesSecondarySplits[_collectionID].artistPercentage = _artistSecSplit;\r\n        collectionRoyaltiesSecondarySplits[_collectionID].teamPercentage = _teamSecSplit;\r\n    }\r\n\r\n    // function to propose primary addresses and percentages for each address\r\n\r\n    function proposePrimaryAddressesAndPercentages(uint256 _collectionID, address _primaryAdd1, address _primaryAdd2, address _primaryAdd3, uint256 _add1Percentage, uint256 _add2Percentage, uint256 _add3Percentage) public ArtistOrAdminRequired(_collectionID, this.proposePrimaryAddressesAndPercentages.selector) {\r\n        require (collectionArtistPrimaryAddresses[_collectionID].approvedStatus == false, \"Already approved\");\r\n        require (_add1Percentage + _add2Percentage + _add3Percentage == collectionRoyaltiesPrimarySplits[_collectionID].artistPercentage, \"Check %\");\r\n        collectionArtistPrimaryAddresses[_collectionID].primaryAdd1 = _primaryAdd1;\r\n        collectionArtistPrimaryAddresses[_collectionID].primaryAdd2 = _primaryAdd2;\r\n        collectionArtistPrimaryAddresses[_collectionID].primaryAdd3 = _primaryAdd3;\r\n        collectionArtistPrimaryAddresses[_collectionID].add1Percentage = _add1Percentage;\r\n        collectionArtistPrimaryAddresses[_collectionID].add2Percentage = _add2Percentage;\r\n        collectionArtistPrimaryAddresses[_collectionID].add3Percentage = _add3Percentage;\r\n        collectionArtistPrimaryAddresses[_collectionID].setStatus = true;\r\n        collectionArtistPrimaryAddresses[_collectionID].approvedStatus = false;\r\n    }\r\n\r\n    // function to propose secondary addresses and percentages for each address\r\n\r\n    function proposeSecondaryAddressesAndPercentages(uint256 _collectionID, address _secondaryAdd1, address _secondaryAdd2, address _secondaryAdd3, uint256 _add1Percentage, uint256 _add2Percentage, uint256 _add3Percentage) public ArtistOrAdminRequired(_collectionID, this.proposeSecondaryAddressesAndPercentages.selector) {\r\n        require (collectionArtistSecondaryAddresses[_collectionID].approvedStatus == false, \"Already approved\");\r\n        require (_add1Percentage + _add2Percentage + _add3Percentage == collectionRoyaltiesSecondarySplits[_collectionID].artistPercentage, \"Check %\");\r\n        collectionArtistSecondaryAddresses[_collectionID].secondaryAdd1 = _secondaryAdd1;\r\n        collectionArtistSecondaryAddresses[_collectionID].secondaryAdd2 = _secondaryAdd2;\r\n        collectionArtistSecondaryAddresses[_collectionID].secondaryAdd3 = _secondaryAdd3;\r\n        collectionArtistSecondaryAddresses[_collectionID].add1Percentage = _add1Percentage;\r\n        collectionArtistSecondaryAddresses[_collectionID].add2Percentage = _add2Percentage;\r\n        collectionArtistSecondaryAddresses[_collectionID].add3Percentage = _add3Percentage;\r\n        collectionArtistSecondaryAddresses[_collectionID].setStatus = true;\r\n        collectionArtistSecondaryAddresses[_collectionID].approvedStatus = false;\r\n    }\r\n\r\n    // function to accept primary addresses and percentages\r\n\r\n    function acceptAddressesAndPercentages(uint256 _collectionID, bool _statusPrimary, bool _statusSecondary) public FunctionAdminRequired(this.acceptAddressesAndPercentages.selector) {\r\n        require(collectionArtistPrimaryAddresses[_collectionID].setStatus == true \u0026\u0026 collectionArtistSecondaryAddresses[_collectionID].setStatus == true, \"Propose Addresses\");\r\n        collectionArtistPrimaryAddresses[_collectionID].approvedStatus = _statusPrimary;\r\n        collectionArtistSecondaryAddresses[_collectionID].approvedStatus = _statusSecondary;\r\n        if (_statusPrimary == false) {\r\n            collectionArtistPrimaryAddresses[_collectionID].setStatus = false;\r\n        } else if (_statusSecondary == false) {\r\n            collectionArtistSecondaryAddresses[_collectionID].setStatus = false;\r\n        }\r\n    }\r\n\r\n    // function to transfer funds to the artist and team\r\n\r\n    function payArtist(uint256 _collectionID, address _team1, address _team2, uint256 _teamperc1, uint256 _teamperc2) public FunctionAdminRequired(this.payArtist.selector) {\r\n        require(collectionArtistPrimaryAddresses[_collectionID].approvedStatus == true, \"Accept Royalties\");\r\n        require(collectionTotalAmount[_collectionID] \u003e 0, \"Collection Balance must be grater than 0\");\r\n        require(collectionRoyaltiesPrimarySplits[_collectionID].artistPercentage + _teamperc1 + _teamperc2 == 100, \"Change percentages\");\r\n        uint256 royalties = collectionTotalAmount[_collectionID];\r\n        collectionTotalAmount[_collectionID] = 0;\r\n        address tm1 = _team1;\r\n        address tm2 = _team2;\r\n        uint256 colId = _collectionID;\r\n        uint256 artistRoyalties1;\r\n        uint256 artistRoyalties2;\r\n        uint256 artistRoyalties3;\r\n        uint256 teamRoyalties1;\r\n        uint256 teamRoyalties2;\r\n        artistRoyalties1 = royalties * collectionArtistPrimaryAddresses[colId].add1Percentage / 100;\r\n        artistRoyalties2 = royalties * collectionArtistPrimaryAddresses[colId].add2Percentage / 100;\r\n        artistRoyalties3 = royalties * collectionArtistPrimaryAddresses[colId].add3Percentage / 100;\r\n        teamRoyalties1 = royalties * _teamperc1 / 100;\r\n        teamRoyalties2 = royalties * _teamperc2 / 100;\r\n        (bool success1, ) = payable(collectionArtistPrimaryAddresses[colId].primaryAdd1).call{value: artistRoyalties1}(\"\");\r\n        (bool success2, ) = payable(collectionArtistPrimaryAddresses[colId].primaryAdd2).call{value: artistRoyalties2}(\"\");\r\n        (bool success3, ) = payable(collectionArtistPrimaryAddresses[colId].primaryAdd3).call{value: artistRoyalties3}(\"\");\r\n        (bool success4, ) = payable(tm1).call{value: teamRoyalties1}(\"\");\r\n        (bool success5, ) = payable(tm2).call{value: teamRoyalties2}(\"\");\r\n        require(success1, \"ETH failed\");\r\n        require(success2, \"ETH failed\");\r\n        require(success3, \"ETH failed\");\r\n        require(success4, \"ETH failed\");\r\n        require(success5, \"ETH failed\");\r\n    }\r\n\r\n    // function to update core contract\r\n\r\n    function updateCoreContract(address _gencore) public FunctionAdminRequired(this.updateCoreContract.selector) { \r\n        gencore = INextGenCore(_gencore);\r\n    }\r\n\r\n    // function to update admin contract\r\n\r\n    function updateAdminContract(address _newadminsContract) public FunctionAdminRequired(this.updateAdminContract.selector) {\r\n        require(INextGenAdmins(_newadminsContract).isAdminContract() == true, \"Contract is not Admin\");\r\n        adminsContract = INextGenAdmins(_newadminsContract);\r\n    }\r\n\r\n    // function to withdraw any balance from the smart contract\r\n\r\n    function emergencyWithdraw() public FunctionAdminRequired(this.emergencyWithdraw.selector) {\r\n        uint balance = address(this).balance;\r\n        address admin = adminsContract.owner();\r\n        (bool success, ) = payable(admin).call{value: balance}(\"\");\r\n        require(success, \"ETH failed\");\r\n        emit Withdraw(msg.sender, success, balance);\r\n    }\r\n\r\n    // function to retrieve primary splits between artist and team\r\n\r\n    function retrievePrimarySplits(uint256 _collectionID) public view returns(uint256, uint256){\r\n        return (collectionRoyaltiesPrimarySplits[_collectionID].artistPercentage, collectionRoyaltiesPrimarySplits[_collectionID].teamPercentage);\r\n    }\r\n\r\n    // function to retrieve primary addresses and percentages\r\n\r\n    function retrievePrimaryAddressesAndPercentages(uint256 _collectionID) public view returns(address, address, address, uint256, uint256, uint256, bool){\r\n        return (collectionArtistPrimaryAddresses[_collectionID].primaryAdd1, collectionArtistPrimaryAddresses[_collectionID].primaryAdd2, collectionArtistPrimaryAddresses[_collectionID].primaryAdd3, collectionArtistPrimaryAddresses[_collectionID].add1Percentage, collectionArtistPrimaryAddresses[_collectionID].add2Percentage, collectionArtistPrimaryAddresses[_collectionID].add3Percentage, collectionArtistPrimaryAddresses[_collectionID].approvedStatus);\r\n    }\r\n\r\n    // function to retrieve secondary splits between artist and team\r\n\r\n    function retrieveSecondarySplits(uint256 _collectionID) public view returns(uint256, uint256){\r\n        return (collectionRoyaltiesSecondarySplits[_collectionID].artistPercentage, collectionRoyaltiesSecondarySplits[_collectionID].teamPercentage);\r\n    }\r\n\r\n    // function to retrieve secondary addresses and percentages\r\n\r\n    function retrieveSecondaryAddressesAndPercentages(uint256 _collectionID) public view returns(address, address, address, uint256, uint256, uint256, bool){\r\n        return (collectionArtistSecondaryAddresses[_collectionID].secondaryAdd1, collectionArtistSecondaryAddresses[_collectionID].secondaryAdd2, collectionArtistSecondaryAddresses[_collectionID].secondaryAdd3, collectionArtistSecondaryAddresses[_collectionID].add1Percentage, collectionArtistSecondaryAddresses[_collectionID].add2Percentage, collectionArtistSecondaryAddresses[_collectionID].add3Percentage, collectionArtistSecondaryAddresses[_collectionID].approvedStatus);\r\n    }\r\n\r\n    // function to retrieve the phases and merkle root of a collection\r\n\r\n    function retrieveCollectionPhases(uint256 _collectionID) public view returns(uint, uint, bytes32, uint, uint){\r\n        return (collectionPhases[_collectionID].allowlistStartTime, collectionPhases[_collectionID].allowlistEndTime, collectionPhases[_collectionID].merkleRoot, collectionPhases[_collectionID].publicStartTime, collectionPhases[_collectionID].publicEndTime);\r\n    }\r\n\r\n    // function to retrieve the minting details of a collection\r\n\r\n    function retrieveCollectionMintingDetails(uint256 _collectionID) public view returns(uint256, uint256, uint256, uint256, uint8, address){\r\n        return (collectionPhases[_collectionID].collectionMintCost, collectionPhases[_collectionID].collectionEndMintCost, collectionPhases[_collectionID].rate, collectionPhases[_collectionID].timePeriod, collectionPhases[_collectionID].salesOption, collectionPhases[_collectionID].delAddress);\r\n    }\r\n\r\n    // retrieve minter contract status\r\n\r\n    function isMinterContract() external view returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    // retrieve minting end time\r\n\r\n    function getEndTime(uint256 _collectionID) external view returns (uint) {\r\n        return collectionPhases[_collectionID].publicEndTime;\r\n    }\r\n\r\n    // retrieve auction end time\r\n\r\n    function getAuctionEndTime(uint256 _tokenId) external view returns (uint) {\r\n        return mintToAuctionData[_tokenId];\r\n    }\r\n\r\n    // retrieve auction status\r\n\r\n    function getAuctionStatus(uint256 _tokenId) external view  returns (bool) {\r\n        return mintToAuctionStatus[_tokenId];\r\n    }\r\n\r\n    // retrieve the minting price of collection\r\n\r\n    function getPrice(uint256 _collectionId) public view returns (uint256) {\r\n        uint tDiff;\r\n        if (collectionPhases[_collectionId].salesOption == 3) {\r\n            // periodic sale model\r\n            // if rate \u003e 0 minting price increases by rate (percentage) during each mint\r\n            if (collectionPhases[_collectionId].rate \u003e 0) {\r\n                return collectionPhases[_collectionId].collectionMintCost + ((collectionPhases[_collectionId].collectionMintCost * collectionPhases[_collectionId].rate / 100) * (gencore.viewCirSupply(_collectionId) - excludeTokensCounter[_collectionId]));\r\n            } else {\r\n                return collectionPhases[_collectionId].collectionMintCost;\r\n            }\r\n        } else if (collectionPhases[_collectionId].salesOption == 2 \u0026\u0026 block.timestamp \u003e= collectionPhases[_collectionId].allowlistStartTime \u0026\u0026 block.timestamp \u003c= collectionPhases[_collectionId].publicEndTime){\r\n            // decreases during a time period\r\n            // if only public minting set allowlistStartTime = publicStartTime\r\n            // if rate = 0 exponential descending model, otherwise, linear descending model\r\n            // if rate is set the linear decrase each period per rate\r\n            tDiff = (block.timestamp - collectionPhases[_collectionId].allowlistStartTime) / collectionPhases[_collectionId].timePeriod;\r\n            uint256 price;\r\n            uint256 decreaserate;\r\n            if (collectionPhases[_collectionId].rate == 0) {\r\n                price = collectionPhases[_collectionId].collectionMintCost / (tDiff + 1);\r\n                decreaserate = ((price - (collectionPhases[_collectionId].collectionMintCost / (tDiff + 2))) / collectionPhases[_collectionId].timePeriod) * ((block.timestamp - (tDiff * collectionPhases[_collectionId].timePeriod) - collectionPhases[_collectionId].allowlistStartTime));\r\n            } else {\r\n                if (((collectionPhases[_collectionId].collectionMintCost - collectionPhases[_collectionId].collectionEndMintCost) / (collectionPhases[_collectionId].rate)) \u003e= tDiff) {\r\n                    price = collectionPhases[_collectionId].collectionMintCost - (tDiff * collectionPhases[_collectionId].rate);\r\n                } else {\r\n                    price = collectionPhases[_collectionId].collectionEndMintCost;\r\n                }\r\n            }\r\n            if (price - decreaserate \u003e collectionPhases[_collectionId].collectionEndMintCost) {\r\n                return price - decreaserate; \r\n            } else {\r\n                return collectionPhases[_collectionId].collectionEndMintCost;\r\n            }\r\n        } else {\r\n            // fixed price model\r\n            return collectionPhases[_collectionId].collectionMintCost;\r\n        }\r\n    }\r\n\r\n}"}}